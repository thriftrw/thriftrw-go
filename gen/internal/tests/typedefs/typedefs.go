// Code generated by thriftrw v1.20.0. DO NOT EDIT.
// @generated

package typedefs

import (
	bytes "bytes"
	base64 "encoding/base64"
	errors "errors"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	enums "go.uber.org/thriftrw/gen/internal/tests/enums"
	structs "go.uber.org/thriftrw/gen/internal/tests/structs"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	strings "strings"
)

type _Set_Binary_sliceType_ValueList [][]byte

func (v _Set_Binary_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := wire.NewValueBinary(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Binary_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Binary_sliceType_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_Binary_sliceType_ValueList) Close() {}

func _Set_Binary_sliceType_Read(s wire.ValueList) ([][]byte, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([][]byte, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetBinary(), error(nil)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Set_Binary_sliceType_Equals(lhs, rhs [][]byte) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if bytes.Equal(x, y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

type _Set_Binary_sliceType_Zapper [][]byte

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Binary_sliceType_Zapper.
func (s _Set_Binary_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		enc.AppendString(base64.StdEncoding.EncodeToString(v))
	}
	return err
}

type BinarySet [][]byte

// ToWire translates BinarySet into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v BinarySet) ToWire() (wire.Value, error) {
	x := ([][]byte)(v)
	return wire.NewValueSet(_Set_Binary_sliceType_ValueList(x)), error(nil)
}

// String returns a readable string representation of BinarySet.
func (v BinarySet) String() string {
	x := ([][]byte)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes BinarySet from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *BinarySet) FromWire(w wire.Value) error {
	x, err := _Set_Binary_sliceType_Read(w.GetSet())
	*v = (BinarySet)(x)
	return err
}

// Equals returns true if this BinarySet is equal to the provided
// BinarySet.
func (lhs BinarySet) Equals(rhs BinarySet) bool {
	return _Set_Binary_sliceType_Equals(([][]byte)(lhs), ([][]byte)(rhs))
}

func (v BinarySet) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_Set_Binary_sliceType_Zapper)(([][]byte)(v))).MarshalLogArray(enc)
}

type DefaultPrimitiveTypedef struct {
	State *State `json:"state,omitempty"`
}

func _State_ptr(v State) *State {
	return &v
}

// ToWire translates a DefaultPrimitiveTypedef struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DefaultPrimitiveTypedef) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.State == nil {
		v.State = _State_ptr("hello")
	}
	{
		w, err = v.State.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _State_Read(w wire.Value) (State, error) {
	var x State
	err := x.FromWire(w)
	return x, err
}

// FromWire deserializes a DefaultPrimitiveTypedef struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DefaultPrimitiveTypedef struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DefaultPrimitiveTypedef
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DefaultPrimitiveTypedef) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x State
				x, err = _State_Read(field.Value)
				v.State = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if v.State == nil {
		v.State = _State_ptr("hello")
	}

	return nil
}

// String returns a readable string representation of a DefaultPrimitiveTypedef
// struct.
func (v *DefaultPrimitiveTypedef) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.State != nil {
		fields[i] = fmt.Sprintf("State: %v", *(v.State))
		i++
	}

	return fmt.Sprintf("DefaultPrimitiveTypedef{%v}", strings.Join(fields[:i], ", "))
}

func _State_EqualsPtr(lhs, rhs *State) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this DefaultPrimitiveTypedef match the
// provided DefaultPrimitiveTypedef.
//
// This function performs a deep comparison.
func (v *DefaultPrimitiveTypedef) Equals(rhs *DefaultPrimitiveTypedef) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_State_EqualsPtr(v.State, rhs.State) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DefaultPrimitiveTypedef.
func (v *DefaultPrimitiveTypedef) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.State != nil {
		enc.AddString("state", (string)(*v.State))
	}
	return err
}

// GetState returns the value of State if it is set or its
// default value if it is unset.
func (v *DefaultPrimitiveTypedef) GetState() (o State) {
	if v != nil && v.State != nil {
		return *v.State
	}
	o = "hello"
	return
}

// IsSetState returns true if State is not nil.
func (v *DefaultPrimitiveTypedef) IsSetState() bool {
	return v != nil && v.State != nil
}

type _Map_Edge_Edge_MapItemList []struct {
	Key   *structs.Edge
	Value *structs.Edge
}

func (m _Map_Edge_Edge_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Edge_Edge_MapItemList) Size() int {
	return len(m)
}

func (_Map_Edge_Edge_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_Edge_Edge_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_Edge_Edge_MapItemList) Close() {}

func _Edge_Read(w wire.Value) (*structs.Edge, error) {
	var v structs.Edge
	err := v.FromWire(w)
	return &v, err
}

func _Map_Edge_Edge_Read(m wire.MapItemList) ([]struct {
	Key   *structs.Edge
	Value *structs.Edge
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]struct {
		Key   *structs.Edge
		Value *structs.Edge
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Edge_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Edge_Read(x.Value)
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   *structs.Edge
			Value *structs.Edge
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _Map_Edge_Edge_Equals(lhs, rhs []struct {
	Key   *structs.Edge
	Value *structs.Edge
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !lk.Equals(rk) {
				continue
			}

			if !lv.Equals(rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

type _Map_Edge_Edge_Item_Zapper struct {
	Key   *structs.Edge
	Value *structs.Edge
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Edge_Edge_Item_Zapper.
func (v _Map_Edge_Edge_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_Edge_Edge_Zapper []struct {
	Key   *structs.Edge
	Value *structs.Edge
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Edge_Edge_Zapper.
func (m _Map_Edge_Edge_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err = multierr.Append(err, enc.AppendObject(_Map_Edge_Edge_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type EdgeMap []struct {
	Key   *structs.Edge
	Value *structs.Edge
}

// ToWire translates EdgeMap into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v EdgeMap) ToWire() (wire.Value, error) {
	x := ([]struct {
		Key   *structs.Edge
		Value *structs.Edge
	})(v)
	return wire.NewValueMap(_Map_Edge_Edge_MapItemList(x)), error(nil)
}

// String returns a readable string representation of EdgeMap.
func (v EdgeMap) String() string {
	x := ([]struct {
		Key   *structs.Edge
		Value *structs.Edge
	})(v)
	return fmt.Sprint(x)
}

// FromWire deserializes EdgeMap from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *EdgeMap) FromWire(w wire.Value) error {
	x, err := _Map_Edge_Edge_Read(w.GetMap())
	*v = (EdgeMap)(x)
	return err
}

// Equals returns true if this EdgeMap is equal to the provided
// EdgeMap.
func (lhs EdgeMap) Equals(rhs EdgeMap) bool {
	return _Map_Edge_Edge_Equals(([]struct {
		Key   *structs.Edge
		Value *structs.Edge
	})(lhs), ([]struct {
		Key   *structs.Edge
		Value *structs.Edge
	})(rhs))
}

func (v EdgeMap) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_Map_Edge_Edge_Zapper)(([]struct {
		Key   *structs.Edge
		Value *structs.Edge
	})(v))).MarshalLogArray(enc)
}

type Event struct {
	UUID *UUID      `json:"uuid,required"`
	Time *Timestamp `json:"time,omitempty"`
}

// ToWire translates a Event struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Event) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UUID == nil {
		return w, errors.New("field UUID of Event is required")
	}
	w, err = v.UUID.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Time != nil {
		w, err = v.Time.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _UUID_Read(w wire.Value) (*UUID, error) {
	var x UUID
	err := x.FromWire(w)
	return &x, err
}

func _Timestamp_Read(w wire.Value) (Timestamp, error) {
	var x Timestamp
	err := x.FromWire(w)
	return x, err
}

// FromWire deserializes a Event struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Event struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Event
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Event) FromWire(w wire.Value) error {
	var err error

	uuidIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.UUID, err = _UUID_Read(field.Value)
				if err != nil {
					return err
				}
				uuidIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x Timestamp
				x, err = _Timestamp_Read(field.Value)
				v.Time = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !uuidIsSet {
		return errors.New("field UUID of Event is required")
	}

	return nil
}

// String returns a readable string representation of a Event
// struct.
func (v *Event) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("UUID: %v", v.UUID)
	i++
	if v.Time != nil {
		fields[i] = fmt.Sprintf("Time: %v", *(v.Time))
		i++
	}

	return fmt.Sprintf("Event{%v}", strings.Join(fields[:i], ", "))
}

func _Timestamp_EqualsPtr(lhs, rhs *Timestamp) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Event match the
// provided Event.
//
// This function performs a deep comparison.
func (v *Event) Equals(rhs *Event) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.UUID.Equals(rhs.UUID) {
		return false
	}
	if !_Timestamp_EqualsPtr(v.Time, rhs.Time) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Event.
func (v *Event) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("uuid", (*I128)(v.UUID)))
	if v.Time != nil {
		enc.AddInt64("time", (int64)(*v.Time))
	}
	return err
}

// GetUUID returns the value of UUID if it is set or its
// zero value if it is unset.
func (v *Event) GetUUID() (o *UUID) {
	if v != nil {
		o = v.UUID
	}
	return
}

// IsSetUUID returns true if UUID is not nil.
func (v *Event) IsSetUUID() bool {
	return v != nil && v.UUID != nil
}

// GetTime returns the value of Time if it is set or its
// zero value if it is unset.
func (v *Event) GetTime() (o Timestamp) {
	if v != nil && v.Time != nil {
		return *v.Time
	}

	return
}

// IsSetTime returns true if Time is not nil.
func (v *Event) IsSetTime() bool {
	return v != nil && v.Time != nil
}

type _List_Event_ValueList []*Event

func (v _List_Event_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Event_ValueList) Size() int {
	return len(v)
}

func (_List_Event_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Event_ValueList) Close() {}

func _Event_Read(w wire.Value) (*Event, error) {
	var v Event
	err := v.FromWire(w)
	return &v, err
}

func _List_Event_Read(l wire.ValueList) ([]*Event, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Event, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Event_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_Event_Equals(lhs, rhs []*Event) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

type _List_Event_Zapper []*Event

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Event_Zapper.
func (l _List_Event_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type EventGroup []*Event

// ToWire translates EventGroup into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v EventGroup) ToWire() (wire.Value, error) {
	x := ([]*Event)(v)
	return wire.NewValueList(_List_Event_ValueList(x)), error(nil)
}

// String returns a readable string representation of EventGroup.
func (v EventGroup) String() string {
	x := ([]*Event)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes EventGroup from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *EventGroup) FromWire(w wire.Value) error {
	x, err := _List_Event_Read(w.GetList())
	*v = (EventGroup)(x)
	return err
}

// Equals returns true if this EventGroup is equal to the provided
// EventGroup.
func (lhs EventGroup) Equals(rhs EventGroup) bool {
	return _List_Event_Equals(([]*Event)(lhs), ([]*Event)(rhs))
}

func (v EventGroup) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_List_Event_Zapper)(([]*Event)(v))).MarshalLogArray(enc)
}

type _Set_Frame_sliceType_ValueList []*structs.Frame

func (v _Set_Frame_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Frame_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Frame_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Frame_sliceType_ValueList) Close() {}

func _Frame_Read(w wire.Value) (*structs.Frame, error) {
	var v structs.Frame
	err := v.FromWire(w)
	return &v, err
}

func _Set_Frame_sliceType_Read(s wire.ValueList) ([]*structs.Frame, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*structs.Frame, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Frame_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Set_Frame_sliceType_Equals(lhs, rhs []*structs.Frame) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

type _Set_Frame_sliceType_Zapper []*structs.Frame

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Frame_sliceType_Zapper.
func (s _Set_Frame_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type FrameGroup []*structs.Frame

// ToWire translates FrameGroup into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v FrameGroup) ToWire() (wire.Value, error) {
	x := ([]*structs.Frame)(v)
	return wire.NewValueSet(_Set_Frame_sliceType_ValueList(x)), error(nil)
}

// String returns a readable string representation of FrameGroup.
func (v FrameGroup) String() string {
	x := ([]*structs.Frame)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes FrameGroup from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *FrameGroup) FromWire(w wire.Value) error {
	x, err := _Set_Frame_sliceType_Read(w.GetSet())
	*v = (FrameGroup)(x)
	return err
}

// Equals returns true if this FrameGroup is equal to the provided
// FrameGroup.
func (lhs FrameGroup) Equals(rhs FrameGroup) bool {
	return _Set_Frame_sliceType_Equals(([]*structs.Frame)(lhs), ([]*structs.Frame)(rhs))
}

func (v FrameGroup) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_Set_Frame_sliceType_Zapper)(([]*structs.Frame)(v))).MarshalLogArray(enc)
}

func _EnumWithValues_Read(w wire.Value) (enums.EnumWithValues, error) {
	var v enums.EnumWithValues
	err := v.FromWire(w)
	return v, err
}

type MyEnum enums.EnumWithValues

// MyEnumPtr returns a pointer to a MyEnum
func (v MyEnum) Ptr() *MyEnum {
	return &v
}

// ToWire translates MyEnum into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v MyEnum) ToWire() (wire.Value, error) {
	x := (enums.EnumWithValues)(v)
	return x.ToWire()
}

// String returns a readable string representation of MyEnum.
func (v MyEnum) String() string {
	x := (enums.EnumWithValues)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes MyEnum from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *MyEnum) FromWire(w wire.Value) error {
	x, err := _EnumWithValues_Read(w)
	*v = (MyEnum)(x)
	return err
}

// Equals returns true if this MyEnum is equal to the provided
// MyEnum.
func (lhs MyEnum) Equals(rhs MyEnum) bool {
	return (enums.EnumWithValues)(lhs).Equals((enums.EnumWithValues)(rhs))
}

func (v MyEnum) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((enums.EnumWithValues)(v)).MarshalLogObject(enc)
}

type PDF []byte

// ToWire translates PDF into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v PDF) ToWire() (wire.Value, error) {
	x := ([]byte)(v)
	return wire.NewValueBinary(x), error(nil)
}

// String returns a readable string representation of PDF.
func (v PDF) String() string {
	x := ([]byte)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes PDF from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *PDF) FromWire(w wire.Value) error {
	x, err := w.GetBinary(), error(nil)
	*v = (PDF)(x)
	return err
}

// Equals returns true if this PDF is equal to the provided
// PDF.
func (lhs PDF) Equals(rhs PDF) bool {
	return bytes.Equal(([]byte)(lhs), ([]byte)(rhs))
}

type _Map_Point_Point_MapItemList []struct {
	Key   *structs.Point
	Value *structs.Point
}

func (m _Map_Point_Point_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Point_Point_MapItemList) Size() int {
	return len(m)
}

func (_Map_Point_Point_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_Point_Point_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_Point_Point_MapItemList) Close() {}

func _Point_Read(w wire.Value) (*structs.Point, error) {
	var v structs.Point
	err := v.FromWire(w)
	return &v, err
}

func _Map_Point_Point_Read(m wire.MapItemList) ([]struct {
	Key   *structs.Point
	Value *structs.Point
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]struct {
		Key   *structs.Point
		Value *structs.Point
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Point_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Point_Read(x.Value)
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   *structs.Point
			Value *structs.Point
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _Map_Point_Point_Equals(lhs, rhs []struct {
	Key   *structs.Point
	Value *structs.Point
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !lk.Equals(rk) {
				continue
			}

			if !lv.Equals(rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

type _Map_Point_Point_Item_Zapper struct {
	Key   *structs.Point
	Value *structs.Point
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Point_Point_Item_Zapper.
func (v _Map_Point_Point_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_Point_Point_Zapper []struct {
	Key   *structs.Point
	Value *structs.Point
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Point_Point_Zapper.
func (m _Map_Point_Point_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err = multierr.Append(err, enc.AppendObject(_Map_Point_Point_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type PointMap []struct {
	Key   *structs.Point
	Value *structs.Point
}

// ToWire translates PointMap into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v PointMap) ToWire() (wire.Value, error) {
	x := ([]struct {
		Key   *structs.Point
		Value *structs.Point
	})(v)
	return wire.NewValueMap(_Map_Point_Point_MapItemList(x)), error(nil)
}

// String returns a readable string representation of PointMap.
func (v PointMap) String() string {
	x := ([]struct {
		Key   *structs.Point
		Value *structs.Point
	})(v)
	return fmt.Sprint(x)
}

// FromWire deserializes PointMap from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *PointMap) FromWire(w wire.Value) error {
	x, err := _Map_Point_Point_Read(w.GetMap())
	*v = (PointMap)(x)
	return err
}

// Equals returns true if this PointMap is equal to the provided
// PointMap.
func (lhs PointMap) Equals(rhs PointMap) bool {
	return _Map_Point_Point_Equals(([]struct {
		Key   *structs.Point
		Value *structs.Point
	})(lhs), ([]struct {
		Key   *structs.Point
		Value *structs.Point
	})(rhs))
}

func (v PointMap) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_Map_Point_Point_Zapper)(([]struct {
		Key   *structs.Point
		Value *structs.Point
	})(v))).MarshalLogArray(enc)
}

type State string

// StatePtr returns a pointer to a State
func (v State) Ptr() *State {
	return &v
}

// ToWire translates State into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v State) ToWire() (wire.Value, error) {
	x := (string)(v)
	return wire.NewValueString(x), error(nil)
}

// String returns a readable string representation of State.
func (v State) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes State from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *State) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (State)(x)
	return err
}

// Equals returns true if this State is equal to the provided
// State.
func (lhs State) Equals(rhs State) bool {
	return ((string)(lhs) == (string)(rhs))
}

type _Map_State_I64_MapItemList map[State]int64

func (m _Map_State_I64_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI64(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_State_I64_MapItemList) Size() int {
	return len(m)
}

func (_Map_State_I64_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_State_I64_MapItemList) ValueType() wire.Type {
	return wire.TI64
}

func (_Map_State_I64_MapItemList) Close() {}

func _Map_State_I64_Read(m wire.MapItemList) (map[State]int64, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI64 {
		return nil, nil
	}

	o := make(map[State]int64, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _State_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI64(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_State_I64_Equals(lhs, rhs map[State]int64) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

type _Map_State_I64_Zapper map[State]int64

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_State_I64_Zapper.
func (m _Map_State_I64_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddInt64((string)(k), v)
	}
	return err
}

type StateMap map[State]int64

// ToWire translates StateMap into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v StateMap) ToWire() (wire.Value, error) {
	x := (map[State]int64)(v)
	return wire.NewValueMap(_Map_State_I64_MapItemList(x)), error(nil)
}

// String returns a readable string representation of StateMap.
func (v StateMap) String() string {
	x := (map[State]int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes StateMap from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *StateMap) FromWire(w wire.Value) error {
	x, err := _Map_State_I64_Read(w.GetMap())
	*v = (StateMap)(x)
	return err
}

// Equals returns true if this StateMap is equal to the provided
// StateMap.
func (lhs StateMap) Equals(rhs StateMap) bool {
	return _Map_State_I64_Equals((map[State]int64)(lhs), (map[State]int64)(rhs))
}

func (v StateMap) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((_Map_State_I64_Zapper)((map[State]int64)(v))).MarshalLogObject(enc)
}

// Number of seconds since epoch.
//
// Deprecated: Use ISOTime instead.
type Timestamp int64

// TimestampPtr returns a pointer to a Timestamp
func (v Timestamp) Ptr() *Timestamp {
	return &v
}

// ToWire translates Timestamp into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v Timestamp) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of Timestamp.
func (v Timestamp) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes Timestamp from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *Timestamp) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (Timestamp)(x)
	return err
}

// Equals returns true if this Timestamp is equal to the provided
// Timestamp.
func (lhs Timestamp) Equals(rhs Timestamp) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type Transition struct {
	FromState State      `json:"fromState,required"`
	ToState   State      `json:"toState,required"`
	Events    EventGroup `json:"events,omitempty"`
}

// ToWire translates a Transition struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Transition) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = v.FromState.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = v.ToState.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Events != nil {
		w, err = v.Events.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EventGroup_Read(w wire.Value) (EventGroup, error) {
	var x EventGroup
	err := x.FromWire(w)
	return x, err
}

// FromWire deserializes a Transition struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Transition struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Transition
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Transition) FromWire(w wire.Value) error {
	var err error

	fromStateIsSet := false
	toStateIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.FromState, err = _State_Read(field.Value)
				if err != nil {
					return err
				}
				fromStateIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.ToState, err = _State_Read(field.Value)
				if err != nil {
					return err
				}
				toStateIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Events, err = _EventGroup_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !fromStateIsSet {
		return errors.New("field FromState of Transition is required")
	}

	if !toStateIsSet {
		return errors.New("field ToState of Transition is required")
	}

	return nil
}

// String returns a readable string representation of a Transition
// struct.
func (v *Transition) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("FromState: %v", v.FromState)
	i++
	fields[i] = fmt.Sprintf("ToState: %v", v.ToState)
	i++
	if v.Events != nil {
		fields[i] = fmt.Sprintf("Events: %v", v.Events)
		i++
	}

	return fmt.Sprintf("Transition{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Transition match the
// provided Transition.
//
// This function performs a deep comparison.
func (v *Transition) Equals(rhs *Transition) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.FromState == rhs.FromState) {
		return false
	}
	if !(v.ToState == rhs.ToState) {
		return false
	}
	if !((v.Events == nil && rhs.Events == nil) || (v.Events != nil && rhs.Events != nil && v.Events.Equals(rhs.Events))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Transition.
func (v *Transition) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("fromState", (string)(v.FromState))
	enc.AddString("toState", (string)(v.ToState))
	if v.Events != nil {
		err = multierr.Append(err, enc.AddArray("events", (_List_Event_Zapper)(([]*Event)(v.Events))))
	}
	return err
}

// GetFromState returns the value of FromState if it is set or its
// zero value if it is unset.
func (v *Transition) GetFromState() (o State) {
	if v != nil {
		o = v.FromState
	}
	return
}

// GetToState returns the value of ToState if it is set or its
// zero value if it is unset.
func (v *Transition) GetToState() (o State) {
	if v != nil {
		o = v.ToState
	}
	return
}

// GetEvents returns the value of Events if it is set or its
// zero value if it is unset.
func (v *Transition) GetEvents() (o EventGroup) {
	if v != nil && v.Events != nil {
		return v.Events
	}

	return
}

// IsSetEvents returns true if Events is not nil.
func (v *Transition) IsSetEvents() bool {
	return v != nil && v.Events != nil
}

type UUID I128

// ToWire translates UUID into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v *UUID) ToWire() (wire.Value, error) {
	x := (*I128)(v)
	return x.ToWire()
}

// String returns a readable string representation of UUID.
func (v *UUID) String() string {
	x := (*I128)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UUID from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UUID) FromWire(w wire.Value) error {
	return (*I128)(v).FromWire(w)
}

// Equals returns true if this UUID is equal to the provided
// UUID.
func (lhs *UUID) Equals(rhs *UUID) bool {
	return (*I128)(lhs).Equals((*I128)(rhs))
}

func (v *UUID) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((*I128)(v)).MarshalLogObject(enc)
}

type I128 struct {
	High int64 `json:"high,required"`
	Low  int64 `json:"low,required"`
}

// ToWire translates a I128 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *I128) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI64(v.High), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI64(v.Low), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a I128 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a I128 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v I128
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *I128) FromWire(w wire.Value) error {
	var err error

	highIsSet := false
	lowIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				v.High, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				highIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				v.Low, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				lowIsSet = true
			}
		}
	}

	if !highIsSet {
		return errors.New("field High of I128 is required")
	}

	if !lowIsSet {
		return errors.New("field Low of I128 is required")
	}

	return nil
}

// String returns a readable string representation of a I128
// struct.
func (v *I128) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("High: %v", v.High)
	i++
	fields[i] = fmt.Sprintf("Low: %v", v.Low)
	i++

	return fmt.Sprintf("I128{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this I128 match the
// provided I128.
//
// This function performs a deep comparison.
func (v *I128) Equals(rhs *I128) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.High == rhs.High) {
		return false
	}
	if !(v.Low == rhs.Low) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of I128.
func (v *I128) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddInt64("high", v.High)
	enc.AddInt64("low", v.Low)
	return err
}

// GetHigh returns the value of High if it is set or its
// zero value if it is unset.
func (v *I128) GetHigh() (o int64) {
	if v != nil {
		o = v.High
	}
	return
}

// GetLow returns the value of Low if it is set or its
// zero value if it is unset.
func (v *I128) GetLow() (o int64) {
	if v != nil {
		o = v.Low
	}
	return
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "typedefs",
	Package:  "go.uber.org/thriftrw/gen/internal/tests/typedefs",
	FilePath: "typedefs.thrift",
	SHA1:     "c44a85a79e17ab1c29e271bdef1909abe37fbb97",
	Includes: []*thriftreflect.ThriftModule{
		enums.ThriftModule,
		structs.ThriftModule,
	},
	Raw: rawIDL,
}

const rawIDL = "include \"./structs.thrift\"\ninclude \"./enums.thrift\"\n\n/**\n * Number of seconds since epoch.\n *\n * Deprecated: Use ISOTime instead.\n */\ntypedef i64 Timestamp  // alias of primitive\ntypedef string State\n\ntypedef i128 UUID  // alias of struct\n\ntypedef list<Event> EventGroup  // alias fo collection\n\nstruct i128 {\n    1: required i64 high\n    2: required i64 low\n}\n\nstruct Event {\n    1: required UUID uuid  // required typedef\n    2: optional Timestamp time  // optional typedef\n}\n\nstruct DefaultPrimitiveTypedef {\n    1: optional State state = \"hello\"\n}\n\nstruct Transition {\n    1: required State fromState\n    2: required State toState\n    3: optional EventGroup events\n}\n\ntypedef binary PDF  // alias of []byte\n\ntypedef set<structs.Frame> FrameGroup\n\ntypedef map<structs.Point, structs.Point> PointMap\n\ntypedef set<binary> BinarySet\n\ntypedef map<structs.Edge, structs.Edge> EdgeMap\n\ntypedef map<State, i64> StateMap\n\ntypedef enums.EnumWithValues MyEnum\n"
