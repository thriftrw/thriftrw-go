// Code generated by thriftrw v1.20.0. DO NOT EDIT.
// @generated

package collision

import (
	bytes "bytes"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	math "math"
	strconv "strconv"
	strings "strings"
)

var StructConstant *StructCollision2 = &StructCollision2{
	CollisionField:  false,
	CollisionField2: "false indeed",
}

type AccessorConflict struct {
	Name       *string `json:"name,omitempty"`
	GetName2   *string `json:"get_name,omitempty"`
	IsSetName2 *bool   `json:"is_set_name,omitempty"`
}

// ToWire translates a AccessorConflict struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *AccessorConflict) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.GetName2 != nil {
		w, err = wire.NewValueString(*(v.GetName2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.IsSetName2 != nil {
		w, err = wire.NewValueBool(*(v.IsSetName2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a AccessorConflict struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a AccessorConflict struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v AccessorConflict
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *AccessorConflict) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.GetName2 = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.IsSetName2 = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a AccessorConflict
// struct.
func (v *AccessorConflict) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.GetName2 != nil {
		fields[i] = fmt.Sprintf("GetName2: %v", *(v.GetName2))
		i++
	}
	if v.IsSetName2 != nil {
		fields[i] = fmt.Sprintf("IsSetName2: %v", *(v.IsSetName2))
		i++
	}

	return fmt.Sprintf("AccessorConflict{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this AccessorConflict match the
// provided AccessorConflict.
//
// This function performs a deep comparison.
func (v *AccessorConflict) Equals(rhs *AccessorConflict) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.GetName2, rhs.GetName2) {
		return false
	}
	if !_Bool_EqualsPtr(v.IsSetName2, rhs.IsSetName2) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of AccessorConflict.
func (v *AccessorConflict) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.GetName2 != nil {
		enc.AddString("get_name", *v.GetName2)
	}
	if v.IsSetName2 != nil {
		enc.AddBool("is_set_name", *v.IsSetName2)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *AccessorConflict) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *AccessorConflict) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetGetName2 returns the value of GetName2 if it is set or its
// zero value if it is unset.
func (v *AccessorConflict) GetGetName2() (o string) {
	if v != nil && v.GetName2 != nil {
		return *v.GetName2
	}

	return
}

// IsSetGetName2 returns true if GetName2 is not nil.
func (v *AccessorConflict) IsSetGetName2() bool {
	return v != nil && v.GetName2 != nil
}

// GetIsSetName2 returns the value of IsSetName2 if it is set or its
// zero value if it is unset.
func (v *AccessorConflict) GetIsSetName2() (o bool) {
	if v != nil && v.IsSetName2 != nil {
		return *v.IsSetName2
	}

	return
}

// IsSetIsSetName2 returns true if IsSetName2 is not nil.
func (v *AccessorConflict) IsSetIsSetName2() bool {
	return v != nil && v.IsSetName2 != nil
}

type AccessorNoConflict struct {
	Getname *string `json:"getname,omitempty"`
	GetName *string `json:"get_name,omitempty"`
}

// ToWire translates a AccessorNoConflict struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *AccessorNoConflict) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Getname != nil {
		w, err = wire.NewValueString(*(v.Getname)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.GetName != nil {
		w, err = wire.NewValueString(*(v.GetName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a AccessorNoConflict struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a AccessorNoConflict struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v AccessorNoConflict
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *AccessorNoConflict) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Getname = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.GetName = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a AccessorNoConflict
// struct.
func (v *AccessorNoConflict) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Getname != nil {
		fields[i] = fmt.Sprintf("Getname: %v", *(v.Getname))
		i++
	}
	if v.GetName != nil {
		fields[i] = fmt.Sprintf("GetName: %v", *(v.GetName))
		i++
	}

	return fmt.Sprintf("AccessorNoConflict{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this AccessorNoConflict match the
// provided AccessorNoConflict.
//
// This function performs a deep comparison.
func (v *AccessorNoConflict) Equals(rhs *AccessorNoConflict) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Getname, rhs.Getname) {
		return false
	}
	if !_String_EqualsPtr(v.GetName, rhs.GetName) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of AccessorNoConflict.
func (v *AccessorNoConflict) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Getname != nil {
		enc.AddString("getname", *v.Getname)
	}
	if v.GetName != nil {
		enc.AddString("get_name", *v.GetName)
	}
	return err
}

// GetGetname returns the value of Getname if it is set or its
// zero value if it is unset.
func (v *AccessorNoConflict) GetGetname() (o string) {
	if v != nil && v.Getname != nil {
		return *v.Getname
	}

	return
}

// IsSetGetname returns true if Getname is not nil.
func (v *AccessorNoConflict) IsSetGetname() bool {
	return v != nil && v.Getname != nil
}

// GetGetName returns the value of GetName if it is set or its
// zero value if it is unset.
func (v *AccessorNoConflict) GetGetName() (o string) {
	if v != nil && v.GetName != nil {
		return *v.GetName
	}

	return
}

// IsSetGetName returns true if GetName is not nil.
func (v *AccessorNoConflict) IsSetGetName() bool {
	return v != nil && v.GetName != nil
}

type LittlePotatoe int64

// LittlePotatoePtr returns a pointer to a LittlePotatoe
func (v LittlePotatoe) Ptr() *LittlePotatoe {
	return &v
}

// ToWire translates LittlePotatoe into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v LittlePotatoe) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of LittlePotatoe.
func (v LittlePotatoe) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes LittlePotatoe from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *LittlePotatoe) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (LittlePotatoe)(x)
	return err
}

// Equals returns true if this LittlePotatoe is equal to the provided
// LittlePotatoe.
func (lhs LittlePotatoe) Equals(rhs LittlePotatoe) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type MyEnum int32

const (
	MyEnumX       MyEnum = 123
	MyEnumY       MyEnum = 456
	MyEnumZ       MyEnum = 789
	MyEnumFooBar  MyEnum = 790
	MyEnumFooBar2 MyEnum = 791
)

// MyEnum_Values returns all recognized values of MyEnum.
func MyEnum_Values() []MyEnum {
	return []MyEnum{
		MyEnumX,
		MyEnumY,
		MyEnumZ,
		MyEnumFooBar,
		MyEnumFooBar2,
	}
}

// UnmarshalText tries to decode MyEnum from a byte slice
// containing its name.
//
//   var v MyEnum
//   err := v.UnmarshalText([]byte("X"))
func (v *MyEnum) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "X":
		*v = MyEnumX
		return nil
	case "Y":
		*v = MyEnumY
		return nil
	case "Z":
		*v = MyEnumZ
		return nil
	case "FooBar":
		*v = MyEnumFooBar
		return nil
	case "foo_bar":
		*v = MyEnumFooBar2
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "MyEnum", err)
		}
		*v = MyEnum(val)
		return nil
	}
}

// MarshalText encodes MyEnum to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v MyEnum) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 123:
		return []byte("X"), nil
	case 456:
		return []byte("Y"), nil
	case 789:
		return []byte("Z"), nil
	case 790:
		return []byte("FooBar"), nil
	case 791:
		return []byte("foo_bar"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MyEnum.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v MyEnum) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 123:
		enc.AddString("name", "X")
	case 456:
		enc.AddString("name", "Y")
	case 789:
		enc.AddString("name", "Z")
	case 790:
		enc.AddString("name", "FooBar")
	case 791:
		enc.AddString("name", "foo_bar")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v MyEnum) Ptr() *MyEnum {
	return &v
}

// ToWire translates MyEnum into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v MyEnum) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes MyEnum from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return MyEnum(0), err
//   }
//
//   var v MyEnum
//   if err := v.FromWire(x); err != nil {
//     return MyEnum(0), err
//   }
//   return v, nil
func (v *MyEnum) FromWire(w wire.Value) error {
	*v = (MyEnum)(w.GetI32())
	return nil
}

// String returns a readable string representation of MyEnum.
func (v MyEnum) String() string {
	w := int32(v)
	switch w {
	case 123:
		return "X"
	case 456:
		return "Y"
	case 789:
		return "Z"
	case 790:
		return "FooBar"
	case 791:
		return "foo_bar"
	}
	return fmt.Sprintf("MyEnum(%d)", w)
}

// Equals returns true if this MyEnum value matches the provided
// value.
func (v MyEnum) Equals(rhs MyEnum) bool {
	return v == rhs
}

// MarshalJSON serializes MyEnum into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v MyEnum) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 123:
		return ([]byte)("\"X\""), nil
	case 456:
		return ([]byte)("\"Y\""), nil
	case 789:
		return ([]byte)("\"Z\""), nil
	case 790:
		return ([]byte)("\"FooBar\""), nil
	case 791:
		return ([]byte)("\"foo_bar\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode MyEnum from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *MyEnum) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "MyEnum")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "MyEnum")
		}
		*v = (MyEnum)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "MyEnum")
	}
}

type PrimitiveContainers struct {
	A []string            `json:"ListOrSetOrMap,omitempty"`
	B map[string]struct{} `json:"List_Or_SetOrMap,omitempty"`
	C map[string]string   `json:"ListOrSet_Or_Map,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

type _Set_String_mapType_ValueList map[string]struct{}

func (v _Set_String_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_String_mapType_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_mapType_ValueList) Close() {}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a PrimitiveContainers struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PrimitiveContainers) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.A != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.A)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.B != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.B)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.C != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.C)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Set_String_mapType_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a PrimitiveContainers struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PrimitiveContainers struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PrimitiveContainers
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PrimitiveContainers) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.A, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.B, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.C, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PrimitiveContainers
// struct.
func (v *PrimitiveContainers) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.A != nil {
		fields[i] = fmt.Sprintf("A: %v", v.A)
		i++
	}
	if v.B != nil {
		fields[i] = fmt.Sprintf("B: %v", v.B)
		i++
	}
	if v.C != nil {
		fields[i] = fmt.Sprintf("C: %v", v.C)
		i++
	}

	return fmt.Sprintf("PrimitiveContainers{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

func _Set_String_mapType_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this PrimitiveContainers match the
// provided PrimitiveContainers.
//
// This function performs a deep comparison.
func (v *PrimitiveContainers) Equals(rhs *PrimitiveContainers) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.A == nil && rhs.A == nil) || (v.A != nil && rhs.A != nil && _List_String_Equals(v.A, rhs.A))) {
		return false
	}
	if !((v.B == nil && rhs.B == nil) || (v.B != nil && rhs.B != nil && _Set_String_mapType_Equals(v.B, rhs.B))) {
		return false
	}
	if !((v.C == nil && rhs.C == nil) || (v.C != nil && rhs.C != nil && _Map_String_String_Equals(v.C, rhs.C))) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

type _Set_String_mapType_Zapper map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_String_mapType_Zapper.
func (s _Set_String_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendString(v)
	}
	return err
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PrimitiveContainers.
func (v *PrimitiveContainers) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.A != nil {
		err = multierr.Append(err, enc.AddArray("ListOrSetOrMap", (_List_String_Zapper)(v.A)))
	}
	if v.B != nil {
		err = multierr.Append(err, enc.AddArray("List_Or_SetOrMap", (_Set_String_mapType_Zapper)(v.B)))
	}
	if v.C != nil {
		err = multierr.Append(err, enc.AddObject("ListOrSet_Or_Map", (_Map_String_String_Zapper)(v.C)))
	}
	return err
}

// GetA returns the value of A if it is set or its
// zero value if it is unset.
func (v *PrimitiveContainers) GetA() (o []string) {
	if v != nil && v.A != nil {
		return v.A
	}

	return
}

// IsSetA returns true if A is not nil.
func (v *PrimitiveContainers) IsSetA() bool {
	return v != nil && v.A != nil
}

// GetB returns the value of B if it is set or its
// zero value if it is unset.
func (v *PrimitiveContainers) GetB() (o map[string]struct{}) {
	if v != nil && v.B != nil {
		return v.B
	}

	return
}

// IsSetB returns true if B is not nil.
func (v *PrimitiveContainers) IsSetB() bool {
	return v != nil && v.B != nil
}

// GetC returns the value of C if it is set or its
// zero value if it is unset.
func (v *PrimitiveContainers) GetC() (o map[string]string) {
	if v != nil && v.C != nil {
		return v.C
	}

	return
}

// IsSetC returns true if C is not nil.
func (v *PrimitiveContainers) IsSetC() bool {
	return v != nil && v.C != nil
}

type StructCollision struct {
	CollisionField  bool   `json:"collisionField,required"`
	CollisionField2 string `json:"collision_field,required"`
}

// ToWire translates a StructCollision struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructCollision) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueBool(v.CollisionField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.CollisionField2), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StructCollision struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructCollision struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructCollision
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructCollision) FromWire(w wire.Value) error {
	var err error

	collisionFieldIsSet := false
	collision_fieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				v.CollisionField, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				collisionFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.CollisionField2, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				collision_fieldIsSet = true
			}
		}
	}

	if !collisionFieldIsSet {
		return errors.New("field CollisionField of StructCollision is required")
	}

	if !collision_fieldIsSet {
		return errors.New("field CollisionField2 of StructCollision is required")
	}

	return nil
}

// String returns a readable string representation of a StructCollision
// struct.
func (v *StructCollision) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("CollisionField: %v", v.CollisionField)
	i++
	fields[i] = fmt.Sprintf("CollisionField2: %v", v.CollisionField2)
	i++

	return fmt.Sprintf("StructCollision{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructCollision match the
// provided StructCollision.
//
// This function performs a deep comparison.
func (v *StructCollision) Equals(rhs *StructCollision) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.CollisionField == rhs.CollisionField) {
		return false
	}
	if !(v.CollisionField2 == rhs.CollisionField2) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StructCollision.
func (v *StructCollision) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddBool("collisionField", v.CollisionField)
	enc.AddString("collision_field", v.CollisionField2)
	return err
}

// GetCollisionField returns the value of CollisionField if it is set or its
// zero value if it is unset.
func (v *StructCollision) GetCollisionField() (o bool) {
	if v != nil {
		o = v.CollisionField
	}
	return
}

// GetCollisionField2 returns the value of CollisionField2 if it is set or its
// zero value if it is unset.
func (v *StructCollision) GetCollisionField2() (o string) {
	if v != nil {
		o = v.CollisionField2
	}
	return
}

type UnionCollision struct {
	CollisionField  *bool   `json:"collisionField,omitempty"`
	CollisionField2 *string `json:"collision_field,omitempty"`
}

// ToWire translates a UnionCollision struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *UnionCollision) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.CollisionField != nil {
		w, err = wire.NewValueBool(*(v.CollisionField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.CollisionField2 != nil {
		w, err = wire.NewValueString(*(v.CollisionField2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("UnionCollision should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a UnionCollision struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a UnionCollision struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v UnionCollision
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *UnionCollision) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CollisionField = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CollisionField2 = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.CollisionField != nil {
		count++
	}
	if v.CollisionField2 != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("UnionCollision should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a UnionCollision
// struct.
func (v *UnionCollision) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.CollisionField != nil {
		fields[i] = fmt.Sprintf("CollisionField: %v", *(v.CollisionField))
		i++
	}
	if v.CollisionField2 != nil {
		fields[i] = fmt.Sprintf("CollisionField2: %v", *(v.CollisionField2))
		i++
	}

	return fmt.Sprintf("UnionCollision{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this UnionCollision match the
// provided UnionCollision.
//
// This function performs a deep comparison.
func (v *UnionCollision) Equals(rhs *UnionCollision) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.CollisionField, rhs.CollisionField) {
		return false
	}
	if !_String_EqualsPtr(v.CollisionField2, rhs.CollisionField2) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of UnionCollision.
func (v *UnionCollision) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.CollisionField != nil {
		enc.AddBool("collisionField", *v.CollisionField)
	}
	if v.CollisionField2 != nil {
		enc.AddString("collision_field", *v.CollisionField2)
	}
	return err
}

// GetCollisionField returns the value of CollisionField if it is set or its
// zero value if it is unset.
func (v *UnionCollision) GetCollisionField() (o bool) {
	if v != nil && v.CollisionField != nil {
		return *v.CollisionField
	}

	return
}

// IsSetCollisionField returns true if CollisionField is not nil.
func (v *UnionCollision) IsSetCollisionField() bool {
	return v != nil && v.CollisionField != nil
}

// GetCollisionField2 returns the value of CollisionField2 if it is set or its
// zero value if it is unset.
func (v *UnionCollision) GetCollisionField2() (o string) {
	if v != nil && v.CollisionField2 != nil {
		return *v.CollisionField2
	}

	return
}

// IsSetCollisionField2 returns true if CollisionField2 is not nil.
func (v *UnionCollision) IsSetCollisionField2() bool {
	return v != nil && v.CollisionField2 != nil
}

type WithDefault struct {
	Pouet *StructCollision2 `json:"pouet,omitempty"`
}

// ToWire translates a WithDefault struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WithDefault) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Pouet == nil {
		v.Pouet = &StructCollision2{
			CollisionField:  false,
			CollisionField2: "false indeed",
		}
	}
	{
		w, err = v.Pouet.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StructCollision_Read(w wire.Value) (*StructCollision2, error) {
	var v StructCollision2
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a WithDefault struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WithDefault struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WithDefault
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WithDefault) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Pouet, err = _StructCollision_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if v.Pouet == nil {
		v.Pouet = &StructCollision2{
			CollisionField:  false,
			CollisionField2: "false indeed",
		}
	}

	return nil
}

// String returns a readable string representation of a WithDefault
// struct.
func (v *WithDefault) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Pouet != nil {
		fields[i] = fmt.Sprintf("Pouet: %v", v.Pouet)
		i++
	}

	return fmt.Sprintf("WithDefault{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WithDefault match the
// provided WithDefault.
//
// This function performs a deep comparison.
func (v *WithDefault) Equals(rhs *WithDefault) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Pouet == nil && rhs.Pouet == nil) || (v.Pouet != nil && rhs.Pouet != nil && v.Pouet.Equals(rhs.Pouet))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WithDefault.
func (v *WithDefault) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Pouet != nil {
		err = multierr.Append(err, enc.AddObject("pouet", v.Pouet))
	}
	return err
}

// GetPouet returns the value of Pouet if it is set or its
// default value if it is unset.
func (v *WithDefault) GetPouet() (o *StructCollision2) {
	if v != nil && v.Pouet != nil {
		return v.Pouet
	}
	o = &StructCollision2{
		CollisionField:  false,
		CollisionField2: "false indeed",
	}
	return
}

// IsSetPouet returns true if Pouet is not nil.
func (v *WithDefault) IsSetPouet() bool {
	return v != nil && v.Pouet != nil
}

type LittlePotatoe2 float64

// LittlePotatoe2Ptr returns a pointer to a LittlePotatoe2
func (v LittlePotatoe2) Ptr() *LittlePotatoe2 {
	return &v
}

// ToWire translates LittlePotatoe2 into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v LittlePotatoe2) ToWire() (wire.Value, error) {
	x := (float64)(v)
	return wire.NewValueDouble(x), error(nil)
}

// String returns a readable string representation of LittlePotatoe2.
func (v LittlePotatoe2) String() string {
	x := (float64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes LittlePotatoe2 from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *LittlePotatoe2) FromWire(w wire.Value) error {
	x, err := w.GetDouble(), error(nil)
	*v = (LittlePotatoe2)(x)
	return err
}

// Equals returns true if this LittlePotatoe2 is equal to the provided
// LittlePotatoe2.
func (lhs LittlePotatoe2) Equals(rhs LittlePotatoe2) bool {
	return ((float64)(lhs) == (float64)(rhs))
}

type MyEnum2 int32

const (
	MyEnum2X MyEnum2 = 12
	MyEnum2Y MyEnum2 = 34
	MyEnum2Z MyEnum2 = 56
)

// MyEnum2_Values returns all recognized values of MyEnum2.
func MyEnum2_Values() []MyEnum2 {
	return []MyEnum2{
		MyEnum2X,
		MyEnum2Y,
		MyEnum2Z,
	}
}

// UnmarshalText tries to decode MyEnum2 from a byte slice
// containing its name.
//
//   var v MyEnum2
//   err := v.UnmarshalText([]byte("X"))
func (v *MyEnum2) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "X":
		*v = MyEnum2X
		return nil
	case "Y":
		*v = MyEnum2Y
		return nil
	case "Z":
		*v = MyEnum2Z
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "MyEnum2", err)
		}
		*v = MyEnum2(val)
		return nil
	}
}

// MarshalText encodes MyEnum2 to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v MyEnum2) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 12:
		return []byte("X"), nil
	case 34:
		return []byte("Y"), nil
	case 56:
		return []byte("Z"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MyEnum2.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v MyEnum2) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 12:
		enc.AddString("name", "X")
	case 34:
		enc.AddString("name", "Y")
	case 56:
		enc.AddString("name", "Z")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v MyEnum2) Ptr() *MyEnum2 {
	return &v
}

// ToWire translates MyEnum2 into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v MyEnum2) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes MyEnum2 from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return MyEnum2(0), err
//   }
//
//   var v MyEnum2
//   if err := v.FromWire(x); err != nil {
//     return MyEnum2(0), err
//   }
//   return v, nil
func (v *MyEnum2) FromWire(w wire.Value) error {
	*v = (MyEnum2)(w.GetI32())
	return nil
}

// String returns a readable string representation of MyEnum2.
func (v MyEnum2) String() string {
	w := int32(v)
	switch w {
	case 12:
		return "X"
	case 34:
		return "Y"
	case 56:
		return "Z"
	}
	return fmt.Sprintf("MyEnum2(%d)", w)
}

// Equals returns true if this MyEnum2 value matches the provided
// value.
func (v MyEnum2) Equals(rhs MyEnum2) bool {
	return v == rhs
}

// MarshalJSON serializes MyEnum2 into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v MyEnum2) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 12:
		return ([]byte)("\"X\""), nil
	case 34:
		return ([]byte)("\"Y\""), nil
	case 56:
		return ([]byte)("\"Z\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode MyEnum2 from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *MyEnum2) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "MyEnum2")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "MyEnum2")
		}
		*v = (MyEnum2)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "MyEnum2")
	}
}

type StructCollision2 struct {
	CollisionField  bool   `json:"collisionField,required"`
	CollisionField2 string `json:"collision_field,required"`
}

// ToWire translates a StructCollision2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructCollision2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueBool(v.CollisionField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.CollisionField2), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StructCollision2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructCollision2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructCollision2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructCollision2) FromWire(w wire.Value) error {
	var err error

	collisionFieldIsSet := false
	collision_fieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				v.CollisionField, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				collisionFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.CollisionField2, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				collision_fieldIsSet = true
			}
		}
	}

	if !collisionFieldIsSet {
		return errors.New("field CollisionField of StructCollision2 is required")
	}

	if !collision_fieldIsSet {
		return errors.New("field CollisionField2 of StructCollision2 is required")
	}

	return nil
}

// String returns a readable string representation of a StructCollision2
// struct.
func (v *StructCollision2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("CollisionField: %v", v.CollisionField)
	i++
	fields[i] = fmt.Sprintf("CollisionField2: %v", v.CollisionField2)
	i++

	return fmt.Sprintf("StructCollision2{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructCollision2 match the
// provided StructCollision2.
//
// This function performs a deep comparison.
func (v *StructCollision2) Equals(rhs *StructCollision2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.CollisionField == rhs.CollisionField) {
		return false
	}
	if !(v.CollisionField2 == rhs.CollisionField2) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StructCollision2.
func (v *StructCollision2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddBool("collisionField", v.CollisionField)
	enc.AddString("collision_field", v.CollisionField2)
	return err
}

// GetCollisionField returns the value of CollisionField if it is set or its
// zero value if it is unset.
func (v *StructCollision2) GetCollisionField() (o bool) {
	if v != nil {
		o = v.CollisionField
	}
	return
}

// GetCollisionField2 returns the value of CollisionField2 if it is set or its
// zero value if it is unset.
func (v *StructCollision2) GetCollisionField2() (o string) {
	if v != nil {
		o = v.CollisionField2
	}
	return
}

type UnionCollision2 struct {
	CollisionField  *bool   `json:"collisionField,omitempty"`
	CollisionField2 *string `json:"collision_field,omitempty"`
}

// ToWire translates a UnionCollision2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *UnionCollision2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.CollisionField != nil {
		w, err = wire.NewValueBool(*(v.CollisionField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.CollisionField2 != nil {
		w, err = wire.NewValueString(*(v.CollisionField2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("UnionCollision2 should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a UnionCollision2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a UnionCollision2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v UnionCollision2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *UnionCollision2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CollisionField = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CollisionField2 = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.CollisionField != nil {
		count++
	}
	if v.CollisionField2 != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("UnionCollision2 should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a UnionCollision2
// struct.
func (v *UnionCollision2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.CollisionField != nil {
		fields[i] = fmt.Sprintf("CollisionField: %v", *(v.CollisionField))
		i++
	}
	if v.CollisionField2 != nil {
		fields[i] = fmt.Sprintf("CollisionField2: %v", *(v.CollisionField2))
		i++
	}

	return fmt.Sprintf("UnionCollision2{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this UnionCollision2 match the
// provided UnionCollision2.
//
// This function performs a deep comparison.
func (v *UnionCollision2) Equals(rhs *UnionCollision2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.CollisionField, rhs.CollisionField) {
		return false
	}
	if !_String_EqualsPtr(v.CollisionField2, rhs.CollisionField2) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of UnionCollision2.
func (v *UnionCollision2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.CollisionField != nil {
		enc.AddBool("collisionField", *v.CollisionField)
	}
	if v.CollisionField2 != nil {
		enc.AddString("collision_field", *v.CollisionField2)
	}
	return err
}

// GetCollisionField returns the value of CollisionField if it is set or its
// zero value if it is unset.
func (v *UnionCollision2) GetCollisionField() (o bool) {
	if v != nil && v.CollisionField != nil {
		return *v.CollisionField
	}

	return
}

// IsSetCollisionField returns true if CollisionField is not nil.
func (v *UnionCollision2) IsSetCollisionField() bool {
	return v != nil && v.CollisionField != nil
}

// GetCollisionField2 returns the value of CollisionField2 if it is set or its
// zero value if it is unset.
func (v *UnionCollision2) GetCollisionField2() (o string) {
	if v != nil && v.CollisionField2 != nil {
		return *v.CollisionField2
	}

	return
}

// IsSetCollisionField2 returns true if CollisionField2 is not nil.
func (v *UnionCollision2) IsSetCollisionField2() bool {
	return v != nil && v.CollisionField2 != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "collision",
	Package:  "go.uber.org/thriftrw/gen/internal/tests/collision",
	FilePath: "collision.thrift",
	SHA1:     "b7ffef8f5aede3fbc4440cadb2f225e474797f2d",
	Raw:      rawIDL,
}

const rawIDL = "\nstruct StructCollision {\n\t1: required bool collisionField\n\t2: required string collision_field (go.name = \"CollisionField2\")\n}\n\nstruct struct_collision {\n\t1: required bool collisionField\n\t2: required string collision_field (go.name = \"CollisionField2\")\n} (go.name=\"StructCollision2\")\n\nstruct PrimitiveContainers {\n    1: optional list<string> ListOrSetOrMap (go.name = \"A\")\n    3: optional set<string>  List_Or_SetOrMap (go.name = \"B\")\n    5: optional map<string, string> ListOrSet_Or_Map (go.name = \"C\")\n}\n\nenum MyEnum {\n    X = 123,\n    Y = 456,\n    Z = 789,\n    FooBar,\n    foo_bar (go.name=\"FooBar2\"),\n}\n\nenum my_enum {\n    X = 12,\n    Y = 34,\n    Z = 56,\n} (go.name=\"MyEnum2\")\n\ntypedef i64 LittlePotatoe\ntypedef double little_potatoe (go.name=\"LittlePotatoe2\")\n\nconst struct_collision struct_constant = {\n\t\"collisionField\": false,\n\t\"collision_field\": \"false indeed\",\n}\n\nunion UnionCollision {\n\t1: bool collisionField\n\t2: string collision_field (go.name = \"CollisionField2\")\n}\n\nunion union_collision {\n\t1: bool collisionField\n\t2: string collision_field (go.name = \"CollisionField2\")\n} (go.name=\"UnionCollision2\")\n\nstruct WithDefault {\n\t1: required struct_collision pouet = struct_constant\n}\n\nstruct AccessorNoConflict {\n    1: optional string getname\n    2: optional string get_name\n}\n\nstruct AccessorConflict {\n    1: optional string name\n    2: optional string get_name (go.name = \"GetName2\")\n    3: optional bool is_set_name (go.name = \"IsSetName2\")\n}\n"
