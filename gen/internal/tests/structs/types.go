// Code generated by thriftrw v1.13.0. DO NOT EDIT.
// @generated

package structs

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"go.uber.org/thriftrw/gen/internal/tests/enums"
	"go.uber.org/thriftrw/ptr"
	"go.uber.org/thriftrw/wire"
	"go.uber.org/zap/zapcore"
	"strings"
)

type ContactInfo struct {
	EmailAddress string `json:"emailAddress,required"`
}

// ToWire translates a ContactInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ContactInfo) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.EmailAddress), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ContactInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ContactInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ContactInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ContactInfo) FromWire(w wire.Value) error {
	var err error

	emailAddressIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.EmailAddress, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				emailAddressIsSet = true
			}
		}
	}

	if !emailAddressIsSet {
		return errors.New("field EmailAddress of ContactInfo is required")
	}

	return nil
}

// String returns a readable string representation of a ContactInfo
// struct.
func (v *ContactInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("EmailAddress: %v", v.EmailAddress)
	i++

	return fmt.Sprintf("ContactInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ContactInfo match the
// provided ContactInfo.
//
// This function performs a deep comparison.
func (v *ContactInfo) Equals(rhs *ContactInfo) bool {
	if !(v.EmailAddress == rhs.EmailAddress) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *ContactInfo) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddString("emailAddress", v.EmailAddress)

	return nil
}

// GetEmailAddress returns the value of EmailAddress if it is set or its
// zero value if it is unset.
func (v *ContactInfo) GetEmailAddress() (o string) { return v.EmailAddress }

type DefaultsStruct struct {
	RequiredPrimitive *int32             `json:"requiredPrimitive,omitempty"`
	OptionalPrimitive *int32             `json:"optionalPrimitive,omitempty"`
	RequiredEnum      *enums.EnumDefault `json:"requiredEnum,omitempty"`
	OptionalEnum      *enums.EnumDefault `json:"optionalEnum,omitempty"`
	RequiredList      []string           `json:"requiredList,omitempty"`
	OptionalList      []float64          `json:"optionalList,omitempty"`
	RequiredStruct    *Frame             `json:"requiredStruct,omitempty"`
	OptionalStruct    *Edge              `json:"optionalStruct,omitempty"`
}

func _EnumDefault_ptr(v enums.EnumDefault) *enums.EnumDefault {
	return &v
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

type _List_Double_ValueList []float64

func (v _List_Double_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueDouble(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Double_ValueList) Size() int {
	return len(v)
}

func (_List_Double_ValueList) ValueType() wire.Type {
	return wire.TDouble
}

func (_List_Double_ValueList) Close() {}

// ToWire translates a DefaultsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DefaultsStruct) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.RequiredPrimitive == nil {
		v.RequiredPrimitive = ptr.Int32(100)
	}
	{
		w, err = wire.NewValueI32(*(v.RequiredPrimitive)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.OptionalPrimitive == nil {
		v.OptionalPrimitive = ptr.Int32(200)
	}
	{
		w, err = wire.NewValueI32(*(v.OptionalPrimitive)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.RequiredEnum == nil {
		v.RequiredEnum = _EnumDefault_ptr(enums.EnumDefaultBar)
	}
	{
		w, err = v.RequiredEnum.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.OptionalEnum == nil {
		v.OptionalEnum = _EnumDefault_ptr(enums.EnumDefaultBaz)
	}
	{
		w, err = v.OptionalEnum.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.RequiredList == nil {
		v.RequiredList = []string{
			"hello",
			"world",
		}
	}
	{
		w, err = wire.NewValueList(_List_String_ValueList(v.RequiredList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.OptionalList == nil {
		v.OptionalList = []float64{
			1,
			2,
			3,
		}
	}
	{
		w, err = wire.NewValueList(_List_Double_ValueList(v.OptionalList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.RequiredStruct == nil {
		v.RequiredStruct = &Frame{
			Size: &Size{
				Height: 200,
				Width:  100,
			},
			TopLeft: &Point{
				X: 1,
				Y: 2,
			},
		}
	}
	{
		w, err = v.RequiredStruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.OptionalStruct == nil {
		v.OptionalStruct = &Edge{
			EndPoint: &Point{
				X: 3,
				Y: 4,
			},
			StartPoint: &Point{
				X: 1,
				Y: 2,
			},
		}
	}
	{
		w, err = v.OptionalStruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EnumDefault_Read(w wire.Value) (enums.EnumDefault, error) {
	var v enums.EnumDefault
	err := v.FromWire(w)
	return v, err
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_Double_Read(l wire.ValueList) ([]float64, error) {
	if l.ValueType() != wire.TDouble {
		return nil, nil
	}

	o := make([]float64, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetDouble(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Frame_Read(w wire.Value) (*Frame, error) {
	var v Frame
	err := v.FromWire(w)
	return &v, err
}

func _Edge_Read(w wire.Value) (*Edge, error) {
	var v Edge
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a DefaultsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DefaultsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DefaultsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DefaultsStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RequiredPrimitive = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.OptionalPrimitive = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x enums.EnumDefault
				x, err = _EnumDefault_Read(field.Value)
				v.RequiredEnum = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x enums.EnumDefault
				x, err = _EnumDefault_Read(field.Value)
				v.OptionalEnum = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.RequiredList, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TList {
				v.OptionalList, err = _List_Double_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.RequiredStruct, err = _Frame_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TStruct {
				v.OptionalStruct, err = _Edge_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if v.RequiredPrimitive == nil {
		v.RequiredPrimitive = ptr.Int32(100)
	}

	if v.OptionalPrimitive == nil {
		v.OptionalPrimitive = ptr.Int32(200)
	}

	if v.RequiredEnum == nil {
		v.RequiredEnum = _EnumDefault_ptr(enums.EnumDefaultBar)
	}

	if v.OptionalEnum == nil {
		v.OptionalEnum = _EnumDefault_ptr(enums.EnumDefaultBaz)
	}

	if v.RequiredList == nil {
		v.RequiredList = []string{
			"hello",
			"world",
		}
	}

	if v.OptionalList == nil {
		v.OptionalList = []float64{
			1,
			2,
			3,
		}
	}

	if v.RequiredStruct == nil {
		v.RequiredStruct = &Frame{
			Size: &Size{
				Height: 200,
				Width:  100,
			},
			TopLeft: &Point{
				X: 1,
				Y: 2,
			},
		}
	}

	if v.OptionalStruct == nil {
		v.OptionalStruct = &Edge{
			EndPoint: &Point{
				X: 3,
				Y: 4,
			},
			StartPoint: &Point{
				X: 1,
				Y: 2,
			},
		}
	}

	return nil
}

// String returns a readable string representation of a DefaultsStruct
// struct.
func (v *DefaultsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	if v.RequiredPrimitive != nil {
		fields[i] = fmt.Sprintf("RequiredPrimitive: %v", *(v.RequiredPrimitive))
		i++
	}
	if v.OptionalPrimitive != nil {
		fields[i] = fmt.Sprintf("OptionalPrimitive: %v", *(v.OptionalPrimitive))
		i++
	}
	if v.RequiredEnum != nil {
		fields[i] = fmt.Sprintf("RequiredEnum: %v", *(v.RequiredEnum))
		i++
	}
	if v.OptionalEnum != nil {
		fields[i] = fmt.Sprintf("OptionalEnum: %v", *(v.OptionalEnum))
		i++
	}
	if v.RequiredList != nil {
		fields[i] = fmt.Sprintf("RequiredList: %v", v.RequiredList)
		i++
	}
	if v.OptionalList != nil {
		fields[i] = fmt.Sprintf("OptionalList: %v", v.OptionalList)
		i++
	}
	if v.RequiredStruct != nil {
		fields[i] = fmt.Sprintf("RequiredStruct: %v", v.RequiredStruct)
		i++
	}
	if v.OptionalStruct != nil {
		fields[i] = fmt.Sprintf("OptionalStruct: %v", v.OptionalStruct)
		i++
	}

	return fmt.Sprintf("DefaultsStruct{%v}", strings.Join(fields[:i], ", "))
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _EnumDefault_EqualsPtr(lhs, rhs *enums.EnumDefault) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

func _List_Double_Equals(lhs, rhs []float64) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this DefaultsStruct match the
// provided DefaultsStruct.
//
// This function performs a deep comparison.
func (v *DefaultsStruct) Equals(rhs *DefaultsStruct) bool {
	if !_I32_EqualsPtr(v.RequiredPrimitive, rhs.RequiredPrimitive) {
		return false
	}
	if !_I32_EqualsPtr(v.OptionalPrimitive, rhs.OptionalPrimitive) {
		return false
	}
	if !_EnumDefault_EqualsPtr(v.RequiredEnum, rhs.RequiredEnum) {
		return false
	}
	if !_EnumDefault_EqualsPtr(v.OptionalEnum, rhs.OptionalEnum) {
		return false
	}
	if !((v.RequiredList == nil && rhs.RequiredList == nil) || (v.RequiredList != nil && rhs.RequiredList != nil && _List_String_Equals(v.RequiredList, rhs.RequiredList))) {
		return false
	}
	if !((v.OptionalList == nil && rhs.OptionalList == nil) || (v.OptionalList != nil && rhs.OptionalList != nil && _List_Double_Equals(v.OptionalList, rhs.OptionalList))) {
		return false
	}
	if !((v.RequiredStruct == nil && rhs.RequiredStruct == nil) || (v.RequiredStruct != nil && rhs.RequiredStruct != nil && v.RequiredStruct.Equals(rhs.RequiredStruct))) {
		return false
	}
	if !((v.OptionalStruct == nil && rhs.OptionalStruct == nil) || (v.OptionalStruct != nil && rhs.OptionalStruct != nil && v.OptionalStruct.Equals(rhs.OptionalStruct))) {
		return false
	}

	return true
}

type _List_String_Zapper []string

func (vals _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	for _, val := range vals {
		enc.AppendString(val)
	}
	return nil
}

type _List_Double_Zapper []float64

func (vals _List_Double_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	for _, val := range vals {
		enc.AppendFloat64(val)
	}
	return nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *DefaultsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	if v.RequiredPrimitive != nil {
		enc.AddInt32("requiredPrimitive", *v.RequiredPrimitive)
	}

	if v.OptionalPrimitive != nil {
		enc.AddInt32("optionalPrimitive", *v.OptionalPrimitive)
	}

	if v.RequiredEnum != nil {
		enc.AddObject("requiredEnum", *v.RequiredEnum)
	}

	if v.OptionalEnum != nil {
		enc.AddObject("optionalEnum", *v.OptionalEnum)
	}

	if v.RequiredList != nil {
		enc.AddArray("requiredList", (_List_String_Zapper)(v.RequiredList))
	}

	if v.OptionalList != nil {
		enc.AddArray("optionalList", (_List_Double_Zapper)(v.OptionalList))
	}

	if v.RequiredStruct != nil {
		enc.AddObject("requiredStruct", v.RequiredStruct)
	}

	if v.OptionalStruct != nil {
		enc.AddObject("optionalStruct", v.OptionalStruct)
	}

	return nil
}

// GetRequiredPrimitive returns the value of RequiredPrimitive if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredPrimitive() (o int32) {
	if v.RequiredPrimitive != nil {
		return *v.RequiredPrimitive
	}
	o = 100
	return
}

// GetOptionalPrimitive returns the value of OptionalPrimitive if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalPrimitive() (o int32) {
	if v.OptionalPrimitive != nil {
		return *v.OptionalPrimitive
	}
	o = 200
	return
}

// GetRequiredEnum returns the value of RequiredEnum if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredEnum() (o enums.EnumDefault) {
	if v.RequiredEnum != nil {
		return *v.RequiredEnum
	}
	o = enums.EnumDefaultBar
	return
}

// GetOptionalEnum returns the value of OptionalEnum if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalEnum() (o enums.EnumDefault) {
	if v.OptionalEnum != nil {
		return *v.OptionalEnum
	}
	o = enums.EnumDefaultBaz
	return
}

// GetRequiredList returns the value of RequiredList if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredList() (o []string) {
	if v.RequiredList != nil {
		return v.RequiredList
	}
	o = []string{
		"hello",
		"world",
	}
	return
}

// GetOptionalList returns the value of OptionalList if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalList() (o []float64) {
	if v.OptionalList != nil {
		return v.OptionalList
	}
	o = []float64{
		1,
		2,
		3,
	}
	return
}

// GetRequiredStruct returns the value of RequiredStruct if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredStruct() (o *Frame) {
	if v.RequiredStruct != nil {
		return v.RequiredStruct
	}
	o = &Frame{
		Size: &Size{
			Height: 200,
			Width:  100,
		},
		TopLeft: &Point{
			X: 1,
			Y: 2,
		},
	}
	return
}

// GetOptionalStruct returns the value of OptionalStruct if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalStruct() (o *Edge) {
	if v.OptionalStruct != nil {
		return v.OptionalStruct
	}
	o = &Edge{
		EndPoint: &Point{
			X: 3,
			Y: 4,
		},
		StartPoint: &Point{
			X: 1,
			Y: 2,
		},
	}
	return
}

type Edge struct {
	StartPoint *Point `json:"startPoint,required"`
	EndPoint   *Point `json:"endPoint,required"`
}

// ToWire translates a Edge struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Edge) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StartPoint == nil {
		return w, errors.New("field StartPoint of Edge is required")
	}
	w, err = v.StartPoint.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.EndPoint == nil {
		return w, errors.New("field EndPoint of Edge is required")
	}
	w, err = v.EndPoint.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Point_Read(w wire.Value) (*Point, error) {
	var v Point
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Edge struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Edge struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Edge
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Edge) FromWire(w wire.Value) error {
	var err error

	startPointIsSet := false
	endPointIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.StartPoint, err = _Point_Read(field.Value)
				if err != nil {
					return err
				}
				startPointIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.EndPoint, err = _Point_Read(field.Value)
				if err != nil {
					return err
				}
				endPointIsSet = true
			}
		}
	}

	if !startPointIsSet {
		return errors.New("field StartPoint of Edge is required")
	}

	if !endPointIsSet {
		return errors.New("field EndPoint of Edge is required")
	}

	return nil
}

// String returns a readable string representation of a Edge
// struct.
func (v *Edge) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("StartPoint: %v", v.StartPoint)
	i++
	fields[i] = fmt.Sprintf("EndPoint: %v", v.EndPoint)
	i++

	return fmt.Sprintf("Edge{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Edge match the
// provided Edge.
//
// This function performs a deep comparison.
func (v *Edge) Equals(rhs *Edge) bool {
	if !v.StartPoint.Equals(rhs.StartPoint) {
		return false
	}
	if !v.EndPoint.Equals(rhs.EndPoint) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Edge) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddObject("startPoint", v.StartPoint)

	enc.AddObject("endPoint", v.EndPoint)

	return nil
}

// GetStartPoint returns the value of StartPoint if it is set or its
// zero value if it is unset.
func (v *Edge) GetStartPoint() (o *Point) { return v.StartPoint }

// GetEndPoint returns the value of EndPoint if it is set or its
// zero value if it is unset.
func (v *Edge) GetEndPoint() (o *Point) { return v.EndPoint }

type EmptyStruct struct {
}

// ToWire translates a EmptyStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EmptyStruct) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a EmptyStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EmptyStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EmptyStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EmptyStruct) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a EmptyStruct
// struct.
func (v *EmptyStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("EmptyStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this EmptyStruct match the
// provided EmptyStruct.
//
// This function performs a deep comparison.
func (v *EmptyStruct) Equals(rhs *EmptyStruct) bool {

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *EmptyStruct) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	return nil
}

type Frame struct {
	TopLeft *Point `json:"topLeft,required"`
	Size    *Size  `json:"size,required"`
}

// ToWire translates a Frame struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Frame) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TopLeft == nil {
		return w, errors.New("field TopLeft of Frame is required")
	}
	w, err = v.TopLeft.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Size == nil {
		return w, errors.New("field Size of Frame is required")
	}
	w, err = v.Size.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Size_Read(w wire.Value) (*Size, error) {
	var v Size
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Frame struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Frame struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Frame
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Frame) FromWire(w wire.Value) error {
	var err error

	topLeftIsSet := false
	sizeIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.TopLeft, err = _Point_Read(field.Value)
				if err != nil {
					return err
				}
				topLeftIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Size, err = _Size_Read(field.Value)
				if err != nil {
					return err
				}
				sizeIsSet = true
			}
		}
	}

	if !topLeftIsSet {
		return errors.New("field TopLeft of Frame is required")
	}

	if !sizeIsSet {
		return errors.New("field Size of Frame is required")
	}

	return nil
}

// String returns a readable string representation of a Frame
// struct.
func (v *Frame) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("TopLeft: %v", v.TopLeft)
	i++
	fields[i] = fmt.Sprintf("Size: %v", v.Size)
	i++

	return fmt.Sprintf("Frame{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Frame match the
// provided Frame.
//
// This function performs a deep comparison.
func (v *Frame) Equals(rhs *Frame) bool {
	if !v.TopLeft.Equals(rhs.TopLeft) {
		return false
	}
	if !v.Size.Equals(rhs.Size) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Frame) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddObject("topLeft", v.TopLeft)

	enc.AddObject("size", v.Size)

	return nil
}

// GetTopLeft returns the value of TopLeft if it is set or its
// zero value if it is unset.
func (v *Frame) GetTopLeft() (o *Point) { return v.TopLeft }

// GetSize returns the value of Size if it is set or its
// zero value if it is unset.
func (v *Frame) GetSize() (o *Size) { return v.Size }

type GoTags struct {
	Foo                 string  `json:"-" foo:"bar"`
	Bar                 *string `json:"Bar,omitempty" bar:"foo"`
	FooBar              string  `json:"foobar,option1,option2,required" bar:"foo,option1" foo:"foobar"`
	FooBarWithSpace     string  `json:"foobarWithSpace,required" foo:"foo bar foobar barfoo"`
	FooBarWithOmitEmpty *string `json:"foobarWithOmitEmpty,omitempty"`
	FooBarWithRequired  string  `json:"foobarWithRequired,required"`
}

// ToWire translates a GoTags struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GoTags) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Foo), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Bar != nil {
		w, err = wire.NewValueString(*(v.Bar)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	w, err = wire.NewValueString(v.FooBar), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	w, err = wire.NewValueString(v.FooBarWithSpace), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++
	if v.FooBarWithOmitEmpty != nil {
		w, err = wire.NewValueString(*(v.FooBarWithOmitEmpty)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	w, err = wire.NewValueString(v.FooBarWithRequired), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a GoTags struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GoTags struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GoTags
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GoTags) FromWire(w wire.Value) error {
	var err error

	FooIsSet := false

	FooBarIsSet := false
	FooBarWithSpaceIsSet := false

	FooBarWithRequiredIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Foo, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Bar = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				v.FooBar, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooBarIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				v.FooBarWithSpace, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooBarWithSpaceIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.FooBarWithOmitEmpty = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TBinary {
				v.FooBarWithRequired, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooBarWithRequiredIsSet = true
			}
		}
	}

	if !FooIsSet {
		return errors.New("field Foo of GoTags is required")
	}

	if !FooBarIsSet {
		return errors.New("field FooBar of GoTags is required")
	}

	if !FooBarWithSpaceIsSet {
		return errors.New("field FooBarWithSpace of GoTags is required")
	}

	if !FooBarWithRequiredIsSet {
		return errors.New("field FooBarWithRequired of GoTags is required")
	}

	return nil
}

// String returns a readable string representation of a GoTags
// struct.
func (v *GoTags) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
	i++
	if v.Bar != nil {
		fields[i] = fmt.Sprintf("Bar: %v", *(v.Bar))
		i++
	}
	fields[i] = fmt.Sprintf("FooBar: %v", v.FooBar)
	i++
	fields[i] = fmt.Sprintf("FooBarWithSpace: %v", v.FooBarWithSpace)
	i++
	if v.FooBarWithOmitEmpty != nil {
		fields[i] = fmt.Sprintf("FooBarWithOmitEmpty: %v", *(v.FooBarWithOmitEmpty))
		i++
	}
	fields[i] = fmt.Sprintf("FooBarWithRequired: %v", v.FooBarWithRequired)
	i++

	return fmt.Sprintf("GoTags{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this GoTags match the
// provided GoTags.
//
// This function performs a deep comparison.
func (v *GoTags) Equals(rhs *GoTags) bool {
	if !(v.Foo == rhs.Foo) {
		return false
	}
	if !_String_EqualsPtr(v.Bar, rhs.Bar) {
		return false
	}
	if !(v.FooBar == rhs.FooBar) {
		return false
	}
	if !(v.FooBarWithSpace == rhs.FooBarWithSpace) {
		return false
	}
	if !_String_EqualsPtr(v.FooBarWithOmitEmpty, rhs.FooBarWithOmitEmpty) {
		return false
	}
	if !(v.FooBarWithRequired == rhs.FooBarWithRequired) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *GoTags) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddString("Foo", v.Foo)

	if v.Bar != nil {
		enc.AddString("Bar", *v.Bar)
	}

	enc.AddString("FooBar", v.FooBar)

	enc.AddString("FooBarWithSpace", v.FooBarWithSpace)

	if v.FooBarWithOmitEmpty != nil {
		enc.AddString("FooBarWithOmitEmpty", *v.FooBarWithOmitEmpty)
	}

	enc.AddString("FooBarWithRequired", v.FooBarWithRequired)

	return nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFoo() (o string) { return v.Foo }

// GetBar returns the value of Bar if it is set or its
// zero value if it is unset.
func (v *GoTags) GetBar() (o string) {
	if v.Bar != nil {
		return *v.Bar
	}

	return
}

// GetFooBar returns the value of FooBar if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBar() (o string) { return v.FooBar }

// GetFooBarWithSpace returns the value of FooBarWithSpace if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBarWithSpace() (o string) { return v.FooBarWithSpace }

// GetFooBarWithOmitEmpty returns the value of FooBarWithOmitEmpty if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBarWithOmitEmpty() (o string) {
	if v.FooBarWithOmitEmpty != nil {
		return *v.FooBarWithOmitEmpty
	}

	return
}

// GetFooBarWithRequired returns the value of FooBarWithRequired if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBarWithRequired() (o string) { return v.FooBarWithRequired }

// A graph is comprised of zero or more edges.
type Graph struct {
	// List of edges in the graph.
	//
	// May be empty.
	Edges []*Edge `json:"edges,required"`
}

type _List_Edge_ValueList []*Edge

func (v _List_Edge_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Edge_ValueList) Size() int {
	return len(v)
}

func (_List_Edge_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Edge_ValueList) Close() {}

// ToWire translates a Graph struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Graph) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Edges == nil {
		return w, errors.New("field Edges of Graph is required")
	}
	w, err = wire.NewValueList(_List_Edge_ValueList(v.Edges)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Edge_Read(l wire.ValueList) ([]*Edge, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Edge, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Edge_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Graph struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Graph struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Graph
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Graph) FromWire(w wire.Value) error {
	var err error

	edgesIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Edges, err = _List_Edge_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				edgesIsSet = true
			}
		}
	}

	if !edgesIsSet {
		return errors.New("field Edges of Graph is required")
	}

	return nil
}

// String returns a readable string representation of a Graph
// struct.
func (v *Graph) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Edges: %v", v.Edges)
	i++

	return fmt.Sprintf("Graph{%v}", strings.Join(fields[:i], ", "))
}

func _List_Edge_Equals(lhs, rhs []*Edge) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Graph match the
// provided Graph.
//
// This function performs a deep comparison.
func (v *Graph) Equals(rhs *Graph) bool {
	if !_List_Edge_Equals(v.Edges, rhs.Edges) {
		return false
	}

	return true
}

type _List_Edge_Zapper []*Edge

func (vals _List_Edge_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	for _, val := range vals {
		enc.AppendObject(val)
	}
	return nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Graph) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddArray("edges", (_List_Edge_Zapper)(v.Edges))

	return nil
}

// GetEdges returns the value of Edges if it is set or its
// zero value if it is unset.
func (v *Graph) GetEdges() (o []*Edge) { return v.Edges }

type List Node

// ToWire translates List into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v *List) ToWire() (wire.Value, error) {
	x := (*Node)(v)
	return x.ToWire()
}

// String returns a readable string representation of List.
func (v *List) String() string {
	x := (*Node)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes List from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *List) FromWire(w wire.Value) error {
	return (*Node)(v).FromWire(w)
}

// Equals returns true if this List is equal to the provided
// List.
func (lhs *List) Equals(rhs *List) bool {
	return (*Node)(lhs).Equals((*Node)(rhs))
}

// Node is linked list of values.
// All values are 32-bit integers.
type Node struct {
	Value int32 `json:"value,required"`
	Tail  *List `json:"tail,omitempty"`
}

// ToWire translates a Node struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Node) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI32(v.Value), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Tail != nil {
		w, err = v.Tail.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Read(w wire.Value) (*List, error) {
	var x List
	err := x.FromWire(w)
	return &x, err
}

// FromWire deserializes a Node struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Node struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Node
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Node) FromWire(w wire.Value) error {
	var err error

	valueIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				v.Value, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				valueIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Tail, err = _List_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !valueIsSet {
		return errors.New("field Value of Node is required")
	}

	return nil
}

// String returns a readable string representation of a Node
// struct.
func (v *Node) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Value: %v", v.Value)
	i++
	if v.Tail != nil {
		fields[i] = fmt.Sprintf("Tail: %v", v.Tail)
		i++
	}

	return fmt.Sprintf("Node{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Node match the
// provided Node.
//
// This function performs a deep comparison.
func (v *Node) Equals(rhs *Node) bool {
	if !(v.Value == rhs.Value) {
		return false
	}
	if !((v.Tail == nil && rhs.Tail == nil) || (v.Tail != nil && rhs.Tail != nil && v.Tail.Equals(rhs.Tail))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Node) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddInt32("value", v.Value)

	if v.Tail != nil {
		enc.AddObject("tail", (*Node)(v.Tail))
	}

	return nil
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *Node) GetValue() (o int32) { return v.Value }

// GetTail returns the value of Tail if it is set or its
// zero value if it is unset.
func (v *Node) GetTail() (o *List) {
	if v.Tail != nil {
		return v.Tail
	}

	return
}

type Omit struct {
	Serialized string `json:"serialized,required"`
	Hidden     string `json:"-"`
}

// ToWire translates a Omit struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Omit) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Serialized), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.Hidden), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Omit struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Omit struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Omit
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Omit) FromWire(w wire.Value) error {
	var err error

	serializedIsSet := false
	hiddenIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Serialized, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				serializedIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Hidden, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				hiddenIsSet = true
			}
		}
	}

	if !serializedIsSet {
		return errors.New("field Serialized of Omit is required")
	}

	if !hiddenIsSet {
		return errors.New("field Hidden of Omit is required")
	}

	return nil
}

// String returns a readable string representation of a Omit
// struct.
func (v *Omit) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Serialized: %v", v.Serialized)
	i++
	fields[i] = fmt.Sprintf("Hidden: %v", v.Hidden)
	i++

	return fmt.Sprintf("Omit{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Omit match the
// provided Omit.
//
// This function performs a deep comparison.
func (v *Omit) Equals(rhs *Omit) bool {
	if !(v.Serialized == rhs.Serialized) {
		return false
	}
	if !(v.Hidden == rhs.Hidden) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Omit) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddString("serialized", v.Serialized)

	enc.AddString("hidden", v.Hidden)

	return nil
}

// GetSerialized returns the value of Serialized if it is set or its
// zero value if it is unset.
func (v *Omit) GetSerialized() (o string) { return v.Serialized }

// GetHidden returns the value of Hidden if it is set or its
// zero value if it is unset.
func (v *Omit) GetHidden() (o string) { return v.Hidden }

// A point in 2D space.
type Point struct {
	X float64 `json:"x,required"`
	Y float64 `json:"y,required"`
}

// ToWire translates a Point struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Point) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueDouble(v.X), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueDouble(v.Y), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Point struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Point struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Point
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Point) FromWire(w wire.Value) error {
	var err error

	xIsSet := false
	yIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				v.X, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				xIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TDouble {
				v.Y, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				yIsSet = true
			}
		}
	}

	if !xIsSet {
		return errors.New("field X of Point is required")
	}

	if !yIsSet {
		return errors.New("field Y of Point is required")
	}

	return nil
}

// String returns a readable string representation of a Point
// struct.
func (v *Point) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("X: %v", v.X)
	i++
	fields[i] = fmt.Sprintf("Y: %v", v.Y)
	i++

	return fmt.Sprintf("Point{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Point match the
// provided Point.
//
// This function performs a deep comparison.
func (v *Point) Equals(rhs *Point) bool {
	if !(v.X == rhs.X) {
		return false
	}
	if !(v.Y == rhs.Y) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Point) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddFloat64("x", v.X)

	enc.AddFloat64("y", v.Y)

	return nil
}

// GetX returns the value of X if it is set or its
// zero value if it is unset.
func (v *Point) GetX() (o float64) { return v.X }

// GetY returns the value of Y if it is set or its
// zero value if it is unset.
func (v *Point) GetY() (o float64) { return v.Y }

// A struct that contains primitive fields exclusively.
//
// All fields are optional.
type PrimitiveOptionalStruct struct {
	BoolField   *bool    `json:"boolField,omitempty"`
	ByteField   *int8    `json:"byteField,omitempty"`
	Int16Field  *int16   `json:"int16Field,omitempty"`
	Int32Field  *int32   `json:"int32Field,omitempty"`
	Int64Field  *int64   `json:"int64Field,omitempty"`
	DoubleField *float64 `json:"doubleField,omitempty"`
	StringField *string  `json:"stringField,omitempty"`
	BinaryField []byte   `json:"binaryField,omitempty"`
}

// ToWire translates a PrimitiveOptionalStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PrimitiveOptionalStruct) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BoolField != nil {
		w, err = wire.NewValueBool(*(v.BoolField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ByteField != nil {
		w, err = wire.NewValueI8(*(v.ByteField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Int16Field != nil {
		w, err = wire.NewValueI16(*(v.Int16Field)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Int32Field != nil {
		w, err = wire.NewValueI32(*(v.Int32Field)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Int64Field != nil {
		w, err = wire.NewValueI64(*(v.Int64Field)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.DoubleField != nil {
		w, err = wire.NewValueDouble(*(v.DoubleField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.StringField != nil {
		w, err = wire.NewValueString(*(v.StringField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.BinaryField != nil {
		w, err = wire.NewValueBinary(v.BinaryField), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PrimitiveOptionalStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PrimitiveOptionalStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PrimitiveOptionalStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PrimitiveOptionalStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.BoolField = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteField = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Int16Field = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Int32Field = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Int64Field = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.DoubleField = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringField = &x
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PrimitiveOptionalStruct
// struct.
func (v *PrimitiveOptionalStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	if v.BoolField != nil {
		fields[i] = fmt.Sprintf("BoolField: %v", *(v.BoolField))
		i++
	}
	if v.ByteField != nil {
		fields[i] = fmt.Sprintf("ByteField: %v", *(v.ByteField))
		i++
	}
	if v.Int16Field != nil {
		fields[i] = fmt.Sprintf("Int16Field: %v", *(v.Int16Field))
		i++
	}
	if v.Int32Field != nil {
		fields[i] = fmt.Sprintf("Int32Field: %v", *(v.Int32Field))
		i++
	}
	if v.Int64Field != nil {
		fields[i] = fmt.Sprintf("Int64Field: %v", *(v.Int64Field))
		i++
	}
	if v.DoubleField != nil {
		fields[i] = fmt.Sprintf("DoubleField: %v", *(v.DoubleField))
		i++
	}
	if v.StringField != nil {
		fields[i] = fmt.Sprintf("StringField: %v", *(v.StringField))
		i++
	}
	if v.BinaryField != nil {
		fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
		i++
	}

	return fmt.Sprintf("PrimitiveOptionalStruct{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Byte_EqualsPtr(lhs, rhs *int8) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this PrimitiveOptionalStruct match the
// provided PrimitiveOptionalStruct.
//
// This function performs a deep comparison.
func (v *PrimitiveOptionalStruct) Equals(rhs *PrimitiveOptionalStruct) bool {
	if !_Bool_EqualsPtr(v.BoolField, rhs.BoolField) {
		return false
	}
	if !_Byte_EqualsPtr(v.ByteField, rhs.ByteField) {
		return false
	}
	if !_I16_EqualsPtr(v.Int16Field, rhs.Int16Field) {
		return false
	}
	if !_I32_EqualsPtr(v.Int32Field, rhs.Int32Field) {
		return false
	}
	if !_I64_EqualsPtr(v.Int64Field, rhs.Int64Field) {
		return false
	}
	if !_Double_EqualsPtr(v.DoubleField, rhs.DoubleField) {
		return false
	}
	if !_String_EqualsPtr(v.StringField, rhs.StringField) {
		return false
	}
	if !((v.BinaryField == nil && rhs.BinaryField == nil) || (v.BinaryField != nil && rhs.BinaryField != nil && bytes.Equal(v.BinaryField, rhs.BinaryField))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *PrimitiveOptionalStruct) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	if v.BoolField != nil {
		enc.AddBool("boolField", *v.BoolField)
	}

	if v.ByteField != nil {
		enc.AddInt8("byteField", *v.ByteField)
	}

	if v.Int16Field != nil {
		enc.AddInt16("int16Field", *v.Int16Field)
	}

	if v.Int32Field != nil {
		enc.AddInt32("int32Field", *v.Int32Field)
	}

	if v.Int64Field != nil {
		enc.AddInt64("int64Field", *v.Int64Field)
	}

	if v.DoubleField != nil {
		enc.AddFloat64("doubleField", *v.DoubleField)
	}

	if v.StringField != nil {
		enc.AddString("stringField", *v.StringField)
	}

	if v.BinaryField != nil {
		enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))
	}

	return nil
}

// GetBoolField returns the value of BoolField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetBoolField() (o bool) {
	if v.BoolField != nil {
		return *v.BoolField
	}

	return
}

// GetByteField returns the value of ByteField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetByteField() (o int8) {
	if v.ByteField != nil {
		return *v.ByteField
	}

	return
}

// GetInt16Field returns the value of Int16Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetInt16Field() (o int16) {
	if v.Int16Field != nil {
		return *v.Int16Field
	}

	return
}

// GetInt32Field returns the value of Int32Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetInt32Field() (o int32) {
	if v.Int32Field != nil {
		return *v.Int32Field
	}

	return
}

// GetInt64Field returns the value of Int64Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetInt64Field() (o int64) {
	if v.Int64Field != nil {
		return *v.Int64Field
	}

	return
}

// GetDoubleField returns the value of DoubleField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetDoubleField() (o float64) {
	if v.DoubleField != nil {
		return *v.DoubleField
	}

	return
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetStringField() (o string) {
	if v.StringField != nil {
		return *v.StringField
	}

	return
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetBinaryField() (o []byte) {
	if v.BinaryField != nil {
		return v.BinaryField
	}

	return
}

// A struct that contains primitive fields exclusively.
//
// All fields are required.
type PrimitiveRequiredStruct struct {
	BoolField   bool    `json:"boolField,required"`
	ByteField   int8    `json:"byteField,required"`
	Int16Field  int16   `json:"int16Field,required"`
	Int32Field  int32   `json:"int32Field,required"`
	Int64Field  int64   `json:"int64Field,required"`
	DoubleField float64 `json:"doubleField,required"`
	StringField string  `json:"stringField,required"`
	BinaryField []byte  `json:"binaryField,required"`
}

// ToWire translates a PrimitiveRequiredStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PrimitiveRequiredStruct) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueBool(v.BoolField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI8(v.ByteField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	w, err = wire.NewValueI16(v.Int16Field), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	w, err = wire.NewValueI32(v.Int32Field), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++

	w, err = wire.NewValueI64(v.Int64Field), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++

	w, err = wire.NewValueDouble(v.DoubleField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 7, Value: w}
	i++
	if v.BinaryField == nil {
		return w, errors.New("field BinaryField of PrimitiveRequiredStruct is required")
	}
	w, err = wire.NewValueBinary(v.BinaryField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 8, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PrimitiveRequiredStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PrimitiveRequiredStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PrimitiveRequiredStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PrimitiveRequiredStruct) FromWire(w wire.Value) error {
	var err error

	boolFieldIsSet := false
	byteFieldIsSet := false
	int16FieldIsSet := false
	int32FieldIsSet := false
	int64FieldIsSet := false
	doubleFieldIsSet := false
	stringFieldIsSet := false
	binaryFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				v.BoolField, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				boolFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI8 {
				v.ByteField, err = field.Value.GetI8(), error(nil)
				if err != nil {
					return err
				}
				byteFieldIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI16 {
				v.Int16Field, err = field.Value.GetI16(), error(nil)
				if err != nil {
					return err
				}
				int16FieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				v.Int32Field, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				int32FieldIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				v.Int64Field, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				int64FieldIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				v.DoubleField, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				doubleFieldIsSet = true
			}
		case 7:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		case 8:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
				binaryFieldIsSet = true
			}
		}
	}

	if !boolFieldIsSet {
		return errors.New("field BoolField of PrimitiveRequiredStruct is required")
	}

	if !byteFieldIsSet {
		return errors.New("field ByteField of PrimitiveRequiredStruct is required")
	}

	if !int16FieldIsSet {
		return errors.New("field Int16Field of PrimitiveRequiredStruct is required")
	}

	if !int32FieldIsSet {
		return errors.New("field Int32Field of PrimitiveRequiredStruct is required")
	}

	if !int64FieldIsSet {
		return errors.New("field Int64Field of PrimitiveRequiredStruct is required")
	}

	if !doubleFieldIsSet {
		return errors.New("field DoubleField of PrimitiveRequiredStruct is required")
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of PrimitiveRequiredStruct is required")
	}

	if !binaryFieldIsSet {
		return errors.New("field BinaryField of PrimitiveRequiredStruct is required")
	}

	return nil
}

// String returns a readable string representation of a PrimitiveRequiredStruct
// struct.
func (v *PrimitiveRequiredStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	fields[i] = fmt.Sprintf("BoolField: %v", v.BoolField)
	i++
	fields[i] = fmt.Sprintf("ByteField: %v", v.ByteField)
	i++
	fields[i] = fmt.Sprintf("Int16Field: %v", v.Int16Field)
	i++
	fields[i] = fmt.Sprintf("Int32Field: %v", v.Int32Field)
	i++
	fields[i] = fmt.Sprintf("Int64Field: %v", v.Int64Field)
	i++
	fields[i] = fmt.Sprintf("DoubleField: %v", v.DoubleField)
	i++
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++
	fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
	i++

	return fmt.Sprintf("PrimitiveRequiredStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this PrimitiveRequiredStruct match the
// provided PrimitiveRequiredStruct.
//
// This function performs a deep comparison.
func (v *PrimitiveRequiredStruct) Equals(rhs *PrimitiveRequiredStruct) bool {
	if !(v.BoolField == rhs.BoolField) {
		return false
	}
	if !(v.ByteField == rhs.ByteField) {
		return false
	}
	if !(v.Int16Field == rhs.Int16Field) {
		return false
	}
	if !(v.Int32Field == rhs.Int32Field) {
		return false
	}
	if !(v.Int64Field == rhs.Int64Field) {
		return false
	}
	if !(v.DoubleField == rhs.DoubleField) {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}
	if !bytes.Equal(v.BinaryField, rhs.BinaryField) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *PrimitiveRequiredStruct) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddBool("boolField", v.BoolField)

	enc.AddInt8("byteField", v.ByteField)

	enc.AddInt16("int16Field", v.Int16Field)

	enc.AddInt32("int32Field", v.Int32Field)

	enc.AddInt64("int64Field", v.Int64Field)

	enc.AddFloat64("doubleField", v.DoubleField)

	enc.AddString("stringField", v.StringField)

	enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))

	return nil
}

// GetBoolField returns the value of BoolField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetBoolField() (o bool) { return v.BoolField }

// GetByteField returns the value of ByteField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetByteField() (o int8) { return v.ByteField }

// GetInt16Field returns the value of Int16Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetInt16Field() (o int16) { return v.Int16Field }

// GetInt32Field returns the value of Int32Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetInt32Field() (o int32) { return v.Int32Field }

// GetInt64Field returns the value of Int64Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetInt64Field() (o int64) { return v.Int64Field }

// GetDoubleField returns the value of DoubleField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetDoubleField() (o float64) { return v.DoubleField }

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetStringField() (o string) { return v.StringField }

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetBinaryField() (o []byte) { return v.BinaryField }

type Rename struct {
	Default   string `json:"default,required"`
	CamelCase string `json:"snake_case,required"`
}

// ToWire translates a Rename struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Rename) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Default), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.CamelCase), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Rename struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Rename struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Rename
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Rename) FromWire(w wire.Value) error {
	var err error

	DefaultIsSet := false
	camelCaseIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Default, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				DefaultIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.CamelCase, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				camelCaseIsSet = true
			}
		}
	}

	if !DefaultIsSet {
		return errors.New("field Default of Rename is required")
	}

	if !camelCaseIsSet {
		return errors.New("field CamelCase of Rename is required")
	}

	return nil
}

// String returns a readable string representation of a Rename
// struct.
func (v *Rename) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Default: %v", v.Default)
	i++
	fields[i] = fmt.Sprintf("CamelCase: %v", v.CamelCase)
	i++

	return fmt.Sprintf("Rename{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Rename match the
// provided Rename.
//
// This function performs a deep comparison.
func (v *Rename) Equals(rhs *Rename) bool {
	if !(v.Default == rhs.Default) {
		return false
	}
	if !(v.CamelCase == rhs.CamelCase) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Rename) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddString("Default", v.Default)

	enc.AddString("camelCase", v.CamelCase)

	return nil
}

// GetDefault returns the value of Default if it is set or its
// zero value if it is unset.
func (v *Rename) GetDefault() (o string) { return v.Default }

// GetCamelCase returns the value of CamelCase if it is set or its
// zero value if it is unset.
func (v *Rename) GetCamelCase() (o string) { return v.CamelCase }

// Size of something.
type Size struct {
	// Width in pixels.
	Width float64 `json:"width,required"`
	// Height in pixels.
	Height float64 `json:"height,required"`
}

// ToWire translates a Size struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Size) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueDouble(v.Width), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueDouble(v.Height), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Size struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Size struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Size
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Size) FromWire(w wire.Value) error {
	var err error

	widthIsSet := false
	heightIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				v.Width, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				widthIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TDouble {
				v.Height, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				heightIsSet = true
			}
		}
	}

	if !widthIsSet {
		return errors.New("field Width of Size is required")
	}

	if !heightIsSet {
		return errors.New("field Height of Size is required")
	}

	return nil
}

// String returns a readable string representation of a Size
// struct.
func (v *Size) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Width: %v", v.Width)
	i++
	fields[i] = fmt.Sprintf("Height: %v", v.Height)
	i++

	return fmt.Sprintf("Size{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Size match the
// provided Size.
//
// This function performs a deep comparison.
func (v *Size) Equals(rhs *Size) bool {
	if !(v.Width == rhs.Width) {
		return false
	}
	if !(v.Height == rhs.Height) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *Size) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddFloat64("width", v.Width)

	enc.AddFloat64("height", v.Height)

	return nil
}

// GetWidth returns the value of Width if it is set or its
// zero value if it is unset.
func (v *Size) GetWidth() (o float64) { return v.Width }

// GetHeight returns the value of Height if it is set or its
// zero value if it is unset.
func (v *Size) GetHeight() (o float64) { return v.Height }

type User struct {
	Name    string       `json:"name,required"`
	Contact *ContactInfo `json:"contact,omitempty"`
}

// ToWire translates a User struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *User) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Contact != nil {
		w, err = v.Contact.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ContactInfo_Read(w wire.Value) (*ContactInfo, error) {
	var v ContactInfo
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a User struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a User struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v User
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *User) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Contact, err = _ContactInfo_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of User is required")
	}

	return nil
}

// String returns a readable string representation of a User
// struct.
func (v *User) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.Contact != nil {
		fields[i] = fmt.Sprintf("Contact: %v", v.Contact)
		i++
	}

	return fmt.Sprintf("User{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this User match the
// provided User.
//
// This function performs a deep comparison.
func (v *User) Equals(rhs *User) bool {
	if !(v.Name == rhs.Name) {
		return false
	}
	if !((v.Contact == nil && rhs.Contact == nil) || (v.Contact != nil && rhs.Contact != nil && v.Contact.Equals(rhs.Contact))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler. (TODO)
func (v *User) MarshalLogObject(enc zapcore.ObjectEncoder) error {

	enc.AddString("name", v.Name)

	if v.Contact != nil {
		enc.AddObject("contact", v.Contact)
	}

	return nil
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *User) GetName() (o string) { return v.Name }

// GetContact returns the value of Contact if it is set or its
// zero value if it is unset.
func (v *User) GetContact() (o *ContactInfo) {
	if v.Contact != nil {
		return v.Contact
	}

	return
}
