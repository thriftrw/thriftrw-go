// Code generated by thriftrw v1.20.0. DO NOT EDIT.
// @generated

package structs

import (
	bytes "bytes"
	base64 "encoding/base64"
	errors "errors"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	enums "go.uber.org/thriftrw/gen/internal/tests/enums"
	ptr "go.uber.org/thriftrw/ptr"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	strings "strings"
)

type ContactInfo struct {
	EmailAddress string `json:"emailAddress,required"`
}

// ToWire translates a ContactInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ContactInfo) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.EmailAddress), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ContactInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ContactInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ContactInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ContactInfo) FromWire(w wire.Value) error {
	var err error

	emailAddressIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.EmailAddress, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				emailAddressIsSet = true
			}
		}
	}

	if !emailAddressIsSet {
		return errors.New("field EmailAddress of ContactInfo is required")
	}

	return nil
}

// String returns a readable string representation of a ContactInfo
// struct.
func (v *ContactInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("EmailAddress: %v", v.EmailAddress)
	i++

	return fmt.Sprintf("ContactInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ContactInfo match the
// provided ContactInfo.
//
// This function performs a deep comparison.
func (v *ContactInfo) Equals(rhs *ContactInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.EmailAddress == rhs.EmailAddress) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ContactInfo.
func (v *ContactInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("emailAddress", v.EmailAddress)
	return err
}

// GetEmailAddress returns the value of EmailAddress if it is set or its
// zero value if it is unset.
func (v *ContactInfo) GetEmailAddress() (o string) {
	if v != nil {
		o = v.EmailAddress
	}
	return
}

type DefaultsStruct struct {
	RequiredPrimitive *int32             `json:"requiredPrimitive,omitempty"`
	OptionalPrimitive *int32             `json:"optionalPrimitive,omitempty"`
	RequiredEnum      *enums.EnumDefault `json:"requiredEnum,omitempty"`
	OptionalEnum      *enums.EnumDefault `json:"optionalEnum,omitempty"`
	RequiredList      []string           `json:"requiredList,omitempty"`
	OptionalList      []float64          `json:"optionalList,omitempty"`
	RequiredStruct    *Frame             `json:"requiredStruct,omitempty"`
	OptionalStruct    *Edge              `json:"optionalStruct,omitempty"`
}

func _EnumDefault_ptr(v enums.EnumDefault) *enums.EnumDefault {
	return &v
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

type _List_Double_ValueList []float64

func (v _List_Double_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueDouble(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Double_ValueList) Size() int {
	return len(v)
}

func (_List_Double_ValueList) ValueType() wire.Type {
	return wire.TDouble
}

func (_List_Double_ValueList) Close() {}

// ToWire translates a DefaultsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DefaultsStruct) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.RequiredPrimitive == nil {
		v.RequiredPrimitive = ptr.Int32(100)
	}
	{
		w, err = wire.NewValueI32(*(v.RequiredPrimitive)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.OptionalPrimitive == nil {
		v.OptionalPrimitive = ptr.Int32(200)
	}
	{
		w, err = wire.NewValueI32(*(v.OptionalPrimitive)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.RequiredEnum == nil {
		v.RequiredEnum = _EnumDefault_ptr(enums.EnumDefaultBar)
	}
	{
		w, err = v.RequiredEnum.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.OptionalEnum == nil {
		v.OptionalEnum = _EnumDefault_ptr(enums.EnumDefaultBaz)
	}
	{
		w, err = v.OptionalEnum.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.RequiredList == nil {
		v.RequiredList = []string{
			"hello",
			"world",
		}
	}
	{
		w, err = wire.NewValueList(_List_String_ValueList(v.RequiredList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.OptionalList == nil {
		v.OptionalList = []float64{
			1,
			2,
			3,
		}
	}
	{
		w, err = wire.NewValueList(_List_Double_ValueList(v.OptionalList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.RequiredStruct == nil {
		v.RequiredStruct = &Frame{
			Size: &Size{
				Height: 200,
				Width:  100,
			},
			TopLeft: &Point{
				X: 1,
				Y: 2,
			},
		}
	}
	{
		w, err = v.RequiredStruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.OptionalStruct == nil {
		v.OptionalStruct = &Edge{
			EndPoint: &Point{
				X: 3,
				Y: 4,
			},
			StartPoint: &Point{
				X: 1,
				Y: 2,
			},
		}
	}
	{
		w, err = v.OptionalStruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EnumDefault_Read(w wire.Value) (enums.EnumDefault, error) {
	var v enums.EnumDefault
	err := v.FromWire(w)
	return v, err
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_Double_Read(l wire.ValueList) ([]float64, error) {
	if l.ValueType() != wire.TDouble {
		return nil, nil
	}

	o := make([]float64, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetDouble(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Frame_Read(w wire.Value) (*Frame, error) {
	var v Frame
	err := v.FromWire(w)
	return &v, err
}

func _Edge_Read(w wire.Value) (*Edge, error) {
	var v Edge
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a DefaultsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DefaultsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DefaultsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DefaultsStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RequiredPrimitive = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.OptionalPrimitive = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x enums.EnumDefault
				x, err = _EnumDefault_Read(field.Value)
				v.RequiredEnum = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x enums.EnumDefault
				x, err = _EnumDefault_Read(field.Value)
				v.OptionalEnum = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.RequiredList, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TList {
				v.OptionalList, err = _List_Double_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.RequiredStruct, err = _Frame_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TStruct {
				v.OptionalStruct, err = _Edge_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if v.RequiredPrimitive == nil {
		v.RequiredPrimitive = ptr.Int32(100)
	}

	if v.OptionalPrimitive == nil {
		v.OptionalPrimitive = ptr.Int32(200)
	}

	if v.RequiredEnum == nil {
		v.RequiredEnum = _EnumDefault_ptr(enums.EnumDefaultBar)
	}

	if v.OptionalEnum == nil {
		v.OptionalEnum = _EnumDefault_ptr(enums.EnumDefaultBaz)
	}

	if v.RequiredList == nil {
		v.RequiredList = []string{
			"hello",
			"world",
		}
	}

	if v.OptionalList == nil {
		v.OptionalList = []float64{
			1,
			2,
			3,
		}
	}

	if v.RequiredStruct == nil {
		v.RequiredStruct = &Frame{
			Size: &Size{
				Height: 200,
				Width:  100,
			},
			TopLeft: &Point{
				X: 1,
				Y: 2,
			},
		}
	}

	if v.OptionalStruct == nil {
		v.OptionalStruct = &Edge{
			EndPoint: &Point{
				X: 3,
				Y: 4,
			},
			StartPoint: &Point{
				X: 1,
				Y: 2,
			},
		}
	}

	return nil
}

// String returns a readable string representation of a DefaultsStruct
// struct.
func (v *DefaultsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	if v.RequiredPrimitive != nil {
		fields[i] = fmt.Sprintf("RequiredPrimitive: %v", *(v.RequiredPrimitive))
		i++
	}
	if v.OptionalPrimitive != nil {
		fields[i] = fmt.Sprintf("OptionalPrimitive: %v", *(v.OptionalPrimitive))
		i++
	}
	if v.RequiredEnum != nil {
		fields[i] = fmt.Sprintf("RequiredEnum: %v", *(v.RequiredEnum))
		i++
	}
	if v.OptionalEnum != nil {
		fields[i] = fmt.Sprintf("OptionalEnum: %v", *(v.OptionalEnum))
		i++
	}
	if v.RequiredList != nil {
		fields[i] = fmt.Sprintf("RequiredList: %v", v.RequiredList)
		i++
	}
	if v.OptionalList != nil {
		fields[i] = fmt.Sprintf("OptionalList: %v", v.OptionalList)
		i++
	}
	if v.RequiredStruct != nil {
		fields[i] = fmt.Sprintf("RequiredStruct: %v", v.RequiredStruct)
		i++
	}
	if v.OptionalStruct != nil {
		fields[i] = fmt.Sprintf("OptionalStruct: %v", v.OptionalStruct)
		i++
	}

	return fmt.Sprintf("DefaultsStruct{%v}", strings.Join(fields[:i], ", "))
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _EnumDefault_EqualsPtr(lhs, rhs *enums.EnumDefault) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

func _List_Double_Equals(lhs, rhs []float64) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this DefaultsStruct match the
// provided DefaultsStruct.
//
// This function performs a deep comparison.
func (v *DefaultsStruct) Equals(rhs *DefaultsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.RequiredPrimitive, rhs.RequiredPrimitive) {
		return false
	}
	if !_I32_EqualsPtr(v.OptionalPrimitive, rhs.OptionalPrimitive) {
		return false
	}
	if !_EnumDefault_EqualsPtr(v.RequiredEnum, rhs.RequiredEnum) {
		return false
	}
	if !_EnumDefault_EqualsPtr(v.OptionalEnum, rhs.OptionalEnum) {
		return false
	}
	if !((v.RequiredList == nil && rhs.RequiredList == nil) || (v.RequiredList != nil && rhs.RequiredList != nil && _List_String_Equals(v.RequiredList, rhs.RequiredList))) {
		return false
	}
	if !((v.OptionalList == nil && rhs.OptionalList == nil) || (v.OptionalList != nil && rhs.OptionalList != nil && _List_Double_Equals(v.OptionalList, rhs.OptionalList))) {
		return false
	}
	if !((v.RequiredStruct == nil && rhs.RequiredStruct == nil) || (v.RequiredStruct != nil && rhs.RequiredStruct != nil && v.RequiredStruct.Equals(rhs.RequiredStruct))) {
		return false
	}
	if !((v.OptionalStruct == nil && rhs.OptionalStruct == nil) || (v.OptionalStruct != nil && rhs.OptionalStruct != nil && v.OptionalStruct.Equals(rhs.OptionalStruct))) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

type _List_Double_Zapper []float64

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Double_Zapper.
func (l _List_Double_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendFloat64(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DefaultsStruct.
func (v *DefaultsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.RequiredPrimitive != nil {
		enc.AddInt32("requiredPrimitive", *v.RequiredPrimitive)
	}
	if v.OptionalPrimitive != nil {
		enc.AddInt32("optionalPrimitive", *v.OptionalPrimitive)
	}
	if v.RequiredEnum != nil {
		err = multierr.Append(err, enc.AddObject("requiredEnum", *v.RequiredEnum))
	}
	if v.OptionalEnum != nil {
		err = multierr.Append(err, enc.AddObject("optionalEnum", *v.OptionalEnum))
	}
	if v.RequiredList != nil {
		err = multierr.Append(err, enc.AddArray("requiredList", (_List_String_Zapper)(v.RequiredList)))
	}
	if v.OptionalList != nil {
		err = multierr.Append(err, enc.AddArray("optionalList", (_List_Double_Zapper)(v.OptionalList)))
	}
	if v.RequiredStruct != nil {
		err = multierr.Append(err, enc.AddObject("requiredStruct", v.RequiredStruct))
	}
	if v.OptionalStruct != nil {
		err = multierr.Append(err, enc.AddObject("optionalStruct", v.OptionalStruct))
	}
	return err
}

// GetRequiredPrimitive returns the value of RequiredPrimitive if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredPrimitive() (o int32) {
	if v != nil && v.RequiredPrimitive != nil {
		return *v.RequiredPrimitive
	}
	o = 100
	return
}

// IsSetRequiredPrimitive returns true if RequiredPrimitive is not nil.
func (v *DefaultsStruct) IsSetRequiredPrimitive() bool {
	return v != nil && v.RequiredPrimitive != nil
}

// GetOptionalPrimitive returns the value of OptionalPrimitive if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalPrimitive() (o int32) {
	if v != nil && v.OptionalPrimitive != nil {
		return *v.OptionalPrimitive
	}
	o = 200
	return
}

// IsSetOptionalPrimitive returns true if OptionalPrimitive is not nil.
func (v *DefaultsStruct) IsSetOptionalPrimitive() bool {
	return v != nil && v.OptionalPrimitive != nil
}

// GetRequiredEnum returns the value of RequiredEnum if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredEnum() (o enums.EnumDefault) {
	if v != nil && v.RequiredEnum != nil {
		return *v.RequiredEnum
	}
	o = enums.EnumDefaultBar
	return
}

// IsSetRequiredEnum returns true if RequiredEnum is not nil.
func (v *DefaultsStruct) IsSetRequiredEnum() bool {
	return v != nil && v.RequiredEnum != nil
}

// GetOptionalEnum returns the value of OptionalEnum if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalEnum() (o enums.EnumDefault) {
	if v != nil && v.OptionalEnum != nil {
		return *v.OptionalEnum
	}
	o = enums.EnumDefaultBaz
	return
}

// IsSetOptionalEnum returns true if OptionalEnum is not nil.
func (v *DefaultsStruct) IsSetOptionalEnum() bool {
	return v != nil && v.OptionalEnum != nil
}

// GetRequiredList returns the value of RequiredList if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredList() (o []string) {
	if v != nil && v.RequiredList != nil {
		return v.RequiredList
	}
	o = []string{
		"hello",
		"world",
	}
	return
}

// IsSetRequiredList returns true if RequiredList is not nil.
func (v *DefaultsStruct) IsSetRequiredList() bool {
	return v != nil && v.RequiredList != nil
}

// GetOptionalList returns the value of OptionalList if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalList() (o []float64) {
	if v != nil && v.OptionalList != nil {
		return v.OptionalList
	}
	o = []float64{
		1,
		2,
		3,
	}
	return
}

// IsSetOptionalList returns true if OptionalList is not nil.
func (v *DefaultsStruct) IsSetOptionalList() bool {
	return v != nil && v.OptionalList != nil
}

// GetRequiredStruct returns the value of RequiredStruct if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetRequiredStruct() (o *Frame) {
	if v != nil && v.RequiredStruct != nil {
		return v.RequiredStruct
	}
	o = &Frame{
		Size: &Size{
			Height: 200,
			Width:  100,
		},
		TopLeft: &Point{
			X: 1,
			Y: 2,
		},
	}
	return
}

// IsSetRequiredStruct returns true if RequiredStruct is not nil.
func (v *DefaultsStruct) IsSetRequiredStruct() bool {
	return v != nil && v.RequiredStruct != nil
}

// GetOptionalStruct returns the value of OptionalStruct if it is set or its
// default value if it is unset.
func (v *DefaultsStruct) GetOptionalStruct() (o *Edge) {
	if v != nil && v.OptionalStruct != nil {
		return v.OptionalStruct
	}
	o = &Edge{
		EndPoint: &Point{
			X: 3,
			Y: 4,
		},
		StartPoint: &Point{
			X: 1,
			Y: 2,
		},
	}
	return
}

// IsSetOptionalStruct returns true if OptionalStruct is not nil.
func (v *DefaultsStruct) IsSetOptionalStruct() bool {
	return v != nil && v.OptionalStruct != nil
}

type Edge struct {
	StartPoint *Point `json:"startPoint,required"`
	EndPoint   *Point `json:"endPoint,required"`
}

// ToWire translates a Edge struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Edge) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StartPoint == nil {
		return w, errors.New("field StartPoint of Edge is required")
	}
	w, err = v.StartPoint.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.EndPoint == nil {
		return w, errors.New("field EndPoint of Edge is required")
	}
	w, err = v.EndPoint.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Point_Read(w wire.Value) (*Point, error) {
	var v Point
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Edge struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Edge struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Edge
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Edge) FromWire(w wire.Value) error {
	var err error

	startPointIsSet := false
	endPointIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.StartPoint, err = _Point_Read(field.Value)
				if err != nil {
					return err
				}
				startPointIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.EndPoint, err = _Point_Read(field.Value)
				if err != nil {
					return err
				}
				endPointIsSet = true
			}
		}
	}

	if !startPointIsSet {
		return errors.New("field StartPoint of Edge is required")
	}

	if !endPointIsSet {
		return errors.New("field EndPoint of Edge is required")
	}

	return nil
}

// String returns a readable string representation of a Edge
// struct.
func (v *Edge) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("StartPoint: %v", v.StartPoint)
	i++
	fields[i] = fmt.Sprintf("EndPoint: %v", v.EndPoint)
	i++

	return fmt.Sprintf("Edge{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Edge match the
// provided Edge.
//
// This function performs a deep comparison.
func (v *Edge) Equals(rhs *Edge) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.StartPoint.Equals(rhs.StartPoint) {
		return false
	}
	if !v.EndPoint.Equals(rhs.EndPoint) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Edge.
func (v *Edge) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("startPoint", v.StartPoint))
	err = multierr.Append(err, enc.AddObject("endPoint", v.EndPoint))
	return err
}

// GetStartPoint returns the value of StartPoint if it is set or its
// zero value if it is unset.
func (v *Edge) GetStartPoint() (o *Point) {
	if v != nil {
		o = v.StartPoint
	}
	return
}

// IsSetStartPoint returns true if StartPoint is not nil.
func (v *Edge) IsSetStartPoint() bool {
	return v != nil && v.StartPoint != nil
}

// GetEndPoint returns the value of EndPoint if it is set or its
// zero value if it is unset.
func (v *Edge) GetEndPoint() (o *Point) {
	if v != nil {
		o = v.EndPoint
	}
	return
}

// IsSetEndPoint returns true if EndPoint is not nil.
func (v *Edge) IsSetEndPoint() bool {
	return v != nil && v.EndPoint != nil
}

type EmptyStruct struct {
}

// ToWire translates a EmptyStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EmptyStruct) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a EmptyStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EmptyStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EmptyStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EmptyStruct) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a EmptyStruct
// struct.
func (v *EmptyStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("EmptyStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this EmptyStruct match the
// provided EmptyStruct.
//
// This function performs a deep comparison.
func (v *EmptyStruct) Equals(rhs *EmptyStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EmptyStruct.
func (v *EmptyStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

type Frame struct {
	TopLeft *Point `json:"topLeft,required"`
	Size    *Size  `json:"size,required"`
}

// ToWire translates a Frame struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Frame) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TopLeft == nil {
		return w, errors.New("field TopLeft of Frame is required")
	}
	w, err = v.TopLeft.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Size == nil {
		return w, errors.New("field Size of Frame is required")
	}
	w, err = v.Size.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Size_Read(w wire.Value) (*Size, error) {
	var v Size
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Frame struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Frame struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Frame
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Frame) FromWire(w wire.Value) error {
	var err error

	topLeftIsSet := false
	sizeIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.TopLeft, err = _Point_Read(field.Value)
				if err != nil {
					return err
				}
				topLeftIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Size, err = _Size_Read(field.Value)
				if err != nil {
					return err
				}
				sizeIsSet = true
			}
		}
	}

	if !topLeftIsSet {
		return errors.New("field TopLeft of Frame is required")
	}

	if !sizeIsSet {
		return errors.New("field Size of Frame is required")
	}

	return nil
}

// String returns a readable string representation of a Frame
// struct.
func (v *Frame) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("TopLeft: %v", v.TopLeft)
	i++
	fields[i] = fmt.Sprintf("Size: %v", v.Size)
	i++

	return fmt.Sprintf("Frame{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Frame match the
// provided Frame.
//
// This function performs a deep comparison.
func (v *Frame) Equals(rhs *Frame) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.TopLeft.Equals(rhs.TopLeft) {
		return false
	}
	if !v.Size.Equals(rhs.Size) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Frame.
func (v *Frame) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("topLeft", v.TopLeft))
	err = multierr.Append(err, enc.AddObject("size", v.Size))
	return err
}

// GetTopLeft returns the value of TopLeft if it is set or its
// zero value if it is unset.
func (v *Frame) GetTopLeft() (o *Point) {
	if v != nil {
		o = v.TopLeft
	}
	return
}

// IsSetTopLeft returns true if TopLeft is not nil.
func (v *Frame) IsSetTopLeft() bool {
	return v != nil && v.TopLeft != nil
}

// GetSize returns the value of Size if it is set or its
// zero value if it is unset.
func (v *Frame) GetSize() (o *Size) {
	if v != nil {
		o = v.Size
	}
	return
}

// IsSetSize returns true if Size is not nil.
func (v *Frame) IsSetSize() bool {
	return v != nil && v.Size != nil
}

type GoTags struct {
	Foo                 string  `json:"-" foo:"bar"`
	Bar                 *string `json:"Bar,omitempty" bar:"foo"`
	FooBar              string  `json:"foobar,option1,option2,required" bar:"foo,option1" foo:"foobar"`
	FooBarWithSpace     string  `json:"foobarWithSpace,required" foo:"foo bar foobar barfoo"`
	FooBarWithOmitEmpty *string `json:"foobarWithOmitEmpty,omitempty"`
	FooBarWithRequired  string  `json:"foobarWithRequired,required"`
}

// ToWire translates a GoTags struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GoTags) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Foo), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Bar != nil {
		w, err = wire.NewValueString(*(v.Bar)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	w, err = wire.NewValueString(v.FooBar), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	w, err = wire.NewValueString(v.FooBarWithSpace), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++
	if v.FooBarWithOmitEmpty != nil {
		w, err = wire.NewValueString(*(v.FooBarWithOmitEmpty)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	w, err = wire.NewValueString(v.FooBarWithRequired), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a GoTags struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GoTags struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GoTags
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GoTags) FromWire(w wire.Value) error {
	var err error

	FooIsSet := false

	FooBarIsSet := false
	FooBarWithSpaceIsSet := false

	FooBarWithRequiredIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Foo, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Bar = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				v.FooBar, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooBarIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				v.FooBarWithSpace, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooBarWithSpaceIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.FooBarWithOmitEmpty = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TBinary {
				v.FooBarWithRequired, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				FooBarWithRequiredIsSet = true
			}
		}
	}

	if !FooIsSet {
		return errors.New("field Foo of GoTags is required")
	}

	if !FooBarIsSet {
		return errors.New("field FooBar of GoTags is required")
	}

	if !FooBarWithSpaceIsSet {
		return errors.New("field FooBarWithSpace of GoTags is required")
	}

	if !FooBarWithRequiredIsSet {
		return errors.New("field FooBarWithRequired of GoTags is required")
	}

	return nil
}

// String returns a readable string representation of a GoTags
// struct.
func (v *GoTags) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
	i++
	if v.Bar != nil {
		fields[i] = fmt.Sprintf("Bar: %v", *(v.Bar))
		i++
	}
	fields[i] = fmt.Sprintf("FooBar: %v", v.FooBar)
	i++
	fields[i] = fmt.Sprintf("FooBarWithSpace: %v", v.FooBarWithSpace)
	i++
	if v.FooBarWithOmitEmpty != nil {
		fields[i] = fmt.Sprintf("FooBarWithOmitEmpty: %v", *(v.FooBarWithOmitEmpty))
		i++
	}
	fields[i] = fmt.Sprintf("FooBarWithRequired: %v", v.FooBarWithRequired)
	i++

	return fmt.Sprintf("GoTags{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this GoTags match the
// provided GoTags.
//
// This function performs a deep comparison.
func (v *GoTags) Equals(rhs *GoTags) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Foo == rhs.Foo) {
		return false
	}
	if !_String_EqualsPtr(v.Bar, rhs.Bar) {
		return false
	}
	if !(v.FooBar == rhs.FooBar) {
		return false
	}
	if !(v.FooBarWithSpace == rhs.FooBarWithSpace) {
		return false
	}
	if !_String_EqualsPtr(v.FooBarWithOmitEmpty, rhs.FooBarWithOmitEmpty) {
		return false
	}
	if !(v.FooBarWithRequired == rhs.FooBarWithRequired) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GoTags.
func (v *GoTags) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("Foo", v.Foo)
	if v.Bar != nil {
		enc.AddString("Bar", *v.Bar)
	}
	enc.AddString("FooBar", v.FooBar)
	enc.AddString("FooBarWithSpace", v.FooBarWithSpace)
	if v.FooBarWithOmitEmpty != nil {
		enc.AddString("FooBarWithOmitEmpty", *v.FooBarWithOmitEmpty)
	}
	enc.AddString("FooBarWithRequired", v.FooBarWithRequired)
	return err
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFoo() (o string) {
	if v != nil {
		o = v.Foo
	}
	return
}

// GetBar returns the value of Bar if it is set or its
// zero value if it is unset.
func (v *GoTags) GetBar() (o string) {
	if v != nil && v.Bar != nil {
		return *v.Bar
	}

	return
}

// IsSetBar returns true if Bar is not nil.
func (v *GoTags) IsSetBar() bool {
	return v != nil && v.Bar != nil
}

// GetFooBar returns the value of FooBar if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBar() (o string) {
	if v != nil {
		o = v.FooBar
	}
	return
}

// GetFooBarWithSpace returns the value of FooBarWithSpace if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBarWithSpace() (o string) {
	if v != nil {
		o = v.FooBarWithSpace
	}
	return
}

// GetFooBarWithOmitEmpty returns the value of FooBarWithOmitEmpty if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBarWithOmitEmpty() (o string) {
	if v != nil && v.FooBarWithOmitEmpty != nil {
		return *v.FooBarWithOmitEmpty
	}

	return
}

// IsSetFooBarWithOmitEmpty returns true if FooBarWithOmitEmpty is not nil.
func (v *GoTags) IsSetFooBarWithOmitEmpty() bool {
	return v != nil && v.FooBarWithOmitEmpty != nil
}

// GetFooBarWithRequired returns the value of FooBarWithRequired if it is set or its
// zero value if it is unset.
func (v *GoTags) GetFooBarWithRequired() (o string) {
	if v != nil {
		o = v.FooBarWithRequired
	}
	return
}

// A graph is comprised of zero or more edges.
type Graph struct {
	// List of edges in the graph.
	//
	// May be empty.
	Edges []*Edge `json:"edges,required"`
}

type _List_Edge_ValueList []*Edge

func (v _List_Edge_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Edge_ValueList) Size() int {
	return len(v)
}

func (_List_Edge_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Edge_ValueList) Close() {}

// ToWire translates a Graph struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Graph) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Edges == nil {
		return w, errors.New("field Edges of Graph is required")
	}
	w, err = wire.NewValueList(_List_Edge_ValueList(v.Edges)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Edge_Read(l wire.ValueList) ([]*Edge, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Edge, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Edge_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Graph struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Graph struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Graph
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Graph) FromWire(w wire.Value) error {
	var err error

	edgesIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Edges, err = _List_Edge_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				edgesIsSet = true
			}
		}
	}

	if !edgesIsSet {
		return errors.New("field Edges of Graph is required")
	}

	return nil
}

// String returns a readable string representation of a Graph
// struct.
func (v *Graph) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Edges: %v", v.Edges)
	i++

	return fmt.Sprintf("Graph{%v}", strings.Join(fields[:i], ", "))
}

func _List_Edge_Equals(lhs, rhs []*Edge) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Graph match the
// provided Graph.
//
// This function performs a deep comparison.
func (v *Graph) Equals(rhs *Graph) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_List_Edge_Equals(v.Edges, rhs.Edges) {
		return false
	}

	return true
}

type _List_Edge_Zapper []*Edge

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Edge_Zapper.
func (l _List_Edge_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Graph.
func (v *Graph) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("edges", (_List_Edge_Zapper)(v.Edges)))
	return err
}

// GetEdges returns the value of Edges if it is set or its
// zero value if it is unset.
func (v *Graph) GetEdges() (o []*Edge) {
	if v != nil {
		o = v.Edges
	}
	return
}

// IsSetEdges returns true if Edges is not nil.
func (v *Graph) IsSetEdges() bool {
	return v != nil && v.Edges != nil
}

type List Node

// ToWire translates List into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v *List) ToWire() (wire.Value, error) {
	x := (*Node)(v)
	return x.ToWire()
}

// String returns a readable string representation of List.
func (v *List) String() string {
	x := (*Node)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes List from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *List) FromWire(w wire.Value) error {
	return (*Node)(v).FromWire(w)
}

// Equals returns true if this List is equal to the provided
// List.
func (lhs *List) Equals(rhs *List) bool {
	return (*Node)(lhs).Equals((*Node)(rhs))
}

func (v *List) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((*Node)(v)).MarshalLogObject(enc)
}

// Node is linked list of values.
// All values are 32-bit integers.
type Node struct {
	Value int32 `json:"value,required"`
	Tail  *List `json:"tail,omitempty"`
}

// ToWire translates a Node struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Node) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI32(v.Value), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Tail != nil {
		w, err = v.Tail.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Read(w wire.Value) (*List, error) {
	var x List
	err := x.FromWire(w)
	return &x, err
}

// FromWire deserializes a Node struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Node struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Node
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Node) FromWire(w wire.Value) error {
	var err error

	valueIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				v.Value, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				valueIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Tail, err = _List_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !valueIsSet {
		return errors.New("field Value of Node is required")
	}

	return nil
}

// String returns a readable string representation of a Node
// struct.
func (v *Node) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Value: %v", v.Value)
	i++
	if v.Tail != nil {
		fields[i] = fmt.Sprintf("Tail: %v", v.Tail)
		i++
	}

	return fmt.Sprintf("Node{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Node match the
// provided Node.
//
// This function performs a deep comparison.
func (v *Node) Equals(rhs *Node) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Value == rhs.Value) {
		return false
	}
	if !((v.Tail == nil && rhs.Tail == nil) || (v.Tail != nil && rhs.Tail != nil && v.Tail.Equals(rhs.Tail))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Node.
func (v *Node) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddInt32("value", v.Value)
	if v.Tail != nil {
		err = multierr.Append(err, enc.AddObject("tail", (*Node)(v.Tail)))
	}
	return err
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *Node) GetValue() (o int32) {
	if v != nil {
		o = v.Value
	}
	return
}

// GetTail returns the value of Tail if it is set or its
// zero value if it is unset.
func (v *Node) GetTail() (o *List) {
	if v != nil && v.Tail != nil {
		return v.Tail
	}

	return
}

// IsSetTail returns true if Tail is not nil.
func (v *Node) IsSetTail() bool {
	return v != nil && v.Tail != nil
}

type Omit struct {
	Serialized string `json:"serialized,required"`
	Hidden     string `json:"-"`
}

// ToWire translates a Omit struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Omit) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Serialized), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.Hidden), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Omit struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Omit struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Omit
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Omit) FromWire(w wire.Value) error {
	var err error

	serializedIsSet := false
	hiddenIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Serialized, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				serializedIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Hidden, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				hiddenIsSet = true
			}
		}
	}

	if !serializedIsSet {
		return errors.New("field Serialized of Omit is required")
	}

	if !hiddenIsSet {
		return errors.New("field Hidden of Omit is required")
	}

	return nil
}

// String returns a readable string representation of a Omit
// struct.
func (v *Omit) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Serialized: %v", v.Serialized)
	i++
	fields[i] = fmt.Sprintf("Hidden: %v", v.Hidden)
	i++

	return fmt.Sprintf("Omit{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Omit match the
// provided Omit.
//
// This function performs a deep comparison.
func (v *Omit) Equals(rhs *Omit) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Serialized == rhs.Serialized) {
		return false
	}
	if !(v.Hidden == rhs.Hidden) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Omit.
func (v *Omit) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("serialized", v.Serialized)
	enc.AddString("hidden", v.Hidden)
	return err
}

// GetSerialized returns the value of Serialized if it is set or its
// zero value if it is unset.
func (v *Omit) GetSerialized() (o string) {
	if v != nil {
		o = v.Serialized
	}
	return
}

// GetHidden returns the value of Hidden if it is set or its
// zero value if it is unset.
func (v *Omit) GetHidden() (o string) {
	if v != nil {
		o = v.Hidden
	}
	return
}

type PersonalInfo struct {
	Age *int32 `json:"age,omitempty"`
}

// ToWire translates a PersonalInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PersonalInfo) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Age != nil {
		w, err = wire.NewValueI32(*(v.Age)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PersonalInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PersonalInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PersonalInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PersonalInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Age = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PersonalInfo
// struct.
func (v *PersonalInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Age != nil {
		fields[i] = fmt.Sprintf("Age: %v", *(v.Age))
		i++
	}

	return fmt.Sprintf("PersonalInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this PersonalInfo match the
// provided PersonalInfo.
//
// This function performs a deep comparison.
func (v *PersonalInfo) Equals(rhs *PersonalInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Age, rhs.Age) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PersonalInfo.
func (v *PersonalInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Age != nil {
		enc.AddInt32("age", *v.Age)
	}
	return err
}

// GetAge returns the value of Age if it is set or its
// zero value if it is unset.
func (v *PersonalInfo) GetAge() (o int32) {
	if v != nil && v.Age != nil {
		return *v.Age
	}

	return
}

// IsSetAge returns true if Age is not nil.
func (v *PersonalInfo) IsSetAge() bool {
	return v != nil && v.Age != nil
}

// A point in 2D space.
type Point struct {
	X float64 `json:"x,required"`
	Y float64 `json:"y,required"`
}

// ToWire translates a Point struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Point) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueDouble(v.X), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueDouble(v.Y), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Point struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Point struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Point
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Point) FromWire(w wire.Value) error {
	var err error

	xIsSet := false
	yIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				v.X, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				xIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TDouble {
				v.Y, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				yIsSet = true
			}
		}
	}

	if !xIsSet {
		return errors.New("field X of Point is required")
	}

	if !yIsSet {
		return errors.New("field Y of Point is required")
	}

	return nil
}

// String returns a readable string representation of a Point
// struct.
func (v *Point) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("X: %v", v.X)
	i++
	fields[i] = fmt.Sprintf("Y: %v", v.Y)
	i++

	return fmt.Sprintf("Point{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Point match the
// provided Point.
//
// This function performs a deep comparison.
func (v *Point) Equals(rhs *Point) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.X == rhs.X) {
		return false
	}
	if !(v.Y == rhs.Y) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Point.
func (v *Point) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddFloat64("x", v.X)
	enc.AddFloat64("y", v.Y)
	return err
}

// GetX returns the value of X if it is set or its
// zero value if it is unset.
func (v *Point) GetX() (o float64) {
	if v != nil {
		o = v.X
	}
	return
}

// GetY returns the value of Y if it is set or its
// zero value if it is unset.
func (v *Point) GetY() (o float64) {
	if v != nil {
		o = v.Y
	}
	return
}

// A struct that contains primitive fields exclusively.
//
// All fields are optional.
type PrimitiveOptionalStruct struct {
	BoolField   *bool    `json:"boolField,omitempty"`
	ByteField   *int8    `json:"byteField,omitempty"`
	Int16Field  *int16   `json:"int16Field,omitempty"`
	Int32Field  *int32   `json:"int32Field,omitempty"`
	Int64Field  *int64   `json:"int64Field,omitempty"`
	DoubleField *float64 `json:"doubleField,omitempty"`
	StringField *string  `json:"stringField,omitempty"`
	BinaryField []byte   `json:"binaryField,omitempty"`
}

// ToWire translates a PrimitiveOptionalStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PrimitiveOptionalStruct) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BoolField != nil {
		w, err = wire.NewValueBool(*(v.BoolField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ByteField != nil {
		w, err = wire.NewValueI8(*(v.ByteField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Int16Field != nil {
		w, err = wire.NewValueI16(*(v.Int16Field)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Int32Field != nil {
		w, err = wire.NewValueI32(*(v.Int32Field)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Int64Field != nil {
		w, err = wire.NewValueI64(*(v.Int64Field)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.DoubleField != nil {
		w, err = wire.NewValueDouble(*(v.DoubleField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.StringField != nil {
		w, err = wire.NewValueString(*(v.StringField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.BinaryField != nil {
		w, err = wire.NewValueBinary(v.BinaryField), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PrimitiveOptionalStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PrimitiveOptionalStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PrimitiveOptionalStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PrimitiveOptionalStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.BoolField = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteField = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Int16Field = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Int32Field = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Int64Field = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.DoubleField = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringField = &x
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PrimitiveOptionalStruct
// struct.
func (v *PrimitiveOptionalStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	if v.BoolField != nil {
		fields[i] = fmt.Sprintf("BoolField: %v", *(v.BoolField))
		i++
	}
	if v.ByteField != nil {
		fields[i] = fmt.Sprintf("ByteField: %v", *(v.ByteField))
		i++
	}
	if v.Int16Field != nil {
		fields[i] = fmt.Sprintf("Int16Field: %v", *(v.Int16Field))
		i++
	}
	if v.Int32Field != nil {
		fields[i] = fmt.Sprintf("Int32Field: %v", *(v.Int32Field))
		i++
	}
	if v.Int64Field != nil {
		fields[i] = fmt.Sprintf("Int64Field: %v", *(v.Int64Field))
		i++
	}
	if v.DoubleField != nil {
		fields[i] = fmt.Sprintf("DoubleField: %v", *(v.DoubleField))
		i++
	}
	if v.StringField != nil {
		fields[i] = fmt.Sprintf("StringField: %v", *(v.StringField))
		i++
	}
	if v.BinaryField != nil {
		fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
		i++
	}

	return fmt.Sprintf("PrimitiveOptionalStruct{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Byte_EqualsPtr(lhs, rhs *int8) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this PrimitiveOptionalStruct match the
// provided PrimitiveOptionalStruct.
//
// This function performs a deep comparison.
func (v *PrimitiveOptionalStruct) Equals(rhs *PrimitiveOptionalStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.BoolField, rhs.BoolField) {
		return false
	}
	if !_Byte_EqualsPtr(v.ByteField, rhs.ByteField) {
		return false
	}
	if !_I16_EqualsPtr(v.Int16Field, rhs.Int16Field) {
		return false
	}
	if !_I32_EqualsPtr(v.Int32Field, rhs.Int32Field) {
		return false
	}
	if !_I64_EqualsPtr(v.Int64Field, rhs.Int64Field) {
		return false
	}
	if !_Double_EqualsPtr(v.DoubleField, rhs.DoubleField) {
		return false
	}
	if !_String_EqualsPtr(v.StringField, rhs.StringField) {
		return false
	}
	if !((v.BinaryField == nil && rhs.BinaryField == nil) || (v.BinaryField != nil && rhs.BinaryField != nil && bytes.Equal(v.BinaryField, rhs.BinaryField))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PrimitiveOptionalStruct.
func (v *PrimitiveOptionalStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BoolField != nil {
		enc.AddBool("boolField", *v.BoolField)
	}
	if v.ByteField != nil {
		enc.AddInt8("byteField", *v.ByteField)
	}
	if v.Int16Field != nil {
		enc.AddInt16("int16Field", *v.Int16Field)
	}
	if v.Int32Field != nil {
		enc.AddInt32("int32Field", *v.Int32Field)
	}
	if v.Int64Field != nil {
		enc.AddInt64("int64Field", *v.Int64Field)
	}
	if v.DoubleField != nil {
		enc.AddFloat64("doubleField", *v.DoubleField)
	}
	if v.StringField != nil {
		enc.AddString("stringField", *v.StringField)
	}
	if v.BinaryField != nil {
		enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))
	}
	return err
}

// GetBoolField returns the value of BoolField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetBoolField() (o bool) {
	if v != nil && v.BoolField != nil {
		return *v.BoolField
	}

	return
}

// IsSetBoolField returns true if BoolField is not nil.
func (v *PrimitiveOptionalStruct) IsSetBoolField() bool {
	return v != nil && v.BoolField != nil
}

// GetByteField returns the value of ByteField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetByteField() (o int8) {
	if v != nil && v.ByteField != nil {
		return *v.ByteField
	}

	return
}

// IsSetByteField returns true if ByteField is not nil.
func (v *PrimitiveOptionalStruct) IsSetByteField() bool {
	return v != nil && v.ByteField != nil
}

// GetInt16Field returns the value of Int16Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetInt16Field() (o int16) {
	if v != nil && v.Int16Field != nil {
		return *v.Int16Field
	}

	return
}

// IsSetInt16Field returns true if Int16Field is not nil.
func (v *PrimitiveOptionalStruct) IsSetInt16Field() bool {
	return v != nil && v.Int16Field != nil
}

// GetInt32Field returns the value of Int32Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetInt32Field() (o int32) {
	if v != nil && v.Int32Field != nil {
		return *v.Int32Field
	}

	return
}

// IsSetInt32Field returns true if Int32Field is not nil.
func (v *PrimitiveOptionalStruct) IsSetInt32Field() bool {
	return v != nil && v.Int32Field != nil
}

// GetInt64Field returns the value of Int64Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetInt64Field() (o int64) {
	if v != nil && v.Int64Field != nil {
		return *v.Int64Field
	}

	return
}

// IsSetInt64Field returns true if Int64Field is not nil.
func (v *PrimitiveOptionalStruct) IsSetInt64Field() bool {
	return v != nil && v.Int64Field != nil
}

// GetDoubleField returns the value of DoubleField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetDoubleField() (o float64) {
	if v != nil && v.DoubleField != nil {
		return *v.DoubleField
	}

	return
}

// IsSetDoubleField returns true if DoubleField is not nil.
func (v *PrimitiveOptionalStruct) IsSetDoubleField() bool {
	return v != nil && v.DoubleField != nil
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetStringField() (o string) {
	if v != nil && v.StringField != nil {
		return *v.StringField
	}

	return
}

// IsSetStringField returns true if StringField is not nil.
func (v *PrimitiveOptionalStruct) IsSetStringField() bool {
	return v != nil && v.StringField != nil
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *PrimitiveOptionalStruct) GetBinaryField() (o []byte) {
	if v != nil && v.BinaryField != nil {
		return v.BinaryField
	}

	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *PrimitiveOptionalStruct) IsSetBinaryField() bool {
	return v != nil && v.BinaryField != nil
}

// A struct that contains primitive fields exclusively.
//
// All fields are required.
type PrimitiveRequiredStruct struct {
	BoolField   bool    `json:"boolField,required"`
	ByteField   int8    `json:"byteField,required"`
	Int16Field  int16   `json:"int16Field,required"`
	Int32Field  int32   `json:"int32Field,required"`
	Int64Field  int64   `json:"int64Field,required"`
	DoubleField float64 `json:"doubleField,required"`
	StringField string  `json:"stringField,required"`
	BinaryField []byte  `json:"binaryField,required"`
}

// ToWire translates a PrimitiveRequiredStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PrimitiveRequiredStruct) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueBool(v.BoolField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI8(v.ByteField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	w, err = wire.NewValueI16(v.Int16Field), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	w, err = wire.NewValueI32(v.Int32Field), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++

	w, err = wire.NewValueI64(v.Int64Field), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++

	w, err = wire.NewValueDouble(v.DoubleField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 7, Value: w}
	i++
	if v.BinaryField == nil {
		return w, errors.New("field BinaryField of PrimitiveRequiredStruct is required")
	}
	w, err = wire.NewValueBinary(v.BinaryField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 8, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PrimitiveRequiredStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PrimitiveRequiredStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PrimitiveRequiredStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PrimitiveRequiredStruct) FromWire(w wire.Value) error {
	var err error

	boolFieldIsSet := false
	byteFieldIsSet := false
	int16FieldIsSet := false
	int32FieldIsSet := false
	int64FieldIsSet := false
	doubleFieldIsSet := false
	stringFieldIsSet := false
	binaryFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				v.BoolField, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				boolFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI8 {
				v.ByteField, err = field.Value.GetI8(), error(nil)
				if err != nil {
					return err
				}
				byteFieldIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI16 {
				v.Int16Field, err = field.Value.GetI16(), error(nil)
				if err != nil {
					return err
				}
				int16FieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				v.Int32Field, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				int32FieldIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				v.Int64Field, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				int64FieldIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				v.DoubleField, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				doubleFieldIsSet = true
			}
		case 7:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		case 8:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
				binaryFieldIsSet = true
			}
		}
	}

	if !boolFieldIsSet {
		return errors.New("field BoolField of PrimitiveRequiredStruct is required")
	}

	if !byteFieldIsSet {
		return errors.New("field ByteField of PrimitiveRequiredStruct is required")
	}

	if !int16FieldIsSet {
		return errors.New("field Int16Field of PrimitiveRequiredStruct is required")
	}

	if !int32FieldIsSet {
		return errors.New("field Int32Field of PrimitiveRequiredStruct is required")
	}

	if !int64FieldIsSet {
		return errors.New("field Int64Field of PrimitiveRequiredStruct is required")
	}

	if !doubleFieldIsSet {
		return errors.New("field DoubleField of PrimitiveRequiredStruct is required")
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of PrimitiveRequiredStruct is required")
	}

	if !binaryFieldIsSet {
		return errors.New("field BinaryField of PrimitiveRequiredStruct is required")
	}

	return nil
}

// String returns a readable string representation of a PrimitiveRequiredStruct
// struct.
func (v *PrimitiveRequiredStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	fields[i] = fmt.Sprintf("BoolField: %v", v.BoolField)
	i++
	fields[i] = fmt.Sprintf("ByteField: %v", v.ByteField)
	i++
	fields[i] = fmt.Sprintf("Int16Field: %v", v.Int16Field)
	i++
	fields[i] = fmt.Sprintf("Int32Field: %v", v.Int32Field)
	i++
	fields[i] = fmt.Sprintf("Int64Field: %v", v.Int64Field)
	i++
	fields[i] = fmt.Sprintf("DoubleField: %v", v.DoubleField)
	i++
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++
	fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
	i++

	return fmt.Sprintf("PrimitiveRequiredStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this PrimitiveRequiredStruct match the
// provided PrimitiveRequiredStruct.
//
// This function performs a deep comparison.
func (v *PrimitiveRequiredStruct) Equals(rhs *PrimitiveRequiredStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.BoolField == rhs.BoolField) {
		return false
	}
	if !(v.ByteField == rhs.ByteField) {
		return false
	}
	if !(v.Int16Field == rhs.Int16Field) {
		return false
	}
	if !(v.Int32Field == rhs.Int32Field) {
		return false
	}
	if !(v.Int64Field == rhs.Int64Field) {
		return false
	}
	if !(v.DoubleField == rhs.DoubleField) {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}
	if !bytes.Equal(v.BinaryField, rhs.BinaryField) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PrimitiveRequiredStruct.
func (v *PrimitiveRequiredStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddBool("boolField", v.BoolField)
	enc.AddInt8("byteField", v.ByteField)
	enc.AddInt16("int16Field", v.Int16Field)
	enc.AddInt32("int32Field", v.Int32Field)
	enc.AddInt64("int64Field", v.Int64Field)
	enc.AddFloat64("doubleField", v.DoubleField)
	enc.AddString("stringField", v.StringField)
	enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))
	return err
}

// GetBoolField returns the value of BoolField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetBoolField() (o bool) {
	if v != nil {
		o = v.BoolField
	}
	return
}

// GetByteField returns the value of ByteField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetByteField() (o int8) {
	if v != nil {
		o = v.ByteField
	}
	return
}

// GetInt16Field returns the value of Int16Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetInt16Field() (o int16) {
	if v != nil {
		o = v.Int16Field
	}
	return
}

// GetInt32Field returns the value of Int32Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetInt32Field() (o int32) {
	if v != nil {
		o = v.Int32Field
	}
	return
}

// GetInt64Field returns the value of Int64Field if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetInt64Field() (o int64) {
	if v != nil {
		o = v.Int64Field
	}
	return
}

// GetDoubleField returns the value of DoubleField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetDoubleField() (o float64) {
	if v != nil {
		o = v.DoubleField
	}
	return
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetStringField() (o string) {
	if v != nil {
		o = v.StringField
	}
	return
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *PrimitiveRequiredStruct) GetBinaryField() (o []byte) {
	if v != nil {
		o = v.BinaryField
	}
	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *PrimitiveRequiredStruct) IsSetBinaryField() bool {
	return v != nil && v.BinaryField != nil
}

type Rename struct {
	Default   string `json:"default,required"`
	CamelCase string `json:"snake_case,required"`
}

// ToWire translates a Rename struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Rename) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Default), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.CamelCase), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Rename struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Rename struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Rename
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Rename) FromWire(w wire.Value) error {
	var err error

	DefaultIsSet := false
	camelCaseIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Default, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				DefaultIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.CamelCase, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				camelCaseIsSet = true
			}
		}
	}

	if !DefaultIsSet {
		return errors.New("field Default of Rename is required")
	}

	if !camelCaseIsSet {
		return errors.New("field CamelCase of Rename is required")
	}

	return nil
}

// String returns a readable string representation of a Rename
// struct.
func (v *Rename) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Default: %v", v.Default)
	i++
	fields[i] = fmt.Sprintf("CamelCase: %v", v.CamelCase)
	i++

	return fmt.Sprintf("Rename{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Rename match the
// provided Rename.
//
// This function performs a deep comparison.
func (v *Rename) Equals(rhs *Rename) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Default == rhs.Default) {
		return false
	}
	if !(v.CamelCase == rhs.CamelCase) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Rename.
func (v *Rename) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("Default", v.Default)
	enc.AddString("camelCase", v.CamelCase)
	return err
}

// GetDefault returns the value of Default if it is set or its
// zero value if it is unset.
func (v *Rename) GetDefault() (o string) {
	if v != nil {
		o = v.Default
	}
	return
}

// GetCamelCase returns the value of CamelCase if it is set or its
// zero value if it is unset.
func (v *Rename) GetCamelCase() (o string) {
	if v != nil {
		o = v.CamelCase
	}
	return
}

// Size of something.
type Size struct {
	// Width in pixels.
	Width float64 `json:"width,required"`
	// Height in pixels.
	Height float64 `json:"height,required"`
}

// ToWire translates a Size struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Size) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueDouble(v.Width), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueDouble(v.Height), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Size struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Size struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Size
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Size) FromWire(w wire.Value) error {
	var err error

	widthIsSet := false
	heightIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				v.Width, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				widthIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TDouble {
				v.Height, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				heightIsSet = true
			}
		}
	}

	if !widthIsSet {
		return errors.New("field Width of Size is required")
	}

	if !heightIsSet {
		return errors.New("field Height of Size is required")
	}

	return nil
}

// String returns a readable string representation of a Size
// struct.
func (v *Size) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Width: %v", v.Width)
	i++
	fields[i] = fmt.Sprintf("Height: %v", v.Height)
	i++

	return fmt.Sprintf("Size{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Size match the
// provided Size.
//
// This function performs a deep comparison.
func (v *Size) Equals(rhs *Size) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Width == rhs.Width) {
		return false
	}
	if !(v.Height == rhs.Height) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Size.
func (v *Size) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddFloat64("width", v.Width)
	enc.AddFloat64("height", v.Height)
	return err
}

// GetWidth returns the value of Width if it is set or its
// zero value if it is unset.
func (v *Size) GetWidth() (o float64) {
	if v != nil {
		o = v.Width
	}
	return
}

// GetHeight returns the value of Height if it is set or its
// zero value if it is unset.
func (v *Size) GetHeight() (o float64) {
	if v != nil {
		o = v.Height
	}
	return
}

type StructLabels struct {
	IsRequired *bool   `json:"required,omitempty"`
	Foo        *string `json:"not_bar,omitempty"`
	Qux        *string `json:"qux,omitempty"`
	Quux       *string `json:"QUUX,omitempty"`
}

// ToWire translates a StructLabels struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructLabels) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.IsRequired != nil {
		w, err = wire.NewValueBool(*(v.IsRequired)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Foo != nil {
		w, err = wire.NewValueString(*(v.Foo)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Qux != nil {
		w, err = wire.NewValueString(*(v.Qux)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Quux != nil {
		w, err = wire.NewValueString(*(v.Quux)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StructLabels struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructLabels struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructLabels
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructLabels) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.IsRequired = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Foo = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Qux = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Quux = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a StructLabels
// struct.
func (v *StructLabels) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.IsRequired != nil {
		fields[i] = fmt.Sprintf("IsRequired: %v", *(v.IsRequired))
		i++
	}
	if v.Foo != nil {
		fields[i] = fmt.Sprintf("Foo: %v", *(v.Foo))
		i++
	}
	if v.Qux != nil {
		fields[i] = fmt.Sprintf("Qux: %v", *(v.Qux))
		i++
	}
	if v.Quux != nil {
		fields[i] = fmt.Sprintf("Quux: %v", *(v.Quux))
		i++
	}

	return fmt.Sprintf("StructLabels{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructLabels match the
// provided StructLabels.
//
// This function performs a deep comparison.
func (v *StructLabels) Equals(rhs *StructLabels) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.IsRequired, rhs.IsRequired) {
		return false
	}
	if !_String_EqualsPtr(v.Foo, rhs.Foo) {
		return false
	}
	if !_String_EqualsPtr(v.Qux, rhs.Qux) {
		return false
	}
	if !_String_EqualsPtr(v.Quux, rhs.Quux) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StructLabels.
func (v *StructLabels) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.IsRequired != nil {
		enc.AddBool("required", *v.IsRequired)
	}
	if v.Foo != nil {
		enc.AddString("bar", *v.Foo)
	}
	if v.Qux != nil {
		enc.AddString("qux", *v.Qux)
	}
	if v.Quux != nil {
		enc.AddString("QUUX", *v.Quux)
	}
	return err
}

// GetIsRequired returns the value of IsRequired if it is set or its
// zero value if it is unset.
func (v *StructLabels) GetIsRequired() (o bool) {
	if v != nil && v.IsRequired != nil {
		return *v.IsRequired
	}

	return
}

// IsSetIsRequired returns true if IsRequired is not nil.
func (v *StructLabels) IsSetIsRequired() bool {
	return v != nil && v.IsRequired != nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *StructLabels) GetFoo() (o string) {
	if v != nil && v.Foo != nil {
		return *v.Foo
	}

	return
}

// IsSetFoo returns true if Foo is not nil.
func (v *StructLabels) IsSetFoo() bool {
	return v != nil && v.Foo != nil
}

// GetQux returns the value of Qux if it is set or its
// zero value if it is unset.
func (v *StructLabels) GetQux() (o string) {
	if v != nil && v.Qux != nil {
		return *v.Qux
	}

	return
}

// IsSetQux returns true if Qux is not nil.
func (v *StructLabels) IsSetQux() bool {
	return v != nil && v.Qux != nil
}

// GetQuux returns the value of Quux if it is set or its
// zero value if it is unset.
func (v *StructLabels) GetQuux() (o string) {
	if v != nil && v.Quux != nil {
		return *v.Quux
	}

	return
}

// IsSetQuux returns true if Quux is not nil.
func (v *StructLabels) IsSetQuux() bool {
	return v != nil && v.Quux != nil
}

type User struct {
	Name     string        `json:"name,required"`
	Contact  *ContactInfo  `json:"contact,omitempty"`
	Personal *PersonalInfo `json:"personal,omitempty"`
}

// ToWire translates a User struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *User) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Contact != nil {
		w, err = v.Contact.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Personal != nil {
		w, err = v.Personal.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ContactInfo_Read(w wire.Value) (*ContactInfo, error) {
	var v ContactInfo
	err := v.FromWire(w)
	return &v, err
}

func _PersonalInfo_Read(w wire.Value) (*PersonalInfo, error) {
	var v PersonalInfo
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a User struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a User struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v User
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *User) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Contact, err = _ContactInfo_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Personal, err = _PersonalInfo_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of User is required")
	}

	return nil
}

// String returns a readable string representation of a User
// struct.
func (v *User) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.Contact != nil {
		fields[i] = fmt.Sprintf("Contact: %v", v.Contact)
		i++
	}
	if v.Personal != nil {
		fields[i] = fmt.Sprintf("Personal: %v", v.Personal)
		i++
	}

	return fmt.Sprintf("User{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this User match the
// provided User.
//
// This function performs a deep comparison.
func (v *User) Equals(rhs *User) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !((v.Contact == nil && rhs.Contact == nil) || (v.Contact != nil && rhs.Contact != nil && v.Contact.Equals(rhs.Contact))) {
		return false
	}
	if !((v.Personal == nil && rhs.Personal == nil) || (v.Personal != nil && rhs.Personal != nil && v.Personal.Equals(rhs.Personal))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of User.
func (v *User) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.Contact != nil {
		err = multierr.Append(err, enc.AddObject("contact", v.Contact))
	}
	if v.Personal != nil {
		err = multierr.Append(err, enc.AddObject("personal", v.Personal))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *User) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetContact returns the value of Contact if it is set or its
// zero value if it is unset.
func (v *User) GetContact() (o *ContactInfo) {
	if v != nil && v.Contact != nil {
		return v.Contact
	}

	return
}

// IsSetContact returns true if Contact is not nil.
func (v *User) IsSetContact() bool {
	return v != nil && v.Contact != nil
}

// GetPersonal returns the value of Personal if it is set or its
// zero value if it is unset.
func (v *User) GetPersonal() (o *PersonalInfo) {
	if v != nil && v.Personal != nil {
		return v.Personal
	}

	return
}

// IsSetPersonal returns true if Personal is not nil.
func (v *User) IsSetPersonal() bool {
	return v != nil && v.Personal != nil
}

type _Map_String_User_MapItemList map[string]*User

func (m _Map_String_User_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_User_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_User_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_User_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_User_MapItemList) Close() {}

func _User_Read(w wire.Value) (*User, error) {
	var v User
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_User_Read(m wire.MapItemList) (map[string]*User, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*User, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _User_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_User_Equals(lhs, rhs map[string]*User) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

type _Map_String_User_Zapper map[string]*User

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_User_Zapper.
func (m _Map_String_User_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

type UserMap map[string]*User

// ToWire translates UserMap into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UserMap) ToWire() (wire.Value, error) {
	x := (map[string]*User)(v)
	return wire.NewValueMap(_Map_String_User_MapItemList(x)), error(nil)
}

// String returns a readable string representation of UserMap.
func (v UserMap) String() string {
	x := (map[string]*User)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UserMap from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UserMap) FromWire(w wire.Value) error {
	x, err := _Map_String_User_Read(w.GetMap())
	*v = (UserMap)(x)
	return err
}

// Equals returns true if this UserMap is equal to the provided
// UserMap.
func (lhs UserMap) Equals(rhs UserMap) bool {
	return _Map_String_User_Equals((map[string]*User)(lhs), (map[string]*User)(rhs))
}

func (v UserMap) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((_Map_String_User_Zapper)((map[string]*User)(v))).MarshalLogObject(enc)
}

type ZapOptOutStruct struct {
	Name   string `json:"name,required"`
	Optout string `json:"optout,required"`
}

// ToWire translates a ZapOptOutStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ZapOptOutStruct) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.Optout), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ZapOptOutStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ZapOptOutStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ZapOptOutStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ZapOptOutStruct) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false
	optoutIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Optout, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				optoutIsSet = true
			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of ZapOptOutStruct is required")
	}

	if !optoutIsSet {
		return errors.New("field Optout of ZapOptOutStruct is required")
	}

	return nil
}

// String returns a readable string representation of a ZapOptOutStruct
// struct.
func (v *ZapOptOutStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("Optout: %v", v.Optout)
	i++

	return fmt.Sprintf("ZapOptOutStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ZapOptOutStruct match the
// provided ZapOptOutStruct.
//
// This function performs a deep comparison.
func (v *ZapOptOutStruct) Equals(rhs *ZapOptOutStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.Optout == rhs.Optout) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ZapOptOutStruct.
func (v *ZapOptOutStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)

	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *ZapOptOutStruct) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetOptout returns the value of Optout if it is set or its
// zero value if it is unset.
func (v *ZapOptOutStruct) GetOptout() (o string) {
	if v != nil {
		o = v.Optout
	}
	return
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "structs",
	Package:  "go.uber.org/thriftrw/gen/internal/tests/structs",
	FilePath: "structs.thrift",
	SHA1:     "dab5c0bea66d50915769e8c6c2f125dc93b16738",
	Includes: []*thriftreflect.ThriftModule{
		enums.ThriftModule,
	},
	Raw: rawIDL,
}

const rawIDL = "include \"./enums.thrift\"\n\nstruct EmptyStruct {}\n\n//////////////////////////////////////////////////////////////////////////////\n// Structs with primitives\n\n/**\n * A struct that contains primitive fields exclusively.\n *\n * All fields are required.\n */\nstruct PrimitiveRequiredStruct {\n    1: required bool boolField\n    2: required byte byteField\n    3: required i16 int16Field\n    4: required i32 int32Field\n    5: required i64 int64Field\n    6: required double doubleField\n    7: required string stringField\n    8: required binary binaryField\n}\n\n/**\n * A struct that contains primitive fields exclusively.\n *\n * All fields are optional.\n */\nstruct PrimitiveOptionalStruct {\n    1: optional bool boolField\n    2: optional byte byteField\n    3: optional i16 int16Field\n    4: optional i32 int32Field\n    5: optional i64 int64Field\n    6: optional double doubleField\n    7: optional string stringField\n    8: optional binary binaryField\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Nested structs (Required)\n\n/**\n * A point in 2D space.\n */\nstruct Point {\n    1: required double x\n    2: required double y\n}\n\n/**\n * Size of something.\n */\nstruct Size {\n    /**\n     * Width in pixels.\n     */\n    1: required double width\n    /** Height in pixels. */\n    2: required double height\n}\n\nstruct Frame {\n    1: required Point topLeft\n    2: required Size size\n}\n\nstruct Edge {\n    1: required Point startPoint\n    2: required Point endPoint\n}\n\n/**\n * A graph is comprised of zero or more edges.\n */\nstruct Graph {\n    /**\n     * List of edges in the graph.\n     *\n     * May be empty.\n     */\n    1: required list<Edge> edges\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Nested structs (Optional)\n\nstruct ContactInfo {\n    1: required string emailAddress\n}\n\nstruct PersonalInfo {\n    1: optional i32 age\n}\n\nstruct User {\n    1: required string name\n    2: optional ContactInfo contact\n    3: optional PersonalInfo personal\n}\n\ntypedef map<string, User> UserMap\n\n//////////////////////////////////////////////////////////////////////////////\n// self-referential struct\n\ntypedef Node List\n\n/**\n * Node is linked list of values.\n * All values are 32-bit integers.\n */\nstruct Node {\n    1: required i32 value\n    2: optional List tail\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// JSON tagged structs\n\nstruct Rename {\n    1: required string Default (go.tag = 'json:\"default\"')\n    2: required string camelCase (go.tag = 'json:\"snake_case\"')\n}\n\nstruct Omit {\n    1: required string serialized\n    2: required string hidden (go.tag = 'json:\"-\"')\n}\n\nstruct GoTags {\n        1: required string Foo (go.tag = 'json:\"-\" foo:\"bar\"')\n        2: optional string Bar (go.tag = 'bar:\"foo\"')\n        3: required string FooBar (go.tag = 'json:\"foobar,option1,option2\" bar:\"foo,option1\" foo:\"foobar\"')\n        4: required string FooBarWithSpace (go.tag = 'json:\"foobarWithSpace\" foo:\"foo bar foobar barfoo\"')\n        5: optional string FooBarWithOmitEmpty (go.tag = 'json:\"foobarWithOmitEmpty,omitempty\"')\n        6: required string FooBarWithRequired (go.tag = 'json:\"foobarWithRequired,required\"')\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Default values\n\nstruct DefaultsStruct {\n    1: required i32 requiredPrimitive = 100\n    2: optional i32 optionalPrimitive = 200\n\n    3: required enums.EnumDefault requiredEnum = enums.EnumDefault.Bar\n    4: optional enums.EnumDefault optionalEnum = 2\n\n    5: required list<string> requiredList = [\"hello\", \"world\"]\n    6: optional list<double> optionalList = [1, 2.0, 3]\n\n    7: required Frame requiredStruct = {\n        \"topLeft\": {\"x\": 1, \"y\": 2},\n        \"size\": {\"width\": 100, \"height\": 200},\n    }\n    8: optional Edge optionalStruct = {\n        \"startPoint\": {\"x\": 1, \"y\": 2},\n        \"endPoint\":   {\"x\": 3, \"y\": 4},\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Opt-out of Zap\n\nstruct ZapOptOutStruct {\n    1: required string name\n    2: required string optout (go.nolog)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Field jabels\n\nstruct StructLabels {\n    // reserved keyword as label\n    1: optional bool isRequired (go.label = \"required\")\n\n    // go.tag's JSON tag takes precedence over go.label\n    2: optional string foo (go.label = \"bar\", go.tag = 'json:\"not_bar\"')\n\n    // Empty label\n    3: optional string qux (go.label = \"\")\n\n    // All-caps label\n    4: optional string quux (go.label = \"QUUX\")\n}\n"
