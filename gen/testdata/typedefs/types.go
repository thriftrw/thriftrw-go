// Code generated by thriftrw

package typedefs

import (
	"fmt"
	"github.com/thriftrw/thriftrw-go/gen/testdata/structs"
	"github.com/thriftrw/thriftrw-go/wire"
	"strings"
)

type Event struct {
	UUID *UUID      `json:"uuid"`
	Time *Timestamp `json:"time,omitempty"`
}

func (v *Event) ToWire() wire.Value {
	var fields [2]wire.Field
	i := 0
	fields[i] = wire.Field{ID: 1, Value: v.UUID.ToWire()}
	i++
	if v.Time != nil {
		fields[i] = wire.Field{ID: 2, Value: v.Time.ToWire()}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]})
}

func _UUID_Read(w wire.Value) (*UUID, error) {
	var x UUID
	err := x.FromWire(w)
	return &x, err
}

func _Timestamp_Read(w wire.Value) (Timestamp, error) {
	var x Timestamp
	err := x.FromWire(w)
	return x, err
}

func (v *Event) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.UUID, err = _UUID_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x Timestamp
				x, err = _Timestamp_Read(field.Value)
				v.Time = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Event) String() string {
	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("UUID: %v", v.UUID)
	i++
	if v.Time != nil {
		fields[i] = fmt.Sprintf("Time: %v", *(v.Time))
		i++
	}
	return fmt.Sprintf("Event{%v}", strings.Join(fields[:i], ", "))
}

type _List_Event_ValueList []*Event

func (v _List_Event_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(x.ToWire())
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Event_ValueList) Close() {
}

func _Event_Read(w wire.Value) (*Event, error) {
	var v Event
	err := v.FromWire(w)
	return &v, err
}

func _List_Event_Read(l wire.List) ([]*Event, error) {
	if l.ValueType != wire.TStruct {
		return nil, nil
	}
	o := make([]*Event, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := _Event_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}

type EventGroup []*Event

func (v EventGroup) ToWire() wire.Value {
	x := ([]*Event)(v)
	return wire.NewValueList(wire.List{ValueType: wire.TStruct, Size: len(x), Items: _List_Event_ValueList(x)})
}

func (v EventGroup) String() string {
	x := ([]*Event)(v)
	return fmt.Sprint(x)
}

func (v *EventGroup) FromWire(w wire.Value) error {
	x, err := _List_Event_Read(w.GetList())
	*v = (EventGroup)(x)
	return err
}

type _Set_Frame_ValueList []*structs.Frame

func (v _Set_Frame_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(x.ToWire())
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Frame_ValueList) Close() {
}

func _Frame_Read(w wire.Value) (*structs.Frame, error) {
	var v structs.Frame
	err := v.FromWire(w)
	return &v, err
}

func _Set_Frame_Read(s wire.Set) ([]*structs.Frame, error) {
	if s.ValueType != wire.TStruct {
		return nil, nil
	}
	o := make([]*structs.Frame, 0, s.Size)
	err := s.Items.ForEach(func(x wire.Value) error {
		i, err := _Frame_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	s.Items.Close()
	return o, err
}

type FrameGroup []*structs.Frame

func (v FrameGroup) ToWire() wire.Value {
	x := ([]*structs.Frame)(v)
	return wire.NewValueSet(wire.Set{ValueType: wire.TStruct, Size: len(x), Items: _Set_Frame_ValueList(x)})
}

func (v FrameGroup) String() string {
	x := ([]*structs.Frame)(v)
	return fmt.Sprint(x)
}

func (v *FrameGroup) FromWire(w wire.Value) error {
	x, err := _Set_Frame_Read(w.GetSet())
	*v = (FrameGroup)(x)
	return err
}

type Pdf []byte

func (v Pdf) ToWire() wire.Value {
	x := ([]byte)(v)
	return wire.NewValueBinary(x)
}

func (v Pdf) String() string {
	x := ([]byte)(v)
	return fmt.Sprint(x)
}

func (v *Pdf) FromWire(w wire.Value) error {
	x, err := w.GetBinary(), error(nil)
	*v = (Pdf)(x)
	return err
}

type _Map_Point_Point_MapItemList []struct {
	Key   *structs.Point
	Value *structs.Point
}

func (m _Map_Point_Point_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err := f(wire.MapItem{Key: k.ToWire(), Value: v.ToWire()})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Point_Point_MapItemList) Close() {
}

func _Point_Read(w wire.Value) (*structs.Point, error) {
	var v structs.Point
	err := v.FromWire(w)
	return &v, err
}

func _Map_Point_Point_Read(m wire.Map) ([]struct {
	Key   *structs.Point
	Value *structs.Point
}, error) {
	if m.KeyType != wire.TStruct {
		return nil, nil
	}
	if m.ValueType != wire.TStruct {
		return nil, nil
	}
	o := make([]struct {
		Key   *structs.Point
		Value *structs.Point
	}, 0, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		k, err := _Point_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Point_Read(x.Value)
		if err != nil {
			return err
		}
		o = append(o, struct {
			Key   *structs.Point
			Value *structs.Point
		}{k, v})
		return nil
	})
	m.Items.Close()
	return o, err
}

type PointMap []struct {
	Key   *structs.Point
	Value *structs.Point
}

func (v PointMap) ToWire() wire.Value {
	x := ([]struct {
		Key   *structs.Point
		Value *structs.Point
	})(v)
	return wire.NewValueMap(wire.Map{KeyType: wire.TStruct, ValueType: wire.TStruct, Size: len(x), Items: _Map_Point_Point_MapItemList(x)})
}

func (v PointMap) String() string {
	x := ([]struct {
		Key   *structs.Point
		Value *structs.Point
	})(v)
	return fmt.Sprint(x)
}

func (v *PointMap) FromWire(w wire.Value) error {
	x, err := _Map_Point_Point_Read(w.GetMap())
	*v = (PointMap)(x)
	return err
}

type State string

func (v State) ToWire() wire.Value {
	x := (string)(v)
	return wire.NewValueString(x)
}

func (v State) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

func (v *State) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (State)(x)
	return err
}

type Timestamp int64

func (v Timestamp) ToWire() wire.Value {
	x := (int64)(v)
	return wire.NewValueI64(x)
}

func (v Timestamp) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

func (v *Timestamp) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (Timestamp)(x)
	return err
}

type Transition struct {
	From   State      `json:"from"`
	To     State      `json:"to"`
	Events EventGroup `json:"events"`
}

func (v *Transition) ToWire() wire.Value {
	var fields [3]wire.Field
	i := 0
	fields[i] = wire.Field{ID: 1, Value: v.From.ToWire()}
	i++
	fields[i] = wire.Field{ID: 2, Value: v.To.ToWire()}
	i++
	if v.Events != nil {
		fields[i] = wire.Field{ID: 3, Value: v.Events.ToWire()}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]})
}

func _State_Read(w wire.Value) (State, error) {
	var x State
	err := x.FromWire(w)
	return x, err
}

func _EventGroup_Read(w wire.Value) (EventGroup, error) {
	var x EventGroup
	err := x.FromWire(w)
	return x, err
}

func (v *Transition) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.From, err = _State_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.To, err = _State_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Events, err = _EventGroup_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Transition) String() string {
	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("From: %v", v.From)
	i++
	fields[i] = fmt.Sprintf("To: %v", v.To)
	i++
	if v.Events != nil {
		fields[i] = fmt.Sprintf("Events: %v", v.Events)
		i++
	}
	return fmt.Sprintf("Transition{%v}", strings.Join(fields[:i], ", "))
}

type UUID I128

func (v *UUID) ToWire() wire.Value {
	x := (*I128)(v)
	return x.ToWire()
}

func (v *UUID) String() string {
	x := (*I128)(v)
	return fmt.Sprint(x)
}

func (v *UUID) FromWire(w wire.Value) error {
	return (*I128)(v).FromWire(w)
}

type I128 struct {
	High int64 `json:"high"`
	Low  int64 `json:"low"`
}

func (v *I128) ToWire() wire.Value {
	var fields [2]wire.Field
	i := 0
	fields[i] = wire.Field{ID: 1, Value: wire.NewValueI64(v.High)}
	i++
	fields[i] = wire.Field{ID: 2, Value: wire.NewValueI64(v.Low)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]})
}

func (v *I128) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				v.High, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				v.Low, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *I128) String() string {
	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("High: %v", v.High)
	i++
	fields[i] = fmt.Sprintf("Low: %v", v.Low)
	i++
	return fmt.Sprintf("I128{%v}", strings.Join(fields[:i], ", "))
}
