// Code generated by thriftrw v1.1.0
// @generated

// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package newapi

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go.uber.org/thriftrw/wire"
	"math"
	"strconv"
	"strings"
)

type Argument struct {
	Tag  *int16  `json:"tag,omitempty"`
	Name *string `json:"name,omitempty"`
	Type *Type   `json:"type,omitempty"`
}

func (v *Argument) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Tag != nil {
		w, err = wire.NewValueI16(*(v.Tag)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Type_Read(w wire.Value) (*Type, error) {
	var v Type
	err := v.FromWire(w)
	return &v, err
}

func (v *Argument) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Tag = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Type, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Argument) String() string {
	var fields [3]string
	i := 0
	if v.Tag != nil {
		fields[i] = fmt.Sprintf("Tag: %v", *(v.Tag))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", v.Type)
		i++
	}
	return fmt.Sprintf("Argument{%v}", strings.Join(fields[:i], ", "))
}

type Const struct {
	ID          *ID               `json:"id,omitempty"`
	ModuleID    *ID               `json:"module_id,omitempty"`
	Type        *Type             `json:"type,omitempty"`
	Name        *string           `json:"name,omitempty"`
	Value       *string           `json:"value,omitempty"`
	Annotations map[string]string `json:"annotations"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {
}

func (v *Const) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ID != nil {
		w, err = v.ID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ModuleID != nil {
		w, err = v.ModuleID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = wire.NewValueString(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ID_Read(w wire.Value) (ID, error) {
	var x ID
	err := x.FromWire(w)
	return x, err
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *Const) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ModuleID = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Type, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Const) String() string {
	var fields [6]string
	i := 0
	if v.ID != nil {
		fields[i] = fmt.Sprintf("ID: %v", *(v.ID))
		i++
	}
	if v.ModuleID != nil {
		fields[i] = fmt.Sprintf("ModuleID: %v", *(v.ModuleID))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", v.Type)
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("Const{%v}", strings.Join(fields[:i], ", "))
}

type Definition struct {
	Modules  map[ID]*Module  `json:"modules"`
	Consts   map[ID]*Const   `json:"consts"`
	Typedefs map[ID]*Typedef `json:"typedefs"`
	Enums    map[ID]*Enum    `json:"enums"`
	Structs  map[ID]*Struct  `json:"structs"`
	Services map[ID]*Service `json:"services"`
}

type _Map_ID_Module_MapItemList map[ID]*Module

func (m _Map_ID_Module_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Module_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Module_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Module_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ID_Module_MapItemList) Close() {
}

type _Map_ID_Const_MapItemList map[ID]*Const

func (m _Map_ID_Const_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Const_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Const_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Const_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ID_Const_MapItemList) Close() {
}

type _Map_ID_Typedef_MapItemList map[ID]*Typedef

func (m _Map_ID_Typedef_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Typedef_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Typedef_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Typedef_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ID_Typedef_MapItemList) Close() {
}

type _Map_ID_Enum_MapItemList map[ID]*Enum

func (m _Map_ID_Enum_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Enum_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Enum_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Enum_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ID_Enum_MapItemList) Close() {
}

type _Map_ID_Struct_MapItemList map[ID]*Struct

func (m _Map_ID_Struct_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Struct_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Struct_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Struct_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ID_Struct_MapItemList) Close() {
}

type _Map_ID_Service_MapItemList map[ID]*Service

func (m _Map_ID_Service_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Service_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Service_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Service_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ID_Service_MapItemList) Close() {
}

func (v *Definition) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Modules != nil {
		w, err = wire.NewValueMap(_Map_ID_Module_MapItemList(v.Modules)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Consts != nil {
		w, err = wire.NewValueMap(_Map_ID_Const_MapItemList(v.Consts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Typedefs != nil {
		w, err = wire.NewValueMap(_Map_ID_Typedef_MapItemList(v.Typedefs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Enums != nil {
		w, err = wire.NewValueMap(_Map_ID_Enum_MapItemList(v.Enums)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Structs != nil {
		w, err = wire.NewValueMap(_Map_ID_Struct_MapItemList(v.Structs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Services != nil {
		w, err = wire.NewValueMap(_Map_ID_Service_MapItemList(v.Services)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Module_Read(w wire.Value) (*Module, error) {
	var v Module
	err := v.FromWire(w)
	return &v, err
}

func _Map_ID_Module_Read(m wire.MapItemList) (map[ID]*Module, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[ID]*Module, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Module_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Const_Read(w wire.Value) (*Const, error) {
	var v Const
	err := v.FromWire(w)
	return &v, err
}

func _Map_ID_Const_Read(m wire.MapItemList) (map[ID]*Const, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[ID]*Const, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Const_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Typedef_Read(w wire.Value) (*Typedef, error) {
	var v Typedef
	err := v.FromWire(w)
	return &v, err
}

func _Map_ID_Typedef_Read(m wire.MapItemList) (map[ID]*Typedef, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[ID]*Typedef, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Typedef_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Enum_Read(w wire.Value) (*Enum, error) {
	var v Enum
	err := v.FromWire(w)
	return &v, err
}

func _Map_ID_Enum_Read(m wire.MapItemList) (map[ID]*Enum, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[ID]*Enum, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Enum_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Struct_Read(w wire.Value) (*Struct, error) {
	var v Struct
	err := v.FromWire(w)
	return &v, err
}

func _Map_ID_Struct_Read(m wire.MapItemList) (map[ID]*Struct, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[ID]*Struct, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Struct_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Service_Read(w wire.Value) (*Service, error) {
	var v Service
	err := v.FromWire(w)
	return &v, err
}

func _Map_ID_Service_Read(m wire.MapItemList) (map[ID]*Service, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[ID]*Service, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Service_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *Definition) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Modules, err = _Map_ID_Module_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.Consts, err = _Map_ID_Const_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.Typedefs, err = _Map_ID_Typedef_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.Enums, err = _Map_ID_Enum_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.Structs, err = _Map_ID_Struct_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TMap {
				v.Services, err = _Map_ID_Service_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Definition) String() string {
	var fields [6]string
	i := 0
	if v.Modules != nil {
		fields[i] = fmt.Sprintf("Modules: %v", v.Modules)
		i++
	}
	if v.Consts != nil {
		fields[i] = fmt.Sprintf("Consts: %v", v.Consts)
		i++
	}
	if v.Typedefs != nil {
		fields[i] = fmt.Sprintf("Typedefs: %v", v.Typedefs)
		i++
	}
	if v.Enums != nil {
		fields[i] = fmt.Sprintf("Enums: %v", v.Enums)
		i++
	}
	if v.Structs != nil {
		fields[i] = fmt.Sprintf("Structs: %v", v.Structs)
		i++
	}
	if v.Services != nil {
		fields[i] = fmt.Sprintf("Services: %v", v.Services)
		i++
	}
	return fmt.Sprintf("Definition{%v}", strings.Join(fields[:i], ", "))
}

type Enum struct {
	ID              *ID                 `json:"id,omitempty"`
	ModuleID        *ID                 `json:"module_id,omitempty"`
	Name            *string             `json:"name,omitempty"`
	ValueToEnumItem map[int32]*EnumItem `json:"value_to_enum_item"`
	Annotations     map[string]string   `json:"annotations"`
}

type _Map_I32_EnumItem_MapItemList map[int32]*EnumItem

func (m _Map_I32_EnumItem_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_EnumItem_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_EnumItem_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_EnumItem_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_I32_EnumItem_MapItemList) Close() {
}

func (v *Enum) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ID != nil {
		w, err = v.ID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ModuleID != nil {
		w, err = v.ModuleID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.ValueToEnumItem != nil {
		w, err = wire.NewValueMap(_Map_I32_EnumItem_MapItemList(v.ValueToEnumItem)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EnumItem_Read(w wire.Value) (*EnumItem, error) {
	var v EnumItem
	err := v.FromWire(w)
	return &v, err
}

func _Map_I32_EnumItem_Read(m wire.MapItemList) (map[int32]*EnumItem, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[int32]*EnumItem, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}
		v, err := _EnumItem_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *Enum) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ModuleID = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.ValueToEnumItem, err = _Map_I32_EnumItem_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Enum) String() string {
	var fields [5]string
	i := 0
	if v.ID != nil {
		fields[i] = fmt.Sprintf("ID: %v", *(v.ID))
		i++
	}
	if v.ModuleID != nil {
		fields[i] = fmt.Sprintf("ModuleID: %v", *(v.ModuleID))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.ValueToEnumItem != nil {
		fields[i] = fmt.Sprintf("ValueToEnumItem: %v", v.ValueToEnumItem)
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("Enum{%v}", strings.Join(fields[:i], ", "))
}

type EnumItem struct {
	Value       *int32            `json:"value,omitempty"`
	Name        *string           `json:"name,omitempty"`
	Annotations map[string]string `json:"annotations"`
}

func (v *EnumItem) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Value != nil {
		w, err = wire.NewValueI32(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *EnumItem) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *EnumItem) String() string {
	var fields [3]string
	i := 0
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("EnumItem{%v}", strings.Join(fields[:i], ", "))
}

type Field struct {
	Tag         *int16            `json:"tag,omitempty"`
	Name        *string           `json:"name,omitempty"`
	Type        *Type             `json:"type,omitempty"`
	IsRequired  *bool             `json:"isRequired,omitempty"`
	Annotations map[string]string `json:"annotations"`
}

func (v *Field) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Tag != nil {
		w, err = wire.NewValueI16(*(v.Tag)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.IsRequired != nil {
		w, err = wire.NewValueBool(*(v.IsRequired)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Field) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Tag = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Type, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.IsRequired = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Field) String() string {
	var fields [5]string
	i := 0
	if v.Tag != nil {
		fields[i] = fmt.Sprintf("Tag: %v", *(v.Tag))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", v.Type)
		i++
	}
	if v.IsRequired != nil {
		fields[i] = fmt.Sprintf("IsRequired: %v", *(v.IsRequired))
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("Field{%v}", strings.Join(fields[:i], ", "))
}

type Function struct {
	Name           *string             `json:"name,omitempty"`
	TagToArgument  map[int16]*Argument `json:"tag_to_argument"`
	ResponseType   *Type               `json:"response_type,omitempty"`
	TagToException map[int16]*Argument `json:"tag_to_exception"`
	IsOneway       *bool               `json:"isOneway,omitempty"`
	Annotations    map[string]string   `json:"annotations"`
}

type _Map_I16_Argument_MapItemList map[int16]*Argument

func (m _Map_I16_Argument_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI16(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I16_Argument_MapItemList) Size() int {
	return len(m)
}

func (_Map_I16_Argument_MapItemList) KeyType() wire.Type {
	return wire.TI16
}

func (_Map_I16_Argument_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_I16_Argument_MapItemList) Close() {
}

func (v *Function) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.TagToArgument != nil {
		w, err = wire.NewValueMap(_Map_I16_Argument_MapItemList(v.TagToArgument)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ResponseType != nil {
		w, err = v.ResponseType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.TagToException != nil {
		w, err = wire.NewValueMap(_Map_I16_Argument_MapItemList(v.TagToException)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.IsOneway != nil {
		w, err = wire.NewValueBool(*(v.IsOneway)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Argument_Read(w wire.Value) (*Argument, error) {
	var v Argument
	err := v.FromWire(w)
	return &v, err
}

func _Map_I16_Argument_Read(m wire.MapItemList) (map[int16]*Argument, error) {
	if m.KeyType() != wire.TI16 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[int16]*Argument, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI16(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Argument_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *Function) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.TagToArgument, err = _Map_I16_Argument_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.ResponseType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.TagToException, err = _Map_I16_Argument_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.IsOneway = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Function) String() string {
	var fields [6]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.TagToArgument != nil {
		fields[i] = fmt.Sprintf("TagToArgument: %v", v.TagToArgument)
		i++
	}
	if v.ResponseType != nil {
		fields[i] = fmt.Sprintf("ResponseType: %v", v.ResponseType)
		i++
	}
	if v.TagToException != nil {
		fields[i] = fmt.Sprintf("TagToException: %v", v.TagToException)
		i++
	}
	if v.IsOneway != nil {
		fields[i] = fmt.Sprintf("IsOneway: %v", *(v.IsOneway))
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("Function{%v}", strings.Join(fields[:i], ", "))
}

type GenerateRequest struct {
	ModuleID          *ID         `json:"module_id,omitempty"`
	OutDirPath        *string     `json:"out_dir_path,omitempty"`
	ThriftRootDirPath *string     `json:"thrift_root_dir_path,omitempty"`
	GoPkgPrefix       *string     `json:"go_pkg_prefix,omitempty"`
	NoRecurse         *bool       `json:"no_recurse,omitempty"`
	Definition        *Definition `json:"definition,omitempty"`
}

func (v *GenerateRequest) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ModuleID != nil {
		w, err = v.ModuleID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.OutDirPath != nil {
		w, err = wire.NewValueString(*(v.OutDirPath)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ThriftRootDirPath != nil {
		w, err = wire.NewValueString(*(v.ThriftRootDirPath)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.GoPkgPrefix != nil {
		w, err = wire.NewValueString(*(v.GoPkgPrefix)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.NoRecurse != nil {
		w, err = wire.NewValueBool(*(v.NoRecurse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Definition != nil {
		w, err = v.Definition.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Definition_Read(w wire.Value) (*Definition, error) {
	var v Definition
	err := v.FromWire(w)
	return &v, err
}

func (v *GenerateRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ModuleID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OutDirPath = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ThriftRootDirPath = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.GoPkgPrefix = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.NoRecurse = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TStruct {
				v.Definition, err = _Definition_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *GenerateRequest) String() string {
	var fields [6]string
	i := 0
	if v.ModuleID != nil {
		fields[i] = fmt.Sprintf("ModuleID: %v", *(v.ModuleID))
		i++
	}
	if v.OutDirPath != nil {
		fields[i] = fmt.Sprintf("OutDirPath: %v", *(v.OutDirPath))
		i++
	}
	if v.ThriftRootDirPath != nil {
		fields[i] = fmt.Sprintf("ThriftRootDirPath: %v", *(v.ThriftRootDirPath))
		i++
	}
	if v.GoPkgPrefix != nil {
		fields[i] = fmt.Sprintf("GoPkgPrefix: %v", *(v.GoPkgPrefix))
		i++
	}
	if v.NoRecurse != nil {
		fields[i] = fmt.Sprintf("NoRecurse: %v", *(v.NoRecurse))
		i++
	}
	if v.Definition != nil {
		fields[i] = fmt.Sprintf("Definition: %v", v.Definition)
		i++
	}
	return fmt.Sprintf("GenerateRequest{%v}", strings.Join(fields[:i], ", "))
}

type GenerateResponse struct {
	FilePathToFile map[string][]byte `json:"file_path_to_file"`
}

type _Map_String_Binary_MapItemList map[string][]byte

func (m _Map_String_Binary_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueBinary(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Binary_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Binary_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) Close() {
}

func (v *GenerateResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.FilePathToFile != nil {
		w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.FilePathToFile)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_Binary_Read(m wire.MapItemList) (map[string][]byte, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make(map[string][]byte, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetBinary(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *GenerateResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.FilePathToFile, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *GenerateResponse) String() string {
	var fields [1]string
	i := 0
	if v.FilePathToFile != nil {
		fields[i] = fmt.Sprintf("FilePathToFile: %v", v.FilePathToFile)
		i++
	}
	return fmt.Sprintf("GenerateResponse{%v}", strings.Join(fields[:i], ", "))
}

type GoStructTaggerRequest struct {
	ModuleID   *ID         `json:"module_id,omitempty"`
	Definition *Definition `json:"definition,omitempty"`
}

func (v *GoStructTaggerRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ModuleID != nil {
		w, err = v.ModuleID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Definition != nil {
		w, err = v.Definition.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *GoStructTaggerRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ModuleID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Definition, err = _Definition_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *GoStructTaggerRequest) String() string {
	var fields [2]string
	i := 0
	if v.ModuleID != nil {
		fields[i] = fmt.Sprintf("ModuleID: %v", *(v.ModuleID))
		i++
	}
	if v.Definition != nil {
		fields[i] = fmt.Sprintf("Definition: %v", v.Definition)
		i++
	}
	return fmt.Sprintf("GoStructTaggerRequest{%v}", strings.Join(fields[:i], ", "))
}

type GoStructTaggerResponse struct {
	StructIDToFieldTagToRemoveKeys    map[ID]map[int16]map[string]struct{} `json:"struct_id_to_field_tag_to_remove_keys"`
	StructIDToFieldTagToAddKeyToValue map[ID]map[int16]map[string]string   `json:"struct_id_to_field_tag_to_add_key_to_value"`
}

type _Set_String_ValueList map[string]struct{}

func (v _Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_ValueList) Size() int {
	return len(v)
}

func (_Set_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_ValueList) Close() {
}

type _Map_I16_Set_String_MapItemList map[int16]map[string]struct{}

func (m _Map_I16_Set_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI16(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueSet(_Set_String_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I16_Set_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I16_Set_String_MapItemList) KeyType() wire.Type {
	return wire.TI16
}

func (_Map_I16_Set_String_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I16_Set_String_MapItemList) Close() {
}

type _Map_ID_Map_I16_Set_String_MapItemList map[ID]map[int16]map[string]struct{}

func (m _Map_ID_Map_I16_Set_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := wire.NewValueMap(_Map_I16_Set_String_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Map_I16_Set_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Map_I16_Set_String_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Map_I16_Set_String_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_ID_Map_I16_Set_String_MapItemList) Close() {
}

type _Map_I16_Map_String_String_MapItemList map[int16]map[string]string

func (m _Map_I16_Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI16(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueMap(_Map_String_String_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I16_Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I16_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TI16
}

func (_Map_I16_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_I16_Map_String_String_MapItemList) Close() {
}

type _Map_ID_Map_I16_Map_String_String_MapItemList map[ID]map[int16]map[string]string

func (m _Map_ID_Map_I16_Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := wire.NewValueMap(_Map_I16_Map_String_String_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ID_Map_I16_Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_ID_Map_I16_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_ID_Map_I16_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_ID_Map_I16_Map_String_String_MapItemList) Close() {
}

func (v *GoStructTaggerResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.StructIDToFieldTagToRemoveKeys != nil {
		w, err = wire.NewValueMap(_Map_ID_Map_I16_Set_String_MapItemList(v.StructIDToFieldTagToRemoveKeys)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructIDToFieldTagToAddKeyToValue != nil {
		w, err = wire.NewValueMap(_Map_ID_Map_I16_Map_String_String_MapItemList(v.StructIDToFieldTagToAddKeyToValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Set_String_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Map_I16_Set_String_Read(m wire.MapItemList) (map[int16]map[string]struct{}, error) {
	if m.KeyType() != wire.TI16 {
		return nil, nil
	}
	if m.ValueType() != wire.TSet {
		return nil, nil
	}
	o := make(map[int16]map[string]struct{}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI16(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Set_String_Read(x.Value.GetSet())
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_ID_Map_I16_Set_String_Read(m wire.MapItemList) (map[ID]map[int16]map[string]struct{}, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make(map[ID]map[int16]map[string]struct{}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Map_I16_Set_String_Read(x.Value.GetMap())
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_I16_Map_String_String_Read(m wire.MapItemList) (map[int16]map[string]string, error) {
	if m.KeyType() != wire.TI16 {
		return nil, nil
	}
	if m.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make(map[int16]map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI16(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Map_String_String_Read(x.Value.GetMap())
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_ID_Map_I16_Map_String_String_Read(m wire.MapItemList) (map[ID]map[int16]map[string]string, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}
	if m.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make(map[ID]map[int16]map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ID_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _Map_I16_Map_String_String_Read(x.Value.GetMap())
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *GoStructTaggerResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.StructIDToFieldTagToRemoveKeys, err = _Map_ID_Map_I16_Set_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.StructIDToFieldTagToAddKeyToValue, err = _Map_ID_Map_I16_Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *GoStructTaggerResponse) String() string {
	var fields [2]string
	i := 0
	if v.StructIDToFieldTagToRemoveKeys != nil {
		fields[i] = fmt.Sprintf("StructIDToFieldTagToRemoveKeys: %v", v.StructIDToFieldTagToRemoveKeys)
		i++
	}
	if v.StructIDToFieldTagToAddKeyToValue != nil {
		fields[i] = fmt.Sprintf("StructIDToFieldTagToAddKeyToValue: %v", v.StructIDToFieldTagToAddKeyToValue)
		i++
	}
	return fmt.Sprintf("GoStructTaggerResponse{%v}", strings.Join(fields[:i], ", "))
}

type HandshakeRequest struct{}

func (v *HandshakeRequest) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *HandshakeRequest) FromWire(w wire.Value) error {
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}
	return nil
}

func (v *HandshakeRequest) String() string {
	var fields [0]string
	i := 0
	return fmt.Sprintf("HandshakeRequest{%v}", strings.Join(fields[:i], ", "))
}

type HandshakeResponse struct {
	Name           *string                    `json:"name,omitempty"`
	ApiVersion     *int32                     `json:"apiVersion,omitempty"`
	Features       map[PluginFeature]struct{} `json:"features"`
	LibraryVersion *string                    `json:"libraryVersion,omitempty"`
}

type _Set_PluginFeature_ValueList map[PluginFeature]struct{}

func (v _Set_PluginFeature_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_PluginFeature_ValueList) Size() int {
	return len(v)
}

func (_Set_PluginFeature_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_PluginFeature_ValueList) Close() {
}

func (v *HandshakeResponse) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ApiVersion != nil {
		w, err = wire.NewValueI32(*(v.ApiVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Features != nil {
		w, err = wire.NewValueSet(_Set_PluginFeature_ValueList(v.Features)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.LibraryVersion != nil {
		w, err = wire.NewValueString(*(v.LibraryVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _PluginFeature_Read(w wire.Value) (PluginFeature, error) {
	var v PluginFeature
	err := v.FromWire(w)
	return v, err
}

func _Set_PluginFeature_Read(s wire.ValueList) (map[PluginFeature]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}
	o := make(map[PluginFeature]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _PluginFeature_Read(x)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func (v *HandshakeResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ApiVersion = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.Features, err = _Set_PluginFeature_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.LibraryVersion = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *HandshakeResponse) String() string {
	var fields [4]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.ApiVersion != nil {
		fields[i] = fmt.Sprintf("ApiVersion: %v", *(v.ApiVersion))
		i++
	}
	if v.Features != nil {
		fields[i] = fmt.Sprintf("Features: %v", v.Features)
		i++
	}
	if v.LibraryVersion != nil {
		fields[i] = fmt.Sprintf("LibraryVersion: %v", *(v.LibraryVersion))
		i++
	}
	return fmt.Sprintf("HandshakeResponse{%v}", strings.Join(fields[:i], ", "))
}

type ID int64

func (v ID) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

func (v ID) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

func (v *ID) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (ID)(x)
	return err
}

type Module struct {
	ID                      *ID               `json:"id,omitempty"`
	Name                    *string           `json:"name,omitempty"`
	NamespaceLanguageToName map[string]string `json:"namespace_language_to_name"`
	IncludedModuleIds       map[ID]struct{}   `json:"included_module_ids"`
	ConstIds                map[ID]struct{}   `json:"const_ids"`
	TypedefIds              map[ID]struct{}   `json:"typedef_ids"`
	EnumIds                 map[ID]struct{}   `json:"enum_ids"`
	StructIds               map[ID]struct{}   `json:"struct_ids"`
	ServiceIds              map[ID]struct{}   `json:"service_ids"`
}

type _Set_ID_ValueList map[ID]struct{}

func (v _Set_ID_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_ID_ValueList) Size() int {
	return len(v)
}

func (_Set_ID_ValueList) ValueType() wire.Type {
	return wire.TI64
}

func (_Set_ID_ValueList) Close() {
}

func (v *Module) ToWire() (wire.Value, error) {
	var (
		fields [9]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ID != nil {
		w, err = v.ID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.NamespaceLanguageToName != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.NamespaceLanguageToName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.IncludedModuleIds != nil {
		w, err = wire.NewValueSet(_Set_ID_ValueList(v.IncludedModuleIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.ConstIds != nil {
		w, err = wire.NewValueSet(_Set_ID_ValueList(v.ConstIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.TypedefIds != nil {
		w, err = wire.NewValueSet(_Set_ID_ValueList(v.TypedefIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.EnumIds != nil {
		w, err = wire.NewValueSet(_Set_ID_ValueList(v.EnumIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.StructIds != nil {
		w, err = wire.NewValueSet(_Set_ID_ValueList(v.StructIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.ServiceIds != nil {
		w, err = wire.NewValueSet(_Set_ID_ValueList(v.ServiceIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Set_ID_Read(s wire.ValueList) (map[ID]struct{}, error) {
	if s.ValueType() != wire.TI64 {
		return nil, nil
	}
	o := make(map[ID]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _ID_Read(x)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func (v *Module) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.NamespaceLanguageToName, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TSet {
				v.IncludedModuleIds, err = _Set_ID_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TSet {
				v.ConstIds, err = _Set_ID_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TSet {
				v.TypedefIds, err = _Set_ID_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 7:
			if field.Value.Type() == wire.TSet {
				v.EnumIds, err = _Set_ID_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 8:
			if field.Value.Type() == wire.TSet {
				v.StructIds, err = _Set_ID_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 9:
			if field.Value.Type() == wire.TSet {
				v.ServiceIds, err = _Set_ID_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Module) String() string {
	var fields [9]string
	i := 0
	if v.ID != nil {
		fields[i] = fmt.Sprintf("ID: %v", *(v.ID))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.NamespaceLanguageToName != nil {
		fields[i] = fmt.Sprintf("NamespaceLanguageToName: %v", v.NamespaceLanguageToName)
		i++
	}
	if v.IncludedModuleIds != nil {
		fields[i] = fmt.Sprintf("IncludedModuleIds: %v", v.IncludedModuleIds)
		i++
	}
	if v.ConstIds != nil {
		fields[i] = fmt.Sprintf("ConstIds: %v", v.ConstIds)
		i++
	}
	if v.TypedefIds != nil {
		fields[i] = fmt.Sprintf("TypedefIds: %v", v.TypedefIds)
		i++
	}
	if v.EnumIds != nil {
		fields[i] = fmt.Sprintf("EnumIds: %v", v.EnumIds)
		i++
	}
	if v.StructIds != nil {
		fields[i] = fmt.Sprintf("StructIds: %v", v.StructIds)
		i++
	}
	if v.ServiceIds != nil {
		fields[i] = fmt.Sprintf("ServiceIds: %v", v.ServiceIds)
		i++
	}
	return fmt.Sprintf("Module{%v}", strings.Join(fields[:i], ", "))
}

type PluginFeature int32

const (
	PluginFeatureGenerate       PluginFeature = 1
	PluginFeatureGoStructTagger PluginFeature = 2
)

func (v PluginFeature) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *PluginFeature) FromWire(w wire.Value) error {
	*v = (PluginFeature)(w.GetI32())
	return nil
}

func (v PluginFeature) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "GENERATE"
	case 2:
		return "GO_STRUCT_TAGGER"
	}
	return fmt.Sprintf("PluginFeature(%d)", w)
}

func (v PluginFeature) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"GENERATE\""), nil
	case 2:
		return ([]byte)("\"GO_STRUCT_TAGGER\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

func (v *PluginFeature) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}
	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "PluginFeature")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "PluginFeature")
		}
		*v = (PluginFeature)(x)
		return nil
	case string:
		switch w {
		case "GENERATE":
			*v = PluginFeatureGenerate
			return nil
		case "GO_STRUCT_TAGGER":
			*v = PluginFeatureGoStructTagger
			return nil
		default:
			return fmt.Errorf("unknown enum value %q for %q", w, "PluginFeature")
		}
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "PluginFeature")
	}
}

type Primitive int32

const (
	PrimitiveBool   Primitive = 1
	PrimitiveByte   Primitive = 2
	PrimitiveI16    Primitive = 3
	PrimitiveI32    Primitive = 4
	PrimitiveI64    Primitive = 5
	PrimitiveDouble Primitive = 6
	PrimitiveBinary Primitive = 7
	PrimitiveString Primitive = 8
)

func (v Primitive) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *Primitive) FromWire(w wire.Value) error {
	*v = (Primitive)(w.GetI32())
	return nil
}

func (v Primitive) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "BOOL"
	case 2:
		return "BYTE"
	case 3:
		return "I16"
	case 4:
		return "I32"
	case 5:
		return "I64"
	case 6:
		return "DOUBLE"
	case 7:
		return "BINARY"
	case 8:
		return "STRING"
	}
	return fmt.Sprintf("Primitive(%d)", w)
}

func (v Primitive) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"BOOL\""), nil
	case 2:
		return ([]byte)("\"BYTE\""), nil
	case 3:
		return ([]byte)("\"I16\""), nil
	case 4:
		return ([]byte)("\"I32\""), nil
	case 5:
		return ([]byte)("\"I64\""), nil
	case 6:
		return ([]byte)("\"DOUBLE\""), nil
	case 7:
		return ([]byte)("\"BINARY\""), nil
	case 8:
		return ([]byte)("\"STRING\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

func (v *Primitive) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}
	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Primitive")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Primitive")
		}
		*v = (Primitive)(x)
		return nil
	case string:
		switch w {
		case "BOOL":
			*v = PrimitiveBool
			return nil
		case "BYTE":
			*v = PrimitiveByte
			return nil
		case "I16":
			*v = PrimitiveI16
			return nil
		case "I32":
			*v = PrimitiveI32
			return nil
		case "I64":
			*v = PrimitiveI64
			return nil
		case "DOUBLE":
			*v = PrimitiveDouble
			return nil
		case "BINARY":
			*v = PrimitiveBinary
			return nil
		case "STRING":
			*v = PrimitiveString
			return nil
		default:
			return fmt.Errorf("unknown enum value %q for %q", w, "Primitive")
		}
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Primitive")
	}
}

type Service struct {
	ID                *ID                  `json:"id,omitempty"`
	ModuleID          *ID                  `json:"module_id,omitempty"`
	ExtendedServiceID *ID                  `json:"extended_service_id,omitempty"`
	Name              *string              `json:"name,omitempty"`
	NameToFunction    map[string]*Function `json:"name_to_function"`
	Annotations       map[string]string    `json:"annotations"`
}

type _Map_String_Function_MapItemList map[string]*Function

func (m _Map_String_Function_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Function_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Function_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Function_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_Function_MapItemList) Close() {
}

func (v *Service) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ID != nil {
		w, err = v.ID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ModuleID != nil {
		w, err = v.ModuleID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ExtendedServiceID != nil {
		w, err = v.ExtendedServiceID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.NameToFunction != nil {
		w, err = wire.NewValueMap(_Map_String_Function_MapItemList(v.NameToFunction)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Function_Read(w wire.Value) (*Function, error) {
	var v Function
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_Function_Read(m wire.MapItemList) (map[string]*Function, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[string]*Function, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Function_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *Service) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ModuleID = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ExtendedServiceID = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.NameToFunction, err = _Map_String_Function_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Service) String() string {
	var fields [6]string
	i := 0
	if v.ID != nil {
		fields[i] = fmt.Sprintf("ID: %v", *(v.ID))
		i++
	}
	if v.ModuleID != nil {
		fields[i] = fmt.Sprintf("ModuleID: %v", *(v.ModuleID))
		i++
	}
	if v.ExtendedServiceID != nil {
		fields[i] = fmt.Sprintf("ExtendedServiceID: %v", *(v.ExtendedServiceID))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.NameToFunction != nil {
		fields[i] = fmt.Sprintf("NameToFunction: %v", v.NameToFunction)
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("Service{%v}", strings.Join(fields[:i], ", "))
}

type Struct struct {
	ID          *ID               `json:"id,omitempty"`
	ModuleID    *ID               `json:"module_id,omitempty"`
	Name        *string           `json:"name,omitempty"`
	TagToField  map[int16]*Field  `json:"tag_to_field"`
	Annotations map[string]string `json:"annotations"`
}

type _Map_I16_Field_MapItemList map[int16]*Field

func (m _Map_I16_Field_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI16(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I16_Field_MapItemList) Size() int {
	return len(m)
}

func (_Map_I16_Field_MapItemList) KeyType() wire.Type {
	return wire.TI16
}

func (_Map_I16_Field_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_I16_Field_MapItemList) Close() {
}

func (v *Struct) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ID != nil {
		w, err = v.ID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ModuleID != nil {
		w, err = v.ModuleID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.TagToField != nil {
		w, err = wire.NewValueMap(_Map_I16_Field_MapItemList(v.TagToField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Field_Read(w wire.Value) (*Field, error) {
	var v Field
	err := v.FromWire(w)
	return &v, err
}

func _Map_I16_Field_Read(m wire.MapItemList) (map[int16]*Field, error) {
	if m.KeyType() != wire.TI16 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[int16]*Field, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI16(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Field_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *Struct) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ModuleID = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.TagToField, err = _Map_I16_Field_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Struct) String() string {
	var fields [5]string
	i := 0
	if v.ID != nil {
		fields[i] = fmt.Sprintf("ID: %v", *(v.ID))
		i++
	}
	if v.ModuleID != nil {
		fields[i] = fmt.Sprintf("ModuleID: %v", *(v.ModuleID))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.TagToField != nil {
		fields[i] = fmt.Sprintf("TagToField: %v", v.TagToField)
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("Struct{%v}", strings.Join(fields[:i], ", "))
}

type Type struct {
	Primitive *Primitive `json:"primitive,omitempty"`
	ListType  *Type      `json:"listType,omitempty"`
	SetType   *Type      `json:"setType,omitempty"`
	MapType   *TypePair  `json:"mapType,omitempty"`
	TypedefID *ID        `json:"typedefID,omitempty"`
	EnumID    *ID        `json:"enumID,omitempty"`
	StructID  *ID        `json:"structID,omitempty"`
}

func (v *Type) ToWire() (wire.Value, error) {
	var (
		fields [7]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Primitive != nil {
		w, err = v.Primitive.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ListType != nil {
		w, err = v.ListType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.SetType != nil {
		w, err = v.SetType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.MapType != nil {
		w, err = v.MapType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.TypedefID != nil {
		w, err = v.TypedefID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.EnumID != nil {
		w, err = v.EnumID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.StructID != nil {
		w, err = v.StructID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if i != 1 {
		return wire.Value{}, fmt.Errorf("Type should have exactly one field: got %v fields", i)
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Primitive_Read(w wire.Value) (Primitive, error) {
	var v Primitive
	err := v.FromWire(w)
	return v, err
}

func _TypePair_Read(w wire.Value) (*TypePair, error) {
	var v TypePair
	err := v.FromWire(w)
	return &v, err
}

func (v *Type) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x Primitive
				x, err = _Primitive_Read(field.Value)
				v.Primitive = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ListType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.SetType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.MapType, err = _TypePair_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.TypedefID = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.EnumID = &x
				if err != nil {
					return err
				}
			}
		case 7:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.StructID = &x
				if err != nil {
					return err
				}
			}
		}
	}
	count := 0
	if v.Primitive != nil {
		count++
	}
	if v.ListType != nil {
		count++
	}
	if v.SetType != nil {
		count++
	}
	if v.MapType != nil {
		count++
	}
	if v.TypedefID != nil {
		count++
	}
	if v.EnumID != nil {
		count++
	}
	if v.StructID != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Type should have exactly one field: got %v fields", count)
	}
	return nil
}

func (v *Type) String() string {
	var fields [7]string
	i := 0
	if v.Primitive != nil {
		fields[i] = fmt.Sprintf("Primitive: %v", *(v.Primitive))
		i++
	}
	if v.ListType != nil {
		fields[i] = fmt.Sprintf("ListType: %v", v.ListType)
		i++
	}
	if v.SetType != nil {
		fields[i] = fmt.Sprintf("SetType: %v", v.SetType)
		i++
	}
	if v.MapType != nil {
		fields[i] = fmt.Sprintf("MapType: %v", v.MapType)
		i++
	}
	if v.TypedefID != nil {
		fields[i] = fmt.Sprintf("TypedefID: %v", *(v.TypedefID))
		i++
	}
	if v.EnumID != nil {
		fields[i] = fmt.Sprintf("EnumID: %v", *(v.EnumID))
		i++
	}
	if v.StructID != nil {
		fields[i] = fmt.Sprintf("StructID: %v", *(v.StructID))
		i++
	}
	return fmt.Sprintf("Type{%v}", strings.Join(fields[:i], ", "))
}

type TypePair struct {
	Left  *Type `json:"left,omitempty"`
	Right *Type `json:"right,omitempty"`
}

func (v *TypePair) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Left != nil {
		w, err = v.Left.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Right != nil {
		w, err = v.Right.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *TypePair) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Left, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Right, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *TypePair) String() string {
	var fields [2]string
	i := 0
	if v.Left != nil {
		fields[i] = fmt.Sprintf("Left: %v", v.Left)
		i++
	}
	if v.Right != nil {
		fields[i] = fmt.Sprintf("Right: %v", v.Right)
		i++
	}
	return fmt.Sprintf("TypePair{%v}", strings.Join(fields[:i], ", "))
}

type Typedef struct {
	ID          *ID               `json:"id,omitempty"`
	ModuleID    *ID               `json:"module_id,omitempty"`
	Type        *Type             `json:"type,omitempty"`
	Name        *string           `json:"name,omitempty"`
	Annotations map[string]string `json:"annotations"`
}

func (v *Typedef) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ID != nil {
		w, err = v.ID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ModuleID != nil {
		w, err = v.ModuleID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Typedef) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ID = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x ID
				x, err = _ID_Read(field.Value)
				v.ModuleID = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Type, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Typedef) String() string {
	var fields [5]string
	i := 0
	if v.ID != nil {
		fields[i] = fmt.Sprintf("ID: %v", *(v.ID))
		i++
	}
	if v.ModuleID != nil {
		fields[i] = fmt.Sprintf("ModuleID: %v", *(v.ModuleID))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", v.Type)
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}
	return fmt.Sprintf("Typedef{%v}", strings.Join(fields[:i], ", "))
}
