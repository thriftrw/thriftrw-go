// Code generated by thriftrw v1.27.0-dev. DO NOT EDIT.
// @generated

// Copyright (c) 2021 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package api

import (
	bytes "bytes"
	base64 "encoding/base64"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	math "math"
	strconv "strconv"
	strings "strings"
)

// API_VERSION is the version of the plugin API.
//
// This MUST be provided in the HandshakeResponse.
const APIVersion int32 = 4

// Argument is a single Argument inside a Function.
// For,
//
//      void setValue(1: string key, 2: string value)
//
// You get the arguments,
//
//      Argument{Name: "Key", Type: Type{SimpleType: SimpleTypeString}}
//
//      Argument{Name: "Value", Type: Type{SimpleType: SimpleTypeString}}
type Argument struct {
	// Name of the argument. This is also the name of the argument field
	// inside the args/result struct for that function.
	Name string `json:"name,required"`
	// Argument type.
	Type *Type `json:"type,required"`
	// Annotations defined on this argument.
	//
	// Given,
	//
	//   void setValue(
	//     1: SetValueRequest req
	//   ) throws (
	//     1: BadRequestError badRequestError (cache = "false")
	//   )
	//
	// The annotations for the Argument representing badRequestError will be,
	//
	//  {
	//    "cache": "false",
	//  }
	Annotations map[string]string `json:"annotations,omitempty"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a Argument struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Argument) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_Argument)(v)), nil
}

type _fieldList_Argument Argument

func (fl *_fieldList_Argument) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*Argument)(fl)
		w   wire.Value
		err error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}
	if v.Type == nil {
		return errors.New("field Type of Argument is required")
	}
	w, err = v.Type.ToWire()
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
		return err
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 3, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_Argument) Close() {}

func _Type_Read(w wire.Value) (*Type, error) {
	var v Type
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a Argument struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Argument struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Argument
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Argument) FromWire(w wire.Value) error {

	nameIsSet := false
	typeIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Type, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				typeIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !nameIsSet {
		return errors.New("field Name of Argument is required")
	}

	if !typeIsSet {
		return errors.New("field Type of Argument is required")
	}

	return nil
}

// String returns a readable string representation of a Argument
// struct.
func (v *Argument) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("Type: %v", v.Type)
	i++
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}

	return fmt.Sprintf("Argument{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this Argument match the
// provided Argument.
//
// This function performs a deep comparison.
func (v *Argument) Equals(rhs *Argument) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !v.Type.Equals(rhs.Type) {
		return false
	}
	if !((v.Annotations == nil && rhs.Annotations == nil) || (v.Annotations != nil && rhs.Annotations != nil && _Map_String_String_Equals(v.Annotations, rhs.Annotations))) {
		return false
	}

	return true
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Argument.
func (v *Argument) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	err = multierr.Append(err, enc.AddObject("type", v.Type))
	if v.Annotations != nil {
		err = multierr.Append(err, enc.AddObject("annotations", (_Map_String_String_Zapper)(v.Annotations)))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Argument) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetType returns the value of Type if it is set or its
// zero value if it is unset.
func (v *Argument) GetType() (o *Type) {
	if v != nil {
		o = v.Type
	}
	return
}

// IsSetType returns true if Type is not nil.
func (v *Argument) IsSetType() bool {
	return v != nil && v.Type != nil
}

// GetAnnotations returns the value of Annotations if it is set or its
// zero value if it is unset.
func (v *Argument) GetAnnotations() (o map[string]string) {
	if v != nil && v.Annotations != nil {
		return v.Annotations
	}

	return
}

// IsSetAnnotations returns true if Annotations is not nil.
func (v *Argument) IsSetAnnotations() bool {
	return v != nil && v.Annotations != nil
}

// Feature is a functionality offered by a ThriftRW plugin.
type Feature int32

const (
	// SERVICE_GENERATOR specifies that the plugin may generate arbitrary code
	// for services defined in the Thrift file.
	//
	// If a plugin provides this, it MUST implement the ServiceGenerator
	// service.
	FeatureServiceGenerator Feature = 1
)

// Feature_Values returns all recognized values of Feature.
func Feature_Values() []Feature {
	return []Feature{
		FeatureServiceGenerator,
	}
}

// UnmarshalText tries to decode Feature from a byte slice
// containing its name.
//
//   var v Feature
//   err := v.UnmarshalText([]byte("SERVICE_GENERATOR"))
func (v *Feature) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "SERVICE_GENERATOR":
		*v = FeatureServiceGenerator
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "Feature", err)
		}
		*v = Feature(val)
		return nil
	}
}

// MarshalText encodes Feature to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v Feature) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("SERVICE_GENERATOR"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Feature.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v Feature) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "SERVICE_GENERATOR")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v Feature) Ptr() *Feature {
	return &v
}

// ToWire translates Feature into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Feature) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Feature from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Feature(0), err
//   }
//
//   var v Feature
//   if err := v.FromWire(x); err != nil {
//     return Feature(0), err
//   }
//   return v, nil
func (v *Feature) FromWire(w wire.Value) error {
	*v = (Feature)(w.GetI32())
	return nil
}

// String returns a readable string representation of Feature.
func (v Feature) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "SERVICE_GENERATOR"
	}
	return fmt.Sprintf("Feature(%d)", w)
}

// Equals returns true if this Feature value matches the provided
// value.
func (v Feature) Equals(rhs Feature) bool {
	return v == rhs
}

// MarshalJSON serializes Feature into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Feature) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"SERVICE_GENERATOR\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Feature from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Feature) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Feature")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Feature")
		}
		*v = (Feature)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Feature")
	}
}

// Function is a single function on a Thrift service.
type Function struct {
	// Name of the Go function.
	Name string `json:"name,required"`
	// Name of the function as defined in the Thrift file.
	ThriftName string `json:"thriftName,required"`
	// List of arguments accepted by the function.
	//
	// This list is in the order specified by the user in the Thrift file.
	Arguments []*Argument `json:"arguments,required"`
	// Return type of the function, if any. If this is not set, the function
	// is a void function.
	ReturnType *Type `json:"returnType,omitempty"`
	// List of exceptions raised by the function.
	//
	// This list is in the order specified by the user in the Thrift file.
	Exceptions []*Argument `json:"exceptions,omitempty"`
	// Whether this function is oneway or not. This should be assumed to be
	// false unless explicitly stated otherwise. If this is true, the
	// returnType and exceptions will be null or empty.
	OneWay *bool `json:"oneWay,omitempty"`
	// Annotations defined on this function.
	//
	// Given,
	//
	//   void setValue(1: SetValueRequest req) (cache = "false")
	//
	// The annotations will be,
	//
	//  {
	//    "cache": "false",
	//  }
	Annotations map[string]string `json:"annotations,omitempty"`
}

type _List_Argument_ValueList []*Argument

func (v _List_Argument_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Argument_ValueList) Size() int {
	return len(v)
}

func (_List_Argument_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Argument_ValueList) Close() {}

// ToWire translates a Function struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Function) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_Function)(v)), nil
}

type _fieldList_Function Function

func (fl *_fieldList_Function) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*Function)(fl)
		w   wire.Value
		err error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueString(v.ThriftName), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueList(_List_Argument_ValueList(v.Arguments)), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 3, Value: w}); err != nil {
		return err
	}
	if v.ReturnType != nil {
		w, err = v.ReturnType.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 4, Value: w}); err != nil {
			return err
		}
	}
	if v.Exceptions != nil {
		w, err = wire.NewValueList(_List_Argument_ValueList(v.Exceptions)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 5, Value: w}); err != nil {
			return err
		}
	}
	if v.OneWay != nil {
		w, err = wire.NewValueBool(*(v.OneWay)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 6, Value: w}); err != nil {
			return err
		}
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 7, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_Function) Close() {}

func _Argument_Read(w wire.Value) (*Argument, error) {
	var v Argument
	err := v.FromWire(w)
	return &v, err
}

func _List_Argument_Read(l wire.ValueList) ([]*Argument, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Argument, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Argument_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Function struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Function struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Function
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Function) FromWire(w wire.Value) error {

	nameIsSet := false
	thriftNameIsSet := false
	argumentsIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.ThriftName, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				thriftNameIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Arguments, err = _List_Argument_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				argumentsIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.ReturnType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.Exceptions, err = _List_Argument_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.OneWay = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !nameIsSet {
		return errors.New("field Name of Function is required")
	}

	if !thriftNameIsSet {
		return errors.New("field ThriftName of Function is required")
	}

	if !argumentsIsSet {
		return errors.New("field Arguments of Function is required")
	}

	return nil
}

// String returns a readable string representation of a Function
// struct.
func (v *Function) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [7]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("ThriftName: %v", v.ThriftName)
	i++
	fields[i] = fmt.Sprintf("Arguments: %v", v.Arguments)
	i++
	if v.ReturnType != nil {
		fields[i] = fmt.Sprintf("ReturnType: %v", v.ReturnType)
		i++
	}
	if v.Exceptions != nil {
		fields[i] = fmt.Sprintf("Exceptions: %v", v.Exceptions)
		i++
	}
	if v.OneWay != nil {
		fields[i] = fmt.Sprintf("OneWay: %v", *(v.OneWay))
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}

	return fmt.Sprintf("Function{%v}", strings.Join(fields[:i], ", "))
}

func _List_Argument_Equals(lhs, rhs []*Argument) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Function match the
// provided Function.
//
// This function performs a deep comparison.
func (v *Function) Equals(rhs *Function) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.ThriftName == rhs.ThriftName) {
		return false
	}
	if !_List_Argument_Equals(v.Arguments, rhs.Arguments) {
		return false
	}
	if !((v.ReturnType == nil && rhs.ReturnType == nil) || (v.ReturnType != nil && rhs.ReturnType != nil && v.ReturnType.Equals(rhs.ReturnType))) {
		return false
	}
	if !((v.Exceptions == nil && rhs.Exceptions == nil) || (v.Exceptions != nil && rhs.Exceptions != nil && _List_Argument_Equals(v.Exceptions, rhs.Exceptions))) {
		return false
	}
	if !_Bool_EqualsPtr(v.OneWay, rhs.OneWay) {
		return false
	}
	if !((v.Annotations == nil && rhs.Annotations == nil) || (v.Annotations != nil && rhs.Annotations != nil && _Map_String_String_Equals(v.Annotations, rhs.Annotations))) {
		return false
	}

	return true
}

type _List_Argument_Zapper []*Argument

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Argument_Zapper.
func (l _List_Argument_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Function.
func (v *Function) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	enc.AddString("thriftName", v.ThriftName)
	err = multierr.Append(err, enc.AddArray("arguments", (_List_Argument_Zapper)(v.Arguments)))
	if v.ReturnType != nil {
		err = multierr.Append(err, enc.AddObject("returnType", v.ReturnType))
	}
	if v.Exceptions != nil {
		err = multierr.Append(err, enc.AddArray("exceptions", (_List_Argument_Zapper)(v.Exceptions)))
	}
	if v.OneWay != nil {
		enc.AddBool("oneWay", *v.OneWay)
	}
	if v.Annotations != nil {
		err = multierr.Append(err, enc.AddObject("annotations", (_Map_String_String_Zapper)(v.Annotations)))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Function) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetThriftName returns the value of ThriftName if it is set or its
// zero value if it is unset.
func (v *Function) GetThriftName() (o string) {
	if v != nil {
		o = v.ThriftName
	}
	return
}

// GetArguments returns the value of Arguments if it is set or its
// zero value if it is unset.
func (v *Function) GetArguments() (o []*Argument) {
	if v != nil {
		o = v.Arguments
	}
	return
}

// IsSetArguments returns true if Arguments is not nil.
func (v *Function) IsSetArguments() bool {
	return v != nil && v.Arguments != nil
}

// GetReturnType returns the value of ReturnType if it is set or its
// zero value if it is unset.
func (v *Function) GetReturnType() (o *Type) {
	if v != nil && v.ReturnType != nil {
		return v.ReturnType
	}

	return
}

// IsSetReturnType returns true if ReturnType is not nil.
func (v *Function) IsSetReturnType() bool {
	return v != nil && v.ReturnType != nil
}

// GetExceptions returns the value of Exceptions if it is set or its
// zero value if it is unset.
func (v *Function) GetExceptions() (o []*Argument) {
	if v != nil && v.Exceptions != nil {
		return v.Exceptions
	}

	return
}

// IsSetExceptions returns true if Exceptions is not nil.
func (v *Function) IsSetExceptions() bool {
	return v != nil && v.Exceptions != nil
}

// GetOneWay returns the value of OneWay if it is set or its
// zero value if it is unset.
func (v *Function) GetOneWay() (o bool) {
	if v != nil && v.OneWay != nil {
		return *v.OneWay
	}

	return
}

// IsSetOneWay returns true if OneWay is not nil.
func (v *Function) IsSetOneWay() bool {
	return v != nil && v.OneWay != nil
}

// GetAnnotations returns the value of Annotations if it is set or its
// zero value if it is unset.
func (v *Function) GetAnnotations() (o map[string]string) {
	if v != nil && v.Annotations != nil {
		return v.Annotations
	}

	return
}

// IsSetAnnotations returns true if Annotations is not nil.
func (v *Function) IsSetAnnotations() bool {
	return v != nil && v.Annotations != nil
}

// GenerateServiceRequest is a request to generate code for zero or more
// Thrift services.
type GenerateServiceRequest struct {
	// IDs of services for which code should be generated.
	//
	// Note that the services map contains information about both, the
	// services being generated and their transitive dependencies. Code should
	// only be generated for service IDs listed here.
	RootServices []ServiceID `json:"rootServices,required"`
	// Map of service ID to service.
	//
	// Any service IDs present in this request will have a corresponding
	// service definition in this map, including services for which code does
	// not need to be generated.
	Services map[ServiceID]*Service `json:"services,required"`
	// Map of module ID to module.
	//
	// Any module IDs present in the request will have a corresponding module
	// definition in this map.
	Modules map[ModuleID]*Module `json:"modules,required"`
	// Prefix for import paths of generated module. In general, plugins should
	// not need to use the package prefix unless instantiating a new
	// Generator for more custom plugin generation.
	PackagePrefix string `json:"packagePrefix,required"`
	// Directory whose descendants contain all Thrift files. In general,
	// plugins should not need to use the thrift root unless instantiating a
	// new Generator for more custom plugin generation.
	ThriftRoot string `json:"thriftRoot,required"`
	// IDs of Modules for which code should be generated.
	//
	// Note that the modules map contains information about both, the
	// modules being generated and their transitive dependencies. Code should
	// only be generated for module IDs listed here.
	RootModules []ModuleID `json:"rootModules,omitempty"`
}

type _List_ServiceID_ValueList []ServiceID

func (v _List_ServiceID_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ServiceID_ValueList) Size() int {
	return len(v)
}

func (_List_ServiceID_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_ServiceID_ValueList) Close() {}

type _Map_ServiceID_Service_MapItemList map[ServiceID]*Service

func (m _Map_ServiceID_Service_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ServiceID_Service_MapItemList) Size() int {
	return len(m)
}

func (_Map_ServiceID_Service_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_ServiceID_Service_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ServiceID_Service_MapItemList) Close() {}

type _Map_ModuleID_Module_MapItemList map[ModuleID]*Module

func (m _Map_ModuleID_Module_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ModuleID_Module_MapItemList) Size() int {
	return len(m)
}

func (_Map_ModuleID_Module_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_ModuleID_Module_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ModuleID_Module_MapItemList) Close() {}

type _List_ModuleID_ValueList []ModuleID

func (v _List_ModuleID_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ModuleID_ValueList) Size() int {
	return len(v)
}

func (_List_ModuleID_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_ModuleID_ValueList) Close() {}

// ToWire translates a GenerateServiceRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GenerateServiceRequest) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_GenerateServiceRequest)(v)), nil
}

type _fieldList_GenerateServiceRequest GenerateServiceRequest

func (fl *_fieldList_GenerateServiceRequest) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*GenerateServiceRequest)(fl)
		w   wire.Value
		err error
	)

	w, err = wire.NewValueList(_List_ServiceID_ValueList(v.RootServices)), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}
	if v.Services == nil {
		return errors.New("field Services of GenerateServiceRequest is required")
	}
	w, err = wire.NewValueMap(_Map_ServiceID_Service_MapItemList(v.Services)), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
		return err
	}
	if v.Modules == nil {
		return errors.New("field Modules of GenerateServiceRequest is required")
	}
	w, err = wire.NewValueMap(_Map_ModuleID_Module_MapItemList(v.Modules)), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 3, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueString(v.PackagePrefix), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 4, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueString(v.ThriftRoot), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 5, Value: w}); err != nil {
		return err
	}
	if v.RootModules != nil {
		w, err = wire.NewValueList(_List_ModuleID_ValueList(v.RootModules)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 6, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_GenerateServiceRequest) Close() {}

func _ServiceID_Read(w wire.Value) (ServiceID, error) {
	var x ServiceID
	err := x.FromWire(w)
	return x, err
}

func _List_ServiceID_Read(l wire.ValueList) ([]ServiceID, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]ServiceID, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ServiceID_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Service_Read(w wire.Value) (*Service, error) {
	var v Service
	err := v.FromWire(w)
	return &v, err
}

func _Map_ServiceID_Service_Read(m wire.MapItemList) (map[ServiceID]*Service, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[ServiceID]*Service, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ServiceID_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Service_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _ModuleID_Read(w wire.Value) (ModuleID, error) {
	var x ModuleID
	err := x.FromWire(w)
	return x, err
}

func _Module_Read(w wire.Value) (*Module, error) {
	var v Module
	err := v.FromWire(w)
	return &v, err
}

func _Map_ModuleID_Module_Read(m wire.MapItemList) (map[ModuleID]*Module, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[ModuleID]*Module, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ModuleID_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Module_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _List_ModuleID_Read(l wire.ValueList) ([]ModuleID, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]ModuleID, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ModuleID_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a GenerateServiceRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GenerateServiceRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GenerateServiceRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GenerateServiceRequest) FromWire(w wire.Value) error {

	rootServicesIsSet := false
	servicesIsSet := false
	modulesIsSet := false
	packagePrefixIsSet := false
	thriftRootIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.RootServices, err = _List_ServiceID_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				rootServicesIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.Services, err = _Map_ServiceID_Service_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				servicesIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.Modules, err = _Map_ModuleID_Module_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				modulesIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				v.PackagePrefix, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				packagePrefixIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TBinary {
				v.ThriftRoot, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				thriftRootIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TList {
				v.RootModules, err = _List_ModuleID_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !rootServicesIsSet {
		return errors.New("field RootServices of GenerateServiceRequest is required")
	}

	if !servicesIsSet {
		return errors.New("field Services of GenerateServiceRequest is required")
	}

	if !modulesIsSet {
		return errors.New("field Modules of GenerateServiceRequest is required")
	}

	if !packagePrefixIsSet {
		return errors.New("field PackagePrefix of GenerateServiceRequest is required")
	}

	if !thriftRootIsSet {
		return errors.New("field ThriftRoot of GenerateServiceRequest is required")
	}

	return nil
}

// String returns a readable string representation of a GenerateServiceRequest
// struct.
func (v *GenerateServiceRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("RootServices: %v", v.RootServices)
	i++
	fields[i] = fmt.Sprintf("Services: %v", v.Services)
	i++
	fields[i] = fmt.Sprintf("Modules: %v", v.Modules)
	i++
	fields[i] = fmt.Sprintf("PackagePrefix: %v", v.PackagePrefix)
	i++
	fields[i] = fmt.Sprintf("ThriftRoot: %v", v.ThriftRoot)
	i++
	if v.RootModules != nil {
		fields[i] = fmt.Sprintf("RootModules: %v", v.RootModules)
		i++
	}

	return fmt.Sprintf("GenerateServiceRequest{%v}", strings.Join(fields[:i], ", "))
}

func _List_ServiceID_Equals(lhs, rhs []ServiceID) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

func _Map_ServiceID_Service_Equals(lhs, rhs map[ServiceID]*Service) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func _Map_ModuleID_Module_Equals(lhs, rhs map[ModuleID]*Module) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func _List_ModuleID_Equals(lhs, rhs []ModuleID) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this GenerateServiceRequest match the
// provided GenerateServiceRequest.
//
// This function performs a deep comparison.
func (v *GenerateServiceRequest) Equals(rhs *GenerateServiceRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_List_ServiceID_Equals(v.RootServices, rhs.RootServices) {
		return false
	}
	if !_Map_ServiceID_Service_Equals(v.Services, rhs.Services) {
		return false
	}
	if !_Map_ModuleID_Module_Equals(v.Modules, rhs.Modules) {
		return false
	}
	if !(v.PackagePrefix == rhs.PackagePrefix) {
		return false
	}
	if !(v.ThriftRoot == rhs.ThriftRoot) {
		return false
	}
	if !((v.RootModules == nil && rhs.RootModules == nil) || (v.RootModules != nil && rhs.RootModules != nil && _List_ModuleID_Equals(v.RootModules, rhs.RootModules))) {
		return false
	}

	return true
}

type _List_ServiceID_Zapper []ServiceID

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_ServiceID_Zapper.
func (l _List_ServiceID_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendInt32((int32)(v))
	}
	return err
}

type _Map_ServiceID_Service_Item_Zapper struct {
	Key   ServiceID
	Value *Service
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_ServiceID_Service_Item_Zapper.
func (v _Map_ServiceID_Service_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", (int32)(v.Key))
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_ServiceID_Service_Zapper map[ServiceID]*Service

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_ServiceID_Service_Zapper.
func (m _Map_ServiceID_Service_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_ServiceID_Service_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _Map_ModuleID_Module_Item_Zapper struct {
	Key   ModuleID
	Value *Module
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_ModuleID_Module_Item_Zapper.
func (v _Map_ModuleID_Module_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", (int32)(v.Key))
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_ModuleID_Module_Zapper map[ModuleID]*Module

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_ModuleID_Module_Zapper.
func (m _Map_ModuleID_Module_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_ModuleID_Module_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_ModuleID_Zapper []ModuleID

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_ModuleID_Zapper.
func (l _List_ModuleID_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendInt32((int32)(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GenerateServiceRequest.
func (v *GenerateServiceRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("rootServices", (_List_ServiceID_Zapper)(v.RootServices)))
	err = multierr.Append(err, enc.AddArray("services", (_Map_ServiceID_Service_Zapper)(v.Services)))
	err = multierr.Append(err, enc.AddArray("modules", (_Map_ModuleID_Module_Zapper)(v.Modules)))
	enc.AddString("packagePrefix", v.PackagePrefix)
	enc.AddString("thriftRoot", v.ThriftRoot)
	if v.RootModules != nil {
		err = multierr.Append(err, enc.AddArray("rootModules", (_List_ModuleID_Zapper)(v.RootModules)))
	}
	return err
}

// GetRootServices returns the value of RootServices if it is set or its
// zero value if it is unset.
func (v *GenerateServiceRequest) GetRootServices() (o []ServiceID) {
	if v != nil {
		o = v.RootServices
	}
	return
}

// IsSetRootServices returns true if RootServices is not nil.
func (v *GenerateServiceRequest) IsSetRootServices() bool {
	return v != nil && v.RootServices != nil
}

// GetServices returns the value of Services if it is set or its
// zero value if it is unset.
func (v *GenerateServiceRequest) GetServices() (o map[ServiceID]*Service) {
	if v != nil {
		o = v.Services
	}
	return
}

// IsSetServices returns true if Services is not nil.
func (v *GenerateServiceRequest) IsSetServices() bool {
	return v != nil && v.Services != nil
}

// GetModules returns the value of Modules if it is set or its
// zero value if it is unset.
func (v *GenerateServiceRequest) GetModules() (o map[ModuleID]*Module) {
	if v != nil {
		o = v.Modules
	}
	return
}

// IsSetModules returns true if Modules is not nil.
func (v *GenerateServiceRequest) IsSetModules() bool {
	return v != nil && v.Modules != nil
}

// GetPackagePrefix returns the value of PackagePrefix if it is set or its
// zero value if it is unset.
func (v *GenerateServiceRequest) GetPackagePrefix() (o string) {
	if v != nil {
		o = v.PackagePrefix
	}
	return
}

// GetThriftRoot returns the value of ThriftRoot if it is set or its
// zero value if it is unset.
func (v *GenerateServiceRequest) GetThriftRoot() (o string) {
	if v != nil {
		o = v.ThriftRoot
	}
	return
}

// GetRootModules returns the value of RootModules if it is set or its
// zero value if it is unset.
func (v *GenerateServiceRequest) GetRootModules() (o []ModuleID) {
	if v != nil && v.RootModules != nil {
		return v.RootModules
	}

	return
}

// IsSetRootModules returns true if RootModules is not nil.
func (v *GenerateServiceRequest) IsSetRootModules() bool {
	return v != nil && v.RootModules != nil
}

// GenerateServiceResponse is response to a GenerateServiceRequest.
type GenerateServiceResponse struct {
	// Map of file path to file contents.
	//
	// All paths MUST be relative to the output directory into which ThriftRW
	// is generating code. Plugins SHOULD NOT make any assumptions about the
	// absolute location of the directory.
	//
	// The paths MUST NOT contain the string ".." or the request will fail.
	Files map[string][]byte `json:"files,omitempty"`
}

type _Map_String_Binary_MapItemList map[string][]byte

func (m _Map_String_Binary_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueBinary(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Binary_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Binary_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) Close() {}

// ToWire translates a GenerateServiceResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GenerateServiceResponse) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_GenerateServiceResponse)(v)), nil
}

type _fieldList_GenerateServiceResponse GenerateServiceResponse

func (fl *_fieldList_GenerateServiceResponse) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*GenerateServiceResponse)(fl)
		w   wire.Value
		err error
	)

	if v.Files != nil {
		w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.Files)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_GenerateServiceResponse) Close() {}

func _Map_String_Binary_Read(m wire.MapItemList) (map[string][]byte, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string][]byte, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetBinary(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a GenerateServiceResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GenerateServiceResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GenerateServiceResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GenerateServiceResponse) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Files, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	return nil
}

// String returns a readable string representation of a GenerateServiceResponse
// struct.
func (v *GenerateServiceResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Files != nil {
		fields[i] = fmt.Sprintf("Files: %v", v.Files)
		i++
	}

	return fmt.Sprintf("GenerateServiceResponse{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_Binary_Equals(lhs, rhs map[string][]byte) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !bytes.Equal(lv, rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this GenerateServiceResponse match the
// provided GenerateServiceResponse.
//
// This function performs a deep comparison.
func (v *GenerateServiceResponse) Equals(rhs *GenerateServiceResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Files == nil && rhs.Files == nil) || (v.Files != nil && rhs.Files != nil && _Map_String_Binary_Equals(v.Files, rhs.Files))) {
		return false
	}

	return true
}

type _Map_String_Binary_Zapper map[string][]byte

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_Binary_Zapper.
func (m _Map_String_Binary_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), base64.StdEncoding.EncodeToString(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GenerateServiceResponse.
func (v *GenerateServiceResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Files != nil {
		err = multierr.Append(err, enc.AddObject("files", (_Map_String_Binary_Zapper)(v.Files)))
	}
	return err
}

// GetFiles returns the value of Files if it is set or its
// zero value if it is unset.
func (v *GenerateServiceResponse) GetFiles() (o map[string][]byte) {
	if v != nil && v.Files != nil {
		return v.Files
	}

	return
}

// IsSetFiles returns true if Files is not nil.
func (v *GenerateServiceResponse) IsSetFiles() bool {
	return v != nil && v.Files != nil
}

// HandshakeRequest is the initial request sent to the plugin as part of
// establishing communication and feature negotiation.
type HandshakeRequest struct {
}

// ToWire translates a HandshakeRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HandshakeRequest) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_HandshakeRequest)(v)), nil
}

type _fieldList_HandshakeRequest HandshakeRequest

func (fl *_fieldList_HandshakeRequest) ForEach(writeField func(wire.Field) error) error {

	return nil
}

func (fl *_fieldList_HandshakeRequest) Close() {}

// FromWire deserializes a HandshakeRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HandshakeRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HandshakeRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HandshakeRequest) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	return nil
}

// String returns a readable string representation of a HandshakeRequest
// struct.
func (v *HandshakeRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("HandshakeRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this HandshakeRequest match the
// provided HandshakeRequest.
//
// This function performs a deep comparison.
func (v *HandshakeRequest) Equals(rhs *HandshakeRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HandshakeRequest.
func (v *HandshakeRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// HandshakeResponse is the response from the plugin for a HandshakeRequest.
type HandshakeResponse struct {
	// Name of the plugin. This MUST match the name of the plugin specified
	// over the command line or the program will fail.
	Name string `json:"name,required"`
	// Version of the plugin API.
	//
	// This MUST be set to API_VERSION by the plugin.
	APIVersion int32 `json:"apiVersion,required"`
	// List of features the plugin provides.
	Features []Feature `json:"features,required"`
	// Version of ThriftRW with which the plugin was built.
	//
	// This MUST be set to go.uber.org/thriftrw/version.Version by the plugin
	// explicitly.
	LibraryVersion *string `json:"libraryVersion,omitempty"`
}

type _List_Feature_ValueList []Feature

func (v _List_Feature_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Feature_ValueList) Size() int {
	return len(v)
}

func (_List_Feature_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_Feature_ValueList) Close() {}

// ToWire translates a HandshakeResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HandshakeResponse) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_HandshakeResponse)(v)), nil
}

type _fieldList_HandshakeResponse HandshakeResponse

func (fl *_fieldList_HandshakeResponse) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*HandshakeResponse)(fl)
		w   wire.Value
		err error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueI32(v.APIVersion), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueList(_List_Feature_ValueList(v.Features)), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 3, Value: w}); err != nil {
		return err
	}
	if v.LibraryVersion != nil {
		w, err = wire.NewValueString(*(v.LibraryVersion)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 4, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_HandshakeResponse) Close() {}

func _Feature_Read(w wire.Value) (Feature, error) {
	var v Feature
	err := v.FromWire(w)
	return v, err
}

func _List_Feature_Read(l wire.ValueList) ([]Feature, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]Feature, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Feature_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a HandshakeResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HandshakeResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HandshakeResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HandshakeResponse) FromWire(w wire.Value) error {

	nameIsSet := false
	apiVersionIsSet := false
	featuresIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				v.APIVersion, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				apiVersionIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Features, err = _List_Feature_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				featuresIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.LibraryVersion = &x
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !nameIsSet {
		return errors.New("field Name of HandshakeResponse is required")
	}

	if !apiVersionIsSet {
		return errors.New("field APIVersion of HandshakeResponse is required")
	}

	if !featuresIsSet {
		return errors.New("field Features of HandshakeResponse is required")
	}

	return nil
}

// String returns a readable string representation of a HandshakeResponse
// struct.
func (v *HandshakeResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("APIVersion: %v", v.APIVersion)
	i++
	fields[i] = fmt.Sprintf("Features: %v", v.Features)
	i++
	if v.LibraryVersion != nil {
		fields[i] = fmt.Sprintf("LibraryVersion: %v", *(v.LibraryVersion))
		i++
	}

	return fmt.Sprintf("HandshakeResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_Feature_Equals(lhs, rhs []Feature) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this HandshakeResponse match the
// provided HandshakeResponse.
//
// This function performs a deep comparison.
func (v *HandshakeResponse) Equals(rhs *HandshakeResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.APIVersion == rhs.APIVersion) {
		return false
	}
	if !_List_Feature_Equals(v.Features, rhs.Features) {
		return false
	}
	if !_String_EqualsPtr(v.LibraryVersion, rhs.LibraryVersion) {
		return false
	}

	return true
}

type _List_Feature_Zapper []Feature

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Feature_Zapper.
func (l _List_Feature_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HandshakeResponse.
func (v *HandshakeResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	enc.AddInt32("apiVersion", v.APIVersion)
	err = multierr.Append(err, enc.AddArray("features", (_List_Feature_Zapper)(v.Features)))
	if v.LibraryVersion != nil {
		enc.AddString("libraryVersion", *v.LibraryVersion)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *HandshakeResponse) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetAPIVersion returns the value of APIVersion if it is set or its
// zero value if it is unset.
func (v *HandshakeResponse) GetAPIVersion() (o int32) {
	if v != nil {
		o = v.APIVersion
	}
	return
}

// GetFeatures returns the value of Features if it is set or its
// zero value if it is unset.
func (v *HandshakeResponse) GetFeatures() (o []Feature) {
	if v != nil {
		o = v.Features
	}
	return
}

// IsSetFeatures returns true if Features is not nil.
func (v *HandshakeResponse) IsSetFeatures() bool {
	return v != nil && v.Features != nil
}

// GetLibraryVersion returns the value of LibraryVersion if it is set or its
// zero value if it is unset.
func (v *HandshakeResponse) GetLibraryVersion() (o string) {
	if v != nil && v.LibraryVersion != nil {
		return *v.LibraryVersion
	}

	return
}

// IsSetLibraryVersion returns true if LibraryVersion is not nil.
func (v *HandshakeResponse) IsSetLibraryVersion() bool {
	return v != nil && v.LibraryVersion != nil
}

// Module is a module generated from a single Thrift file. Each module
// corresponds to exactly one Thrift file and contains all the types and
// constants defined in that Thrift file.
type Module struct {
	// Import path for the package defining the types for this module.
	ImportPath string `json:"importPath,required"`
	// Path to the directory containing the code for this module.
	//
	// The path is relative to the output directory into which ThriftRW is
	// generating code. Plugins SHOULD NOT make any assumptions about the
	// absolute location of the directory.
	Directory string `json:"directory,required"`
	// Path to the Thrift file from which this module was generated.
	ThriftFilePath string `json:"thriftFilePath,required"`
}

// ToWire translates a Module struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Module) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_Module)(v)), nil
}

type _fieldList_Module Module

func (fl *_fieldList_Module) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*Module)(fl)
		w   wire.Value
		err error
	)

	w, err = wire.NewValueString(v.ImportPath), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueString(v.Directory), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueString(v.ThriftFilePath), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 3, Value: w}); err != nil {
		return err
	}

	return nil
}

func (fl *_fieldList_Module) Close() {}

// FromWire deserializes a Module struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Module struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Module
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Module) FromWire(w wire.Value) error {

	importPathIsSet := false
	directoryIsSet := false
	thriftFilePathIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.ImportPath, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				importPathIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Directory, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				directoryIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				v.ThriftFilePath, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				thriftFilePathIsSet = true
			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !importPathIsSet {
		return errors.New("field ImportPath of Module is required")
	}

	if !directoryIsSet {
		return errors.New("field Directory of Module is required")
	}

	if !thriftFilePathIsSet {
		return errors.New("field ThriftFilePath of Module is required")
	}

	return nil
}

// String returns a readable string representation of a Module
// struct.
func (v *Module) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("ImportPath: %v", v.ImportPath)
	i++
	fields[i] = fmt.Sprintf("Directory: %v", v.Directory)
	i++
	fields[i] = fmt.Sprintf("ThriftFilePath: %v", v.ThriftFilePath)
	i++

	return fmt.Sprintf("Module{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Module match the
// provided Module.
//
// This function performs a deep comparison.
func (v *Module) Equals(rhs *Module) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.ImportPath == rhs.ImportPath) {
		return false
	}
	if !(v.Directory == rhs.Directory) {
		return false
	}
	if !(v.ThriftFilePath == rhs.ThriftFilePath) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Module.
func (v *Module) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("importPath", v.ImportPath)
	enc.AddString("directory", v.Directory)
	enc.AddString("thriftFilePath", v.ThriftFilePath)
	return err
}

// GetImportPath returns the value of ImportPath if it is set or its
// zero value if it is unset.
func (v *Module) GetImportPath() (o string) {
	if v != nil {
		o = v.ImportPath
	}
	return
}

// GetDirectory returns the value of Directory if it is set or its
// zero value if it is unset.
func (v *Module) GetDirectory() (o string) {
	if v != nil {
		o = v.Directory
	}
	return
}

// GetThriftFilePath returns the value of ThriftFilePath if it is set or its
// zero value if it is unset.
func (v *Module) GetThriftFilePath() (o string) {
	if v != nil {
		o = v.ThriftFilePath
	}
	return
}

// ModuleID is an arbitrary unique identifier to reference the different
// modules in this request.
type ModuleID int32

// ModuleIDPtr returns a pointer to a ModuleID
func (v ModuleID) Ptr() *ModuleID {
	return &v
}

// ToWire translates ModuleID into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v ModuleID) ToWire() (wire.Value, error) {
	x := (int32)(v)
	return wire.NewValueI32(x), error(nil)
}

// String returns a readable string representation of ModuleID.
func (v ModuleID) String() string {
	x := (int32)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes ModuleID from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *ModuleID) FromWire(w wire.Value) error {
	x, err := w.GetI32(), error(nil)
	*v = (ModuleID)(x)
	return err
}

// Equals returns true if this ModuleID is equal to the provided
// ModuleID.
func (lhs ModuleID) Equals(rhs ModuleID) bool {
	return ((int32)(lhs) == (int32)(rhs))
}

// Service is a service defined by the user in the Thrift file.
type Service struct {
	// Name of the Thrift service in Go code.
	Name string `json:"name,required"`
	// Name of the service as defined in the Thrift file.
	ThriftName string `json:"thriftName,required"`
	// ID of the parent service.
	ParentID *ServiceID `json:"parentID,omitempty"`
	// List of functions defined for this service.
	Functions []*Function `json:"functions,required"`
	// ID of the module where this service was declared.
	ModuleID ModuleID `json:"moduleID,required"`
	// Annotations defined on this service.
	//
	// Given,
	//
	//   service KeyValue {
	//   } (private = "true")
	//
	// The annotations will be,
	//
	//  {
	//    "private": "true",
	//  }
	Annotations map[string]string `json:"annotations,omitempty"`
}

type _List_Function_ValueList []*Function

func (v _List_Function_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Function_ValueList) Size() int {
	return len(v)
}

func (_List_Function_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Function_ValueList) Close() {}

// ToWire translates a Service struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Service) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_Service)(v)), nil
}

type _fieldList_Service Service

func (fl *_fieldList_Service) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*Service)(fl)
		w   wire.Value
		err error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 7, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueString(v.ThriftName), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}
	if v.ParentID != nil {
		w, err = v.ParentID.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 4, Value: w}); err != nil {
			return err
		}
	}

	w, err = wire.NewValueList(_List_Function_ValueList(v.Functions)), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 5, Value: w}); err != nil {
		return err
	}

	w, err = v.ModuleID.ToWire()
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 6, Value: w}); err != nil {
		return err
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 8, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_Service) Close() {}

func _Function_Read(w wire.Value) (*Function, error) {
	var v Function
	err := v.FromWire(w)
	return &v, err
}

func _List_Function_Read(l wire.ValueList) ([]*Function, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Function, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Function_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Service struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Service struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Service
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Service) FromWire(w wire.Value) error {

	nameIsSet := false
	thriftNameIsSet := false

	functionsIsSet := false
	moduleIDIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 7:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.ThriftName, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				thriftNameIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x ServiceID
				x, err = _ServiceID_Read(field.Value)
				v.ParentID = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.Functions, err = _List_Function_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				functionsIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TI32 {
				v.ModuleID, err = _ModuleID_Read(field.Value)
				if err != nil {
					return err
				}
				moduleIDIsSet = true
			}
		case 8:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !nameIsSet {
		return errors.New("field Name of Service is required")
	}

	if !thriftNameIsSet {
		return errors.New("field ThriftName of Service is required")
	}

	if !functionsIsSet {
		return errors.New("field Functions of Service is required")
	}

	if !moduleIDIsSet {
		return errors.New("field ModuleID of Service is required")
	}

	return nil
}

// String returns a readable string representation of a Service
// struct.
func (v *Service) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("ThriftName: %v", v.ThriftName)
	i++
	if v.ParentID != nil {
		fields[i] = fmt.Sprintf("ParentID: %v", *(v.ParentID))
		i++
	}
	fields[i] = fmt.Sprintf("Functions: %v", v.Functions)
	i++
	fields[i] = fmt.Sprintf("ModuleID: %v", v.ModuleID)
	i++
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}

	return fmt.Sprintf("Service{%v}", strings.Join(fields[:i], ", "))
}

func _ServiceID_EqualsPtr(lhs, rhs *ServiceID) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _List_Function_Equals(lhs, rhs []*Function) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Service match the
// provided Service.
//
// This function performs a deep comparison.
func (v *Service) Equals(rhs *Service) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.ThriftName == rhs.ThriftName) {
		return false
	}
	if !_ServiceID_EqualsPtr(v.ParentID, rhs.ParentID) {
		return false
	}
	if !_List_Function_Equals(v.Functions, rhs.Functions) {
		return false
	}
	if !(v.ModuleID == rhs.ModuleID) {
		return false
	}
	if !((v.Annotations == nil && rhs.Annotations == nil) || (v.Annotations != nil && rhs.Annotations != nil && _Map_String_String_Equals(v.Annotations, rhs.Annotations))) {
		return false
	}

	return true
}

type _List_Function_Zapper []*Function

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Function_Zapper.
func (l _List_Function_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Service.
func (v *Service) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	enc.AddString("thriftName", v.ThriftName)
	if v.ParentID != nil {
		enc.AddInt32("parentID", (int32)(*v.ParentID))
	}
	err = multierr.Append(err, enc.AddArray("functions", (_List_Function_Zapper)(v.Functions)))
	enc.AddInt32("moduleID", (int32)(v.ModuleID))
	if v.Annotations != nil {
		err = multierr.Append(err, enc.AddObject("annotations", (_Map_String_String_Zapper)(v.Annotations)))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Service) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetThriftName returns the value of ThriftName if it is set or its
// zero value if it is unset.
func (v *Service) GetThriftName() (o string) {
	if v != nil {
		o = v.ThriftName
	}
	return
}

// GetParentID returns the value of ParentID if it is set or its
// zero value if it is unset.
func (v *Service) GetParentID() (o ServiceID) {
	if v != nil && v.ParentID != nil {
		return *v.ParentID
	}

	return
}

// IsSetParentID returns true if ParentID is not nil.
func (v *Service) IsSetParentID() bool {
	return v != nil && v.ParentID != nil
}

// GetFunctions returns the value of Functions if it is set or its
// zero value if it is unset.
func (v *Service) GetFunctions() (o []*Function) {
	if v != nil {
		o = v.Functions
	}
	return
}

// IsSetFunctions returns true if Functions is not nil.
func (v *Service) IsSetFunctions() bool {
	return v != nil && v.Functions != nil
}

// GetModuleID returns the value of ModuleID if it is set or its
// zero value if it is unset.
func (v *Service) GetModuleID() (o ModuleID) {
	if v != nil {
		o = v.ModuleID
	}
	return
}

// GetAnnotations returns the value of Annotations if it is set or its
// zero value if it is unset.
func (v *Service) GetAnnotations() (o map[string]string) {
	if v != nil && v.Annotations != nil {
		return v.Annotations
	}

	return
}

// IsSetAnnotations returns true if Annotations is not nil.
func (v *Service) IsSetAnnotations() bool {
	return v != nil && v.Annotations != nil
}

// ServiceID is an arbitrary unique identifier to reference the different
// services in this request.
type ServiceID int32

// ServiceIDPtr returns a pointer to a ServiceID
func (v ServiceID) Ptr() *ServiceID {
	return &v
}

// ToWire translates ServiceID into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v ServiceID) ToWire() (wire.Value, error) {
	x := (int32)(v)
	return wire.NewValueI32(x), error(nil)
}

// String returns a readable string representation of ServiceID.
func (v ServiceID) String() string {
	x := (int32)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes ServiceID from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *ServiceID) FromWire(w wire.Value) error {
	x, err := w.GetI32(), error(nil)
	*v = (ServiceID)(x)
	return err
}

// Equals returns true if this ServiceID is equal to the provided
// ServiceID.
func (lhs ServiceID) Equals(rhs ServiceID) bool {
	return ((int32)(lhs) == (int32)(rhs))
}

// SimpleType is a standalone native Go type.
type SimpleType int32

const (
	SimpleTypeBool        SimpleType = 1
	SimpleTypeByte        SimpleType = 2
	SimpleTypeInt8        SimpleType = 3
	SimpleTypeInt16       SimpleType = 4
	SimpleTypeInt32       SimpleType = 5
	SimpleTypeInt64       SimpleType = 6
	SimpleTypeFloat64     SimpleType = 7
	SimpleTypeString      SimpleType = 8
	SimpleTypeStructEmpty SimpleType = 9
)

// SimpleType_Values returns all recognized values of SimpleType.
func SimpleType_Values() []SimpleType {
	return []SimpleType{
		SimpleTypeBool,
		SimpleTypeByte,
		SimpleTypeInt8,
		SimpleTypeInt16,
		SimpleTypeInt32,
		SimpleTypeInt64,
		SimpleTypeFloat64,
		SimpleTypeString,
		SimpleTypeStructEmpty,
	}
}

// UnmarshalText tries to decode SimpleType from a byte slice
// containing its name.
//
//   var v SimpleType
//   err := v.UnmarshalText([]byte("BOOL"))
func (v *SimpleType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "BOOL":
		*v = SimpleTypeBool
		return nil
	case "BYTE":
		*v = SimpleTypeByte
		return nil
	case "INT8":
		*v = SimpleTypeInt8
		return nil
	case "INT16":
		*v = SimpleTypeInt16
		return nil
	case "INT32":
		*v = SimpleTypeInt32
		return nil
	case "INT64":
		*v = SimpleTypeInt64
		return nil
	case "FLOAT64":
		*v = SimpleTypeFloat64
		return nil
	case "STRING":
		*v = SimpleTypeString
		return nil
	case "STRUCT_EMPTY":
		*v = SimpleTypeStructEmpty
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "SimpleType", err)
		}
		*v = SimpleType(val)
		return nil
	}
}

// MarshalText encodes SimpleType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v SimpleType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("BOOL"), nil
	case 2:
		return []byte("BYTE"), nil
	case 3:
		return []byte("INT8"), nil
	case 4:
		return []byte("INT16"), nil
	case 5:
		return []byte("INT32"), nil
	case 6:
		return []byte("INT64"), nil
	case 7:
		return []byte("FLOAT64"), nil
	case 8:
		return []byte("STRING"), nil
	case 9:
		return []byte("STRUCT_EMPTY"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SimpleType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v SimpleType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "BOOL")
	case 2:
		enc.AddString("name", "BYTE")
	case 3:
		enc.AddString("name", "INT8")
	case 4:
		enc.AddString("name", "INT16")
	case 5:
		enc.AddString("name", "INT32")
	case 6:
		enc.AddString("name", "INT64")
	case 7:
		enc.AddString("name", "FLOAT64")
	case 8:
		enc.AddString("name", "STRING")
	case 9:
		enc.AddString("name", "STRUCT_EMPTY")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v SimpleType) Ptr() *SimpleType {
	return &v
}

// ToWire translates SimpleType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v SimpleType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes SimpleType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return SimpleType(0), err
//   }
//
//   var v SimpleType
//   if err := v.FromWire(x); err != nil {
//     return SimpleType(0), err
//   }
//   return v, nil
func (v *SimpleType) FromWire(w wire.Value) error {
	*v = (SimpleType)(w.GetI32())
	return nil
}

// String returns a readable string representation of SimpleType.
func (v SimpleType) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "BOOL"
	case 2:
		return "BYTE"
	case 3:
		return "INT8"
	case 4:
		return "INT16"
	case 5:
		return "INT32"
	case 6:
		return "INT64"
	case 7:
		return "FLOAT64"
	case 8:
		return "STRING"
	case 9:
		return "STRUCT_EMPTY"
	}
	return fmt.Sprintf("SimpleType(%d)", w)
}

// Equals returns true if this SimpleType value matches the provided
// value.
func (v SimpleType) Equals(rhs SimpleType) bool {
	return v == rhs
}

// MarshalJSON serializes SimpleType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v SimpleType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"BOOL\""), nil
	case 2:
		return ([]byte)("\"BYTE\""), nil
	case 3:
		return ([]byte)("\"INT8\""), nil
	case 4:
		return ([]byte)("\"INT16\""), nil
	case 5:
		return ([]byte)("\"INT32\""), nil
	case 6:
		return ([]byte)("\"INT64\""), nil
	case 7:
		return ([]byte)("\"FLOAT64\""), nil
	case 8:
		return ([]byte)("\"STRING\""), nil
	case 9:
		return ([]byte)("\"STRUCT_EMPTY\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode SimpleType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *SimpleType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "SimpleType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "SimpleType")
		}
		*v = (SimpleType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "SimpleType")
	}
}

// Type is a reference to a Go type which may be native or user defined.
type Type struct {
	SimpleType *SimpleType `json:"simpleType,omitempty"`
	// Slice of a type
	//
	// []$sliceType
	SliceType *Type `json:"sliceType,omitempty"`
	// Slice of key-value pairs of a pair of types.
	//
	// []struct{Key $left, Value $right}
	KeyValueSliceType *TypePair `json:"keyValueSliceType,omitempty"`
	// Map of a pair of types.
	//
	// map[$left]$right
	MapType *TypePair `json:"mapType,omitempty"`
	// Reference to a user-defined type.
	ReferenceType *TypeReference `json:"referenceType,omitempty"`
	// Pointer to a type.
	PointerType *Type `json:"pointerType,omitempty"`
}

// ToWire translates a Type struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Type) ToWire() (wire.Value, error) {
	i := 0
	if v.SimpleType != nil {
		i++
	}
	if v.SliceType != nil {
		i++
	}
	if v.KeyValueSliceType != nil {
		i++
	}
	if v.MapType != nil {
		i++
	}
	if v.ReferenceType != nil {
		i++
	}
	if v.PointerType != nil {
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Type should have exactly one field: got %v fields", i)
	}

	return wire.NewValueFieldList((*_fieldList_Type)(v)), nil
}

type _fieldList_Type Type

func (fl *_fieldList_Type) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*Type)(fl)
		w   wire.Value
		err error
	)

	if v.SimpleType != nil {
		w, err = v.SimpleType.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
			return err
		}
	}
	if v.SliceType != nil {
		w, err = v.SliceType.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
			return err
		}
	}
	if v.KeyValueSliceType != nil {
		w, err = v.KeyValueSliceType.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 3, Value: w}); err != nil {
			return err
		}
	}
	if v.MapType != nil {
		w, err = v.MapType.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 4, Value: w}); err != nil {
			return err
		}
	}
	if v.ReferenceType != nil {
		w, err = v.ReferenceType.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 5, Value: w}); err != nil {
			return err
		}
	}
	if v.PointerType != nil {
		w, err = v.PointerType.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 6, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_Type) Close() {}

func _SimpleType_Read(w wire.Value) (SimpleType, error) {
	var v SimpleType
	err := v.FromWire(w)
	return v, err
}

func _TypePair_Read(w wire.Value) (*TypePair, error) {
	var v TypePair
	err := v.FromWire(w)
	return &v, err
}

func _TypeReference_Read(w wire.Value) (*TypeReference, error) {
	var v TypeReference
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Type struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Type struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Type
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Type) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x SimpleType
				x, err = _SimpleType_Read(field.Value)
				v.SimpleType = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.SliceType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.KeyValueSliceType, err = _TypePair_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.MapType, err = _TypePair_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TStruct {
				v.ReferenceType, err = _TypeReference_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TStruct {
				v.PointerType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	count := 0
	if v.SimpleType != nil {
		count++
	}
	if v.SliceType != nil {
		count++
	}
	if v.KeyValueSliceType != nil {
		count++
	}
	if v.MapType != nil {
		count++
	}
	if v.ReferenceType != nil {
		count++
	}
	if v.PointerType != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Type should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Type
// struct.
func (v *Type) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.SimpleType != nil {
		fields[i] = fmt.Sprintf("SimpleType: %v", *(v.SimpleType))
		i++
	}
	if v.SliceType != nil {
		fields[i] = fmt.Sprintf("SliceType: %v", v.SliceType)
		i++
	}
	if v.KeyValueSliceType != nil {
		fields[i] = fmt.Sprintf("KeyValueSliceType: %v", v.KeyValueSliceType)
		i++
	}
	if v.MapType != nil {
		fields[i] = fmt.Sprintf("MapType: %v", v.MapType)
		i++
	}
	if v.ReferenceType != nil {
		fields[i] = fmt.Sprintf("ReferenceType: %v", v.ReferenceType)
		i++
	}
	if v.PointerType != nil {
		fields[i] = fmt.Sprintf("PointerType: %v", v.PointerType)
		i++
	}

	return fmt.Sprintf("Type{%v}", strings.Join(fields[:i], ", "))
}

func _SimpleType_EqualsPtr(lhs, rhs *SimpleType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Type match the
// provided Type.
//
// This function performs a deep comparison.
func (v *Type) Equals(rhs *Type) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_SimpleType_EqualsPtr(v.SimpleType, rhs.SimpleType) {
		return false
	}
	if !((v.SliceType == nil && rhs.SliceType == nil) || (v.SliceType != nil && rhs.SliceType != nil && v.SliceType.Equals(rhs.SliceType))) {
		return false
	}
	if !((v.KeyValueSliceType == nil && rhs.KeyValueSliceType == nil) || (v.KeyValueSliceType != nil && rhs.KeyValueSliceType != nil && v.KeyValueSliceType.Equals(rhs.KeyValueSliceType))) {
		return false
	}
	if !((v.MapType == nil && rhs.MapType == nil) || (v.MapType != nil && rhs.MapType != nil && v.MapType.Equals(rhs.MapType))) {
		return false
	}
	if !((v.ReferenceType == nil && rhs.ReferenceType == nil) || (v.ReferenceType != nil && rhs.ReferenceType != nil && v.ReferenceType.Equals(rhs.ReferenceType))) {
		return false
	}
	if !((v.PointerType == nil && rhs.PointerType == nil) || (v.PointerType != nil && rhs.PointerType != nil && v.PointerType.Equals(rhs.PointerType))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Type.
func (v *Type) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.SimpleType != nil {
		err = multierr.Append(err, enc.AddObject("simpleType", *v.SimpleType))
	}
	if v.SliceType != nil {
		err = multierr.Append(err, enc.AddObject("sliceType", v.SliceType))
	}
	if v.KeyValueSliceType != nil {
		err = multierr.Append(err, enc.AddObject("keyValueSliceType", v.KeyValueSliceType))
	}
	if v.MapType != nil {
		err = multierr.Append(err, enc.AddObject("mapType", v.MapType))
	}
	if v.ReferenceType != nil {
		err = multierr.Append(err, enc.AddObject("referenceType", v.ReferenceType))
	}
	if v.PointerType != nil {
		err = multierr.Append(err, enc.AddObject("pointerType", v.PointerType))
	}
	return err
}

// GetSimpleType returns the value of SimpleType if it is set or its
// zero value if it is unset.
func (v *Type) GetSimpleType() (o SimpleType) {
	if v != nil && v.SimpleType != nil {
		return *v.SimpleType
	}

	return
}

// IsSetSimpleType returns true if SimpleType is not nil.
func (v *Type) IsSetSimpleType() bool {
	return v != nil && v.SimpleType != nil
}

// GetSliceType returns the value of SliceType if it is set or its
// zero value if it is unset.
func (v *Type) GetSliceType() (o *Type) {
	if v != nil && v.SliceType != nil {
		return v.SliceType
	}

	return
}

// IsSetSliceType returns true if SliceType is not nil.
func (v *Type) IsSetSliceType() bool {
	return v != nil && v.SliceType != nil
}

// GetKeyValueSliceType returns the value of KeyValueSliceType if it is set or its
// zero value if it is unset.
func (v *Type) GetKeyValueSliceType() (o *TypePair) {
	if v != nil && v.KeyValueSliceType != nil {
		return v.KeyValueSliceType
	}

	return
}

// IsSetKeyValueSliceType returns true if KeyValueSliceType is not nil.
func (v *Type) IsSetKeyValueSliceType() bool {
	return v != nil && v.KeyValueSliceType != nil
}

// GetMapType returns the value of MapType if it is set or its
// zero value if it is unset.
func (v *Type) GetMapType() (o *TypePair) {
	if v != nil && v.MapType != nil {
		return v.MapType
	}

	return
}

// IsSetMapType returns true if MapType is not nil.
func (v *Type) IsSetMapType() bool {
	return v != nil && v.MapType != nil
}

// GetReferenceType returns the value of ReferenceType if it is set or its
// zero value if it is unset.
func (v *Type) GetReferenceType() (o *TypeReference) {
	if v != nil && v.ReferenceType != nil {
		return v.ReferenceType
	}

	return
}

// IsSetReferenceType returns true if ReferenceType is not nil.
func (v *Type) IsSetReferenceType() bool {
	return v != nil && v.ReferenceType != nil
}

// GetPointerType returns the value of PointerType if it is set or its
// zero value if it is unset.
func (v *Type) GetPointerType() (o *Type) {
	if v != nil && v.PointerType != nil {
		return v.PointerType
	}

	return
}

// IsSetPointerType returns true if PointerType is not nil.
func (v *Type) IsSetPointerType() bool {
	return v != nil && v.PointerType != nil
}

// TypePair is a pair of two types.
type TypePair struct {
	Left  *Type `json:"left,required"`
	Right *Type `json:"right,required"`
}

// ToWire translates a TypePair struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TypePair) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_TypePair)(v)), nil
}

type _fieldList_TypePair TypePair

func (fl *_fieldList_TypePair) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*TypePair)(fl)
		w   wire.Value
		err error
	)

	if v.Left == nil {
		return errors.New("field Left of TypePair is required")
	}
	w, err = v.Left.ToWire()
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}
	if v.Right == nil {
		return errors.New("field Right of TypePair is required")
	}
	w, err = v.Right.ToWire()
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
		return err
	}

	return nil
}

func (fl *_fieldList_TypePair) Close() {}

// FromWire deserializes a TypePair struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TypePair struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TypePair
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TypePair) FromWire(w wire.Value) error {

	leftIsSet := false
	rightIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Left, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				leftIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Right, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				rightIsSet = true
			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !leftIsSet {
		return errors.New("field Left of TypePair is required")
	}

	if !rightIsSet {
		return errors.New("field Right of TypePair is required")
	}

	return nil
}

// String returns a readable string representation of a TypePair
// struct.
func (v *TypePair) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Left: %v", v.Left)
	i++
	fields[i] = fmt.Sprintf("Right: %v", v.Right)
	i++

	return fmt.Sprintf("TypePair{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TypePair match the
// provided TypePair.
//
// This function performs a deep comparison.
func (v *TypePair) Equals(rhs *TypePair) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Left.Equals(rhs.Left) {
		return false
	}
	if !v.Right.Equals(rhs.Right) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TypePair.
func (v *TypePair) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("left", v.Left))
	err = multierr.Append(err, enc.AddObject("right", v.Right))
	return err
}

// GetLeft returns the value of Left if it is set or its
// zero value if it is unset.
func (v *TypePair) GetLeft() (o *Type) {
	if v != nil {
		o = v.Left
	}
	return
}

// IsSetLeft returns true if Left is not nil.
func (v *TypePair) IsSetLeft() bool {
	return v != nil && v.Left != nil
}

// GetRight returns the value of Right if it is set or its
// zero value if it is unset.
func (v *TypePair) GetRight() (o *Type) {
	if v != nil {
		o = v.Right
	}
	return
}

// IsSetRight returns true if Right is not nil.
func (v *TypePair) IsSetRight() bool {
	return v != nil && v.Right != nil
}

// TypeReference is a reference to a user-defined type.
type TypeReference struct {
	Name string `json:"name,required"`
	// Import path for the package defining this type.
	ImportPath string `json:"importPath,required"`
	// Annotations defined on this type.
	//
	// Note that these are the Thrift annotations listed after the type
	// declaration in the Thrift file.
	//
	// Given,
	//
	//   struct User {
	//     1: required i32 id
	//     2: required string name
	//   } (key = "id", validate)
	//
	// The annotations will be,
	//
	//   {
	//     "key": "id",
	//     "validate": "",
	//   }
	Annotations map[string]string `json:"annotations,omitempty"`
}

// ToWire translates a TypeReference struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TypeReference) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_TypeReference)(v)), nil
}

type _fieldList_TypeReference TypeReference

func (fl *_fieldList_TypeReference) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*TypeReference)(fl)
		w   wire.Value
		err error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
		return err
	}

	w, err = wire.NewValueString(v.ImportPath), error(nil)
	if err != nil {
		return err
	}
	if err := writeField(wire.Field{ID: 2, Value: w}); err != nil {
		return err
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 3, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_TypeReference) Close() {}

// FromWire deserializes a TypeReference struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TypeReference struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TypeReference
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TypeReference) FromWire(w wire.Value) error {

	nameIsSet := false
	importPathIsSet := false

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.ImportPath, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				importPathIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	if !nameIsSet {
		return errors.New("field Name of TypeReference is required")
	}

	if !importPathIsSet {
		return errors.New("field ImportPath of TypeReference is required")
	}

	return nil
}

// String returns a readable string representation of a TypeReference
// struct.
func (v *TypeReference) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("ImportPath: %v", v.ImportPath)
	i++
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}

	return fmt.Sprintf("TypeReference{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TypeReference match the
// provided TypeReference.
//
// This function performs a deep comparison.
func (v *TypeReference) Equals(rhs *TypeReference) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.ImportPath == rhs.ImportPath) {
		return false
	}
	if !((v.Annotations == nil && rhs.Annotations == nil) || (v.Annotations != nil && rhs.Annotations != nil && _Map_String_String_Equals(v.Annotations, rhs.Annotations))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TypeReference.
func (v *TypeReference) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	enc.AddString("importPath", v.ImportPath)
	if v.Annotations != nil {
		err = multierr.Append(err, enc.AddObject("annotations", (_Map_String_String_Zapper)(v.Annotations)))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *TypeReference) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetImportPath returns the value of ImportPath if it is set or its
// zero value if it is unset.
func (v *TypeReference) GetImportPath() (o string) {
	if v != nil {
		o = v.ImportPath
	}
	return
}

// GetAnnotations returns the value of Annotations if it is set or its
// zero value if it is unset.
func (v *TypeReference) GetAnnotations() (o map[string]string) {
	if v != nil && v.Annotations != nil {
		return v.Annotations
	}

	return
}

// IsSetAnnotations returns true if Annotations is not nil.
func (v *TypeReference) IsSetAnnotations() bool {
	return v != nil && v.Annotations != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "api",
	Package:  "go.uber.org/thriftrw/plugin/api",
	FilePath: "api.thrift",
	SHA1:     "f7eeea00e3002a17188f595c7117b9359ab244d3",
	Raw:      rawIDL,
}

const rawIDL = "/**\n * API_VERSION is the version of the plugin API.\n *\n * This MUST be provided in the HandshakeResponse.\n */\nconst i32 API_VERSION = 4\n\n/**\n * ServiceID is an arbitrary unique identifier to reference the different\n * services in this request.\n */\ntypedef i32 ServiceID\n\n/**\n * ModuleID is an arbitrary unique identifier to reference the different\n * modules in this request.\n */\ntypedef i32 ModuleID\n\n/**\n * TypeReference is a reference to a user-defined type.\n */\nstruct TypeReference {\n    1: required string name\n    /**\n     * Import path for the package defining this type.\n     */\n    2: required string importPath\n\n    /**\n     * Annotations defined on this type.\n     *\n     * Note that these are the Thrift annotations listed after the type\n     * declaration in the Thrift file.\n     *\n     * Given,\n     *\n     *   struct User {\n     *     1: required i32 id\n     *     2: required string name\n     *   } (key = \"id\", validate)\n     *\n     * The annotations will be,\n     *\n     *   {\n     *     \"key\": \"id\",\n     *     \"validate\": \"\",\n     *   }\n     */\n    3: optional map<string, string> annotations\n\n    // TODO(abg): Should this just be using ModuleID instead of a package?\n}\n\n/**\n * SimpleType is a standalone native Go type.\n */\nenum SimpleType {\n    BOOL = 1,     // bool\n    BYTE,         // byte\n    INT8,         // int8\n    INT16,        // int16\n    INT32,        // int32\n    INT64,        // int64\n    FLOAT64,      // float64\n    STRING,       // string\n    STRUCT_EMPTY, // struct{}\n}\n\n/**\n * TypePair is a pair of two types.\n */\nstruct TypePair {\n    1: required Type left\n    2: required Type right\n}\n\n/**\n * Type is a reference to a Go type which may be native or user defined.\n */\nunion Type {\n    1: SimpleType simpleType\n    /**\n     * Slice of a type\n     *\n     * []$sliceType\n     */\n    2: Type sliceType\n    /**\n     * Slice of key-value pairs of a pair of types.\n     *\n     * []struct{Key $left, Value $right}\n     */\n    3: TypePair keyValueSliceType\n    /**\n     * Map of a pair of types.\n     *\n     * map[$left]$right\n     */\n    4: TypePair mapType\n    /**\n     * Reference to a user-defined type.\n     */\n    5: TypeReference referenceType\n    /**\n     * Pointer to a type.\n     */\n    6: Type pointerType\n}\n\n/**\n * Argument is a single Argument inside a Function.\n * For,\n *\n *      void setValue(1: string key, 2: string value)\n *\n * You get the arguments,\n *\n *      Argument{Name: \"Key\", Type: Type{SimpleType: SimpleTypeString}}\n *\n *      Argument{Name: \"Value\", Type: Type{SimpleType: SimpleTypeString}}\n */\nstruct Argument {\n    /**\n     * Name of the argument. This is also the name of the argument field\n     * inside the args/result struct for that function.\n     */\n    1: required string name\n    /**\n     * Argument type.\n     */\n    2: required Type type\n    /**\n     * Annotations defined on this argument.\n     *\n     * Given,\n     *\n     *   void setValue(\n     *     1: SetValueRequest req\n     *   ) throws (\n     *     1: BadRequestError badRequestError (cache = \"false\")\n     *   )\n     *\n     * The annotations for the Argument representing badRequestError will be,\n     *\n     *  {\n     *    \"cache\": \"false\",\n     *  }\n     */\n    3: optional map<string, string> annotations;\n}\n\n/**\n * Function is a single function on a Thrift service.\n */\nstruct Function {\n    /**\n     * Name of the Go function.\n     */\n    1: required string name\n    /**\n     * Name of the function as defined in the Thrift file.\n     */\n    2: required string thriftName\n    /**\n     * List of arguments accepted by the function.\n     *\n     * This list is in the order specified by the user in the Thrift file.\n     */\n    3: required list<Argument> arguments\n    /**\n     * Return type of the function, if any. If this is not set, the function\n     * is a void function.\n     */\n    4: optional Type returnType\n    /**\n     * List of exceptions raised by the function.\n     *\n     * This list is in the order specified by the user in the Thrift file.\n     */\n    5: optional list<Argument> exceptions\n    /**\n     * Whether this function is oneway or not. This should be assumed to be\n     * false unless explicitly stated otherwise. If this is true, the\n     * returnType and exceptions will be null or empty.\n     */\n    6: optional bool oneWay\n    /**\n     * Annotations defined on this function.\n     *\n     * Given,\n     *\n     *   void setValue(1: SetValueRequest req) (cache = \"false\")\n     *\n     * The annotations will be,\n     *\n     *  {\n     *    \"cache\": \"false\",\n     *  }\n     */\n    7: optional map<string, string> annotations;\n}\n\n/**\n * Service is a service defined by the user in the Thrift file.\n */\nstruct Service {\n    /**\n     * Name of the Thrift service in Go code.\n     */\n    7: required string name\n    /**\n     * Name of the service as defined in the Thrift file.\n     */\n    1: required string thriftName\n    /**\n     * ID of the parent service.\n     */\n    4: optional ServiceID parentID\n    /**\n     * List of functions defined for this service.\n     */\n    5: required list<Function> functions\n    /**\n     * ID of the module where this service was declared.\n     */\n    6: required ModuleID moduleID\n    /**\n     * Annotations defined on this service.\n     *\n     * Given,\n     *\n     *   service KeyValue {\n     *   } (private = \"true\")\n     *\n     * The annotations will be,\n     *\n     *  {\n     *    \"private\": \"true\",\n     *  }\n     */\n    8: optional map<string, string> annotations;\n}\n\n/**\n * Module is a module generated from a single Thrift file. Each module\n * corresponds to exactly one Thrift file and contains all the types and\n * constants defined in that Thrift file.\n */\nstruct Module {\n    /**\n     * Import path for the package defining the types for this module.\n     */\n    1: required string importPath\n    /**\n     * Path to the directory containing the code for this module.\n     *\n     * The path is relative to the output directory into which ThriftRW is\n     * generating code. Plugins SHOULD NOT make any assumptions about the\n     * absolute location of the directory.\n     */\n    2: required string directory\n    /**\n     * Path to the Thrift file from which this module was generated.\n     */\n    3: required string thriftFilePath\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Feature is a functionality offered by a ThriftRW plugin.\n */\nenum Feature {\n    /**\n     * SERVICE_GENERATOR specifies that the plugin may generate arbitrary code\n     * for services defined in the Thrift file.\n     *\n     * If a plugin provides this, it MUST implement the ServiceGenerator\n     * service.\n     */\n    SERVICE_GENERATOR = 1,\n\n    // TODO: TAGGER for struct-tagging plugins\n}\n\n/**\n * HandshakeRequest is the initial request sent to the plugin as part of\n * establishing communication and feature negotiation.\n */\nstruct HandshakeRequest {\n}\n\n/**\n * HandshakeResponse is the response from the plugin for a HandshakeRequest.\n */\nstruct HandshakeResponse {\n    /**\n     * Name of the plugin. This MUST match the name of the plugin specified\n     * over the command line or the program will fail.\n     */\n    1: required string name\n    /**\n     * Version of the plugin API.\n     *\n     * This MUST be set to API_VERSION by the plugin.\n     */\n    2: required i32 apiVersion (go.name = \"APIVersion\")\n    /**\n     * List of features the plugin provides.\n     */\n    3: required list<Feature> features\n    /**\n     * Version of ThriftRW with which the plugin was built.\n     *\n     * This MUST be set to go.uber.org/thriftrw/version.Version by the plugin\n     * explicitly.\n     */\n    4: optional string libraryVersion\n}\n\nservice Plugin {\n    /**\n     * handshake performs a handshake with the plugin to negotiate the\n     * features provided by it and the version of the plugin API it expects.\n     */\n    HandshakeResponse handshake(1: HandshakeRequest request)\n\n    /**\n     * Informs the plugin process that it will not receive any more requests\n     * and it is safe for it to exit.\n     */\n    void goodbye()\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * GenerateServiceRequest is a request to generate code for zero or more\n * Thrift services.\n */\nstruct GenerateServiceRequest {\n    /**\n     * IDs of services for which code should be generated.\n     *\n     * Note that the services map contains information about both, the\n     * services being generated and their transitive dependencies. Code should\n     * only be generated for service IDs listed here.\n     */\n    1: required list<ServiceID> rootServices\n    /**\n     * Map of service ID to service.\n     *\n     * Any service IDs present in this request will have a corresponding\n     * service definition in this map, including services for which code does\n     * not need to be generated.\n     */\n    2: required map<ServiceID, Service> services\n    /**\n     * Map of module ID to module.\n     *\n     * Any module IDs present in the request will have a corresponding module\n     * definition in this map.\n     */\n    3: required map<ModuleID, Module> modules\n    /**\n     * Prefix for import paths of generated module. In general, plugins should\n     * not need to use the package prefix unless instantiating a new\n     * Generator for more custom plugin generation.\n     */\n    4: required string packagePrefix\n    /**\n     * Directory whose descendants contain all Thrift files. In general,\n     * plugins should not need to use the thrift root unless instantiating a\n     * new Generator for more custom plugin generation.\n     */\n    5: required string thriftRoot\n    /**\n     *  IDs of Modules for which code should be generated.\n     *\n     *  Note that the modules map contains information about both, the\n     *  modules being generated and their transitive dependencies. Code should\n     *  only be generated for module IDs listed here.\n     */\n    6: optional list<ModuleID> rootModules\n}\n\n/**\n * GenerateServiceResponse is response to a GenerateServiceRequest.\n */\nstruct GenerateServiceResponse {\n    /**\n     * Map of file path to file contents.\n     *\n     * All paths MUST be relative to the output directory into which ThriftRW\n     * is generating code. Plugins SHOULD NOT make any assumptions about the\n     * absolute location of the directory.\n     *\n     * The paths MUST NOT contain the string \"..\" or the request will fail.\n     */\n    1: optional map<string, binary> files\n}\n\n/**\n * ServiceGenerator generates arbitrary code for services.\n *\n * This MUST be implemented if the SERVICE_GENERATOR feature is enabled.\n */\nservice ServiceGenerator {\n    /**\n     * Generates code for requested services.\n     */\n    GenerateServiceResponse generate(1: GenerateServiceRequest request)\n}\n"

// Plugin_Goodbye_Args represents the arguments for the Plugin.goodbye function.
//
// The arguments for goodbye are sent and received over the wire as this struct.
type Plugin_Goodbye_Args struct {
}

// ToWire translates a Plugin_Goodbye_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Plugin_Goodbye_Args) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_Plugin_Goodbye_Args)(v)), nil
}

type _fieldList_Plugin_Goodbye_Args Plugin_Goodbye_Args

func (fl *_fieldList_Plugin_Goodbye_Args) ForEach(writeField func(wire.Field) error) error {

	return nil
}

func (fl *_fieldList_Plugin_Goodbye_Args) Close() {}

// FromWire deserializes a Plugin_Goodbye_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Plugin_Goodbye_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Plugin_Goodbye_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Plugin_Goodbye_Args) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	return nil
}

// String returns a readable string representation of a Plugin_Goodbye_Args
// struct.
func (v *Plugin_Goodbye_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Plugin_Goodbye_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Plugin_Goodbye_Args match the
// provided Plugin_Goodbye_Args.
//
// This function performs a deep comparison.
func (v *Plugin_Goodbye_Args) Equals(rhs *Plugin_Goodbye_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Plugin_Goodbye_Args.
func (v *Plugin_Goodbye_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "goodbye" for this struct.
func (v *Plugin_Goodbye_Args) MethodName() string {
	return "goodbye"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Plugin_Goodbye_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Plugin_Goodbye_Helper provides functions that aid in handling the
// parameters and return values of the Plugin.goodbye
// function.
var Plugin_Goodbye_Helper = struct {
	// Args accepts the parameters of goodbye in-order and returns
	// the arguments struct for the function.
	Args func() *Plugin_Goodbye_Args

	// IsException returns true if the given error can be thrown
	// by goodbye.
	//
	// An error can be thrown by goodbye only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for goodbye
	// given the error returned by it. The provided error may
	// be nil if goodbye did not fail.
	//
	// This allows mapping errors returned by goodbye into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// goodbye
	//
	//   err := goodbye(args)
	//   result, err := Plugin_Goodbye_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from goodbye: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Plugin_Goodbye_Result, error)

	// UnwrapResponse takes the result struct for goodbye
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if goodbye threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Plugin_Goodbye_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Plugin_Goodbye_Result) error
}{}

func init() {
	Plugin_Goodbye_Helper.Args = func() *Plugin_Goodbye_Args {
		return &Plugin_Goodbye_Args{}
	}

	Plugin_Goodbye_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Plugin_Goodbye_Helper.WrapResponse = func(err error) (*Plugin_Goodbye_Result, error) {
		if err == nil {
			return &Plugin_Goodbye_Result{}, nil
		}

		return nil, err
	}
	Plugin_Goodbye_Helper.UnwrapResponse = func(result *Plugin_Goodbye_Result) (err error) {
		return
	}

}

// Plugin_Goodbye_Result represents the result of a Plugin.goodbye function call.
//
// The result of a goodbye execution is sent and received over the wire as this struct.
type Plugin_Goodbye_Result struct {
}

// ToWire translates a Plugin_Goodbye_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Plugin_Goodbye_Result) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_Plugin_Goodbye_Result)(v)), nil
}

type _fieldList_Plugin_Goodbye_Result Plugin_Goodbye_Result

func (fl *_fieldList_Plugin_Goodbye_Result) ForEach(writeField func(wire.Field) error) error {

	return nil
}

func (fl *_fieldList_Plugin_Goodbye_Result) Close() {}

// FromWire deserializes a Plugin_Goodbye_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Plugin_Goodbye_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Plugin_Goodbye_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Plugin_Goodbye_Result) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	return nil
}

// String returns a readable string representation of a Plugin_Goodbye_Result
// struct.
func (v *Plugin_Goodbye_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Plugin_Goodbye_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Plugin_Goodbye_Result match the
// provided Plugin_Goodbye_Result.
//
// This function performs a deep comparison.
func (v *Plugin_Goodbye_Result) Equals(rhs *Plugin_Goodbye_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Plugin_Goodbye_Result.
func (v *Plugin_Goodbye_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "goodbye" for this struct.
func (v *Plugin_Goodbye_Result) MethodName() string {
	return "goodbye"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Plugin_Goodbye_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Plugin_Handshake_Args represents the arguments for the Plugin.handshake function.
//
// The arguments for handshake are sent and received over the wire as this struct.
type Plugin_Handshake_Args struct {
	Request *HandshakeRequest `json:"request,omitempty"`
}

// ToWire translates a Plugin_Handshake_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Plugin_Handshake_Args) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_Plugin_Handshake_Args)(v)), nil
}

type _fieldList_Plugin_Handshake_Args Plugin_Handshake_Args

func (fl *_fieldList_Plugin_Handshake_Args) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*Plugin_Handshake_Args)(fl)
		w   wire.Value
		err error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_Plugin_Handshake_Args) Close() {}

func _HandshakeRequest_Read(w wire.Value) (*HandshakeRequest, error) {
	var v HandshakeRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Plugin_Handshake_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Plugin_Handshake_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Plugin_Handshake_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Plugin_Handshake_Args) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _HandshakeRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	return nil
}

// String returns a readable string representation of a Plugin_Handshake_Args
// struct.
func (v *Plugin_Handshake_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Plugin_Handshake_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Plugin_Handshake_Args match the
// provided Plugin_Handshake_Args.
//
// This function performs a deep comparison.
func (v *Plugin_Handshake_Args) Equals(rhs *Plugin_Handshake_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Plugin_Handshake_Args.
func (v *Plugin_Handshake_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Plugin_Handshake_Args) GetRequest() (o *HandshakeRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Plugin_Handshake_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "handshake" for this struct.
func (v *Plugin_Handshake_Args) MethodName() string {
	return "handshake"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Plugin_Handshake_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Plugin_Handshake_Helper provides functions that aid in handling the
// parameters and return values of the Plugin.handshake
// function.
var Plugin_Handshake_Helper = struct {
	// Args accepts the parameters of handshake in-order and returns
	// the arguments struct for the function.
	Args func(
		request *HandshakeRequest,
	) *Plugin_Handshake_Args

	// IsException returns true if the given error can be thrown
	// by handshake.
	//
	// An error can be thrown by handshake only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for handshake
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// handshake into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by handshake
	//
	//   value, err := handshake(args)
	//   result, err := Plugin_Handshake_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from handshake: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*HandshakeResponse, error) (*Plugin_Handshake_Result, error)

	// UnwrapResponse takes the result struct for handshake
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if handshake threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Plugin_Handshake_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Plugin_Handshake_Result) (*HandshakeResponse, error)
}{}

func init() {
	Plugin_Handshake_Helper.Args = func(
		request *HandshakeRequest,
	) *Plugin_Handshake_Args {
		return &Plugin_Handshake_Args{
			Request: request,
		}
	}

	Plugin_Handshake_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Plugin_Handshake_Helper.WrapResponse = func(success *HandshakeResponse, err error) (*Plugin_Handshake_Result, error) {
		if err == nil {
			return &Plugin_Handshake_Result{Success: success}, nil
		}

		return nil, err
	}
	Plugin_Handshake_Helper.UnwrapResponse = func(result *Plugin_Handshake_Result) (success *HandshakeResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Plugin_Handshake_Result represents the result of a Plugin.handshake function call.
//
// The result of a handshake execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Plugin_Handshake_Result struct {
	// Value returned by handshake after a successful execution.
	Success *HandshakeResponse `json:"success,omitempty"`
}

// ToWire translates a Plugin_Handshake_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Plugin_Handshake_Result) ToWire() (wire.Value, error) {
	i := 0
	if v.Success != nil {
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Plugin_Handshake_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueFieldList((*_fieldList_Plugin_Handshake_Result)(v)), nil
}

type _fieldList_Plugin_Handshake_Result Plugin_Handshake_Result

func (fl *_fieldList_Plugin_Handshake_Result) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*Plugin_Handshake_Result)(fl)
		w   wire.Value
		err error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 0, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_Plugin_Handshake_Result) Close() {}

func _HandshakeResponse_Read(w wire.Value) (*HandshakeResponse, error) {
	var v HandshakeResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Plugin_Handshake_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Plugin_Handshake_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Plugin_Handshake_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Plugin_Handshake_Result) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _HandshakeResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Plugin_Handshake_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Plugin_Handshake_Result
// struct.
func (v *Plugin_Handshake_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Plugin_Handshake_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Plugin_Handshake_Result match the
// provided Plugin_Handshake_Result.
//
// This function performs a deep comparison.
func (v *Plugin_Handshake_Result) Equals(rhs *Plugin_Handshake_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Plugin_Handshake_Result.
func (v *Plugin_Handshake_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Plugin_Handshake_Result) GetSuccess() (o *HandshakeResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Plugin_Handshake_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "handshake" for this struct.
func (v *Plugin_Handshake_Result) MethodName() string {
	return "handshake"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Plugin_Handshake_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ServiceGenerator_Generate_Args represents the arguments for the ServiceGenerator.generate function.
//
// The arguments for generate are sent and received over the wire as this struct.
type ServiceGenerator_Generate_Args struct {
	Request *GenerateServiceRequest `json:"request,omitempty"`
}

// ToWire translates a ServiceGenerator_Generate_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ServiceGenerator_Generate_Args) ToWire() (wire.Value, error) {
	return wire.NewValueFieldList((*_fieldList_ServiceGenerator_Generate_Args)(v)), nil
}

type _fieldList_ServiceGenerator_Generate_Args ServiceGenerator_Generate_Args

func (fl *_fieldList_ServiceGenerator_Generate_Args) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*ServiceGenerator_Generate_Args)(fl)
		w   wire.Value
		err error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 1, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_ServiceGenerator_Generate_Args) Close() {}

func _GenerateServiceRequest_Read(w wire.Value) (*GenerateServiceRequest, error) {
	var v GenerateServiceRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ServiceGenerator_Generate_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ServiceGenerator_Generate_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ServiceGenerator_Generate_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ServiceGenerator_Generate_Args) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _GenerateServiceRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	return nil
}

// String returns a readable string representation of a ServiceGenerator_Generate_Args
// struct.
func (v *ServiceGenerator_Generate_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("ServiceGenerator_Generate_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ServiceGenerator_Generate_Args match the
// provided ServiceGenerator_Generate_Args.
//
// This function performs a deep comparison.
func (v *ServiceGenerator_Generate_Args) Equals(rhs *ServiceGenerator_Generate_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ServiceGenerator_Generate_Args.
func (v *ServiceGenerator_Generate_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *ServiceGenerator_Generate_Args) GetRequest() (o *GenerateServiceRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *ServiceGenerator_Generate_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "generate" for this struct.
func (v *ServiceGenerator_Generate_Args) MethodName() string {
	return "generate"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ServiceGenerator_Generate_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ServiceGenerator_Generate_Helper provides functions that aid in handling the
// parameters and return values of the ServiceGenerator.generate
// function.
var ServiceGenerator_Generate_Helper = struct {
	// Args accepts the parameters of generate in-order and returns
	// the arguments struct for the function.
	Args func(
		request *GenerateServiceRequest,
	) *ServiceGenerator_Generate_Args

	// IsException returns true if the given error can be thrown
	// by generate.
	//
	// An error can be thrown by generate only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for generate
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// generate into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by generate
	//
	//   value, err := generate(args)
	//   result, err := ServiceGenerator_Generate_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from generate: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*GenerateServiceResponse, error) (*ServiceGenerator_Generate_Result, error)

	// UnwrapResponse takes the result struct for generate
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if generate threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ServiceGenerator_Generate_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ServiceGenerator_Generate_Result) (*GenerateServiceResponse, error)
}{}

func init() {
	ServiceGenerator_Generate_Helper.Args = func(
		request *GenerateServiceRequest,
	) *ServiceGenerator_Generate_Args {
		return &ServiceGenerator_Generate_Args{
			Request: request,
		}
	}

	ServiceGenerator_Generate_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ServiceGenerator_Generate_Helper.WrapResponse = func(success *GenerateServiceResponse, err error) (*ServiceGenerator_Generate_Result, error) {
		if err == nil {
			return &ServiceGenerator_Generate_Result{Success: success}, nil
		}

		return nil, err
	}
	ServiceGenerator_Generate_Helper.UnwrapResponse = func(result *ServiceGenerator_Generate_Result) (success *GenerateServiceResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ServiceGenerator_Generate_Result represents the result of a ServiceGenerator.generate function call.
//
// The result of a generate execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ServiceGenerator_Generate_Result struct {
	// Value returned by generate after a successful execution.
	Success *GenerateServiceResponse `json:"success,omitempty"`
}

// ToWire translates a ServiceGenerator_Generate_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ServiceGenerator_Generate_Result) ToWire() (wire.Value, error) {
	i := 0
	if v.Success != nil {
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ServiceGenerator_Generate_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueFieldList((*_fieldList_ServiceGenerator_Generate_Result)(v)), nil
}

type _fieldList_ServiceGenerator_Generate_Result ServiceGenerator_Generate_Result

func (fl *_fieldList_ServiceGenerator_Generate_Result) ForEach(writeField func(wire.Field) error) error {
	var (
		v   = (*ServiceGenerator_Generate_Result)(fl)
		w   wire.Value
		err error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return err
		}
		if err := writeField(wire.Field{ID: 0, Value: w}); err != nil {
			return err
		}
	}

	return nil
}

func (fl *_fieldList_ServiceGenerator_Generate_Result) Close() {}

func _GenerateServiceResponse_Read(w wire.Value) (*GenerateServiceResponse, error) {
	var v GenerateServiceResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ServiceGenerator_Generate_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ServiceGenerator_Generate_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ServiceGenerator_Generate_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ServiceGenerator_Generate_Result) FromWire(w wire.Value) error {

	fields := w.GetFieldList()
	err := fields.ForEach(func(field wire.Field) (err error) {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _GenerateServiceResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	fields.Close()

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ServiceGenerator_Generate_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ServiceGenerator_Generate_Result
// struct.
func (v *ServiceGenerator_Generate_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ServiceGenerator_Generate_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ServiceGenerator_Generate_Result match the
// provided ServiceGenerator_Generate_Result.
//
// This function performs a deep comparison.
func (v *ServiceGenerator_Generate_Result) Equals(rhs *ServiceGenerator_Generate_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ServiceGenerator_Generate_Result.
func (v *ServiceGenerator_Generate_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ServiceGenerator_Generate_Result) GetSuccess() (o *GenerateServiceResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ServiceGenerator_Generate_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "generate" for this struct.
func (v *ServiceGenerator_Generate_Result) MethodName() string {
	return "generate"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ServiceGenerator_Generate_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}
