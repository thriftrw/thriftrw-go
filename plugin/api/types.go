// Code generated by thriftrw v1.11.0. DO NOT EDIT.
// @generated

// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package api

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go.uber.org/thriftrw/wire"
	"math"
	"strconv"
	"strings"
)

// Argument is a single Argument inside a Function.
// For,
//
//      void setValue(1: string key, 2: string value)
//
// You get the arguments,
//
//      Argument{Name: "Key", Type: Type{SimpleType: SimpleTypeString}}
//
//      Argument{Name: "Value", Type: Type{SimpleType: SimpleTypeString}}
type Argument struct {
	// Name of the argument. This is also the name of the argument field
	// inside the args/result struct for that function.
	Name string `json:"name,required"`
	// Argument type.
	Type *Type `json:"type,required"`
}

// ToWire translates a Argument struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Argument) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Type == nil {
		return w, errors.New("field Type of Argument is required")
	}
	w, err = v.Type.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Type_Read(w wire.Value) (*Type, error) {
	var v Type
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Argument struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Argument struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Argument
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Argument) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false
	typeIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Type, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				typeIsSet = true
			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of Argument is required")
	}

	if !typeIsSet {
		return errors.New("field Type of Argument is required")
	}

	return nil
}

// String returns a readable string representation of a Argument
// struct.
func (v *Argument) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("Type: %v", v.Type)
	i++

	return fmt.Sprintf("Argument{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Argument match the
// provided Argument.
//
// This function performs a deep comparison.
func (v *Argument) Equals(rhs *Argument) bool {
	if !(v.Name == rhs.Name) {
		return false
	}
	if !v.Type.Equals(rhs.Type) {
		return false
	}

	return true
}

// Feature is a functionality offered by a ThriftRW plugin.
type Feature int32

const (
	// SERVICE_GENERATOR specifies that the plugin may generate arbitrary code
	// for services defined in the Thrift file.
	//
	// If a plugin provides this, it MUST implement the ServiceGenerator
	// service.
	FeatureServiceGenerator Feature = 1
)

// Feature_Values returns all recognized values of Feature.
func Feature_Values() []Feature {
	return []Feature{
		FeatureServiceGenerator,
	}
}

// UnmarshalText tries to decode Feature from a byte slice
// containing its name.
//
//   var v Feature
//   err := v.UnmarshalText([]byte("SERVICE_GENERATOR"))
func (v *Feature) UnmarshalText(value []byte) error {
	switch string(value) {
	case "SERVICE_GENERATOR":
		*v = FeatureServiceGenerator
		return nil
	default:
		return fmt.Errorf("unknown enum value %q for %q", value, "Feature")
	}
}

// Ptr returns a pointer to this enum value.
func (v Feature) Ptr() *Feature {
	return &v
}

// ToWire translates Feature into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Feature) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Feature from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Feature(0), err
//   }
//
//   var v Feature
//   if err := v.FromWire(x); err != nil {
//     return Feature(0), err
//   }
//   return v, nil
func (v *Feature) FromWire(w wire.Value) error {
	*v = (Feature)(w.GetI32())
	return nil
}

// String returns a readable string representation of Feature.
func (v Feature) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "SERVICE_GENERATOR"
	}
	return fmt.Sprintf("Feature(%d)", w)
}

// Equals returns true if this Feature value matches the provided
// value.
func (v Feature) Equals(rhs Feature) bool {
	return v == rhs
}

// MarshalJSON serializes Feature into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Feature) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"SERVICE_GENERATOR\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Feature from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Feature) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Feature")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Feature")
		}
		*v = (Feature)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Feature")
	}
}

// Function is a single function on a Thrift service.
type Function struct {
	// Name of the Go function.
	Name string `json:"name,required"`
	// Name of the function as defined in the Thrift file.
	ThriftName string `json:"thriftName,required"`
	// List of arguments accepted by the function.
	//
	// This list is in the order specified by the user in the Thrift file.
	Arguments []*Argument `json:"arguments,required"`
	// Return type of the function, if any. If this is not set, the function
	// is a void function.
	ReturnType *Type `json:"returnType,omitempty"`
	// List of exceptions raised by the function.
	//
	// This list is in the order specified by the user in the Thrift file.
	Exceptions []*Argument `json:"exceptions,omitempty"`
	// Whether this function is oneway or not. This should be assumed to be
	// false unless explicitly stated otherwise. If this is true, the
	// returnType and exceptions will be null or empty.
	OneWay *bool `json:"oneWay,omitempty"`
	// Annotations defined on this function.
	//
	// Given,
	//
	//   void setValue(1: SetValueRequest req) (cache = "false")
	//
	// The annotations will be,
	//
	//  {
	//    "cache": "false",
	//  }
	Annotations map[string]string `json:"annotations,omitempty"`
}

type _List_Argument_ValueList []*Argument

func (v _List_Argument_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Argument_ValueList) Size() int {
	return len(v)
}

func (_List_Argument_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Argument_ValueList) Close() {}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a Function struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Function) ToWire() (wire.Value, error) {
	var (
		fields [7]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.ThriftName), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Arguments == nil {
		return w, errors.New("field Arguments of Function is required")
	}
	w, err = wire.NewValueList(_List_Argument_ValueList(v.Arguments)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.ReturnType != nil {
		w, err = v.ReturnType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Exceptions != nil {
		w, err = wire.NewValueList(_List_Argument_ValueList(v.Exceptions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.OneWay != nil {
		w, err = wire.NewValueBool(*(v.OneWay)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Argument_Read(w wire.Value) (*Argument, error) {
	var v Argument
	err := v.FromWire(w)
	return &v, err
}

func _List_Argument_Read(l wire.ValueList) ([]*Argument, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Argument, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Argument_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a Function struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Function struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Function
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Function) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false
	thriftNameIsSet := false
	argumentsIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.ThriftName, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				thriftNameIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Arguments, err = _List_Argument_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				argumentsIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.ReturnType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.Exceptions, err = _List_Argument_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.OneWay = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of Function is required")
	}

	if !thriftNameIsSet {
		return errors.New("field ThriftName of Function is required")
	}

	if !argumentsIsSet {
		return errors.New("field Arguments of Function is required")
	}

	return nil
}

// String returns a readable string representation of a Function
// struct.
func (v *Function) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [7]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("ThriftName: %v", v.ThriftName)
	i++
	fields[i] = fmt.Sprintf("Arguments: %v", v.Arguments)
	i++
	if v.ReturnType != nil {
		fields[i] = fmt.Sprintf("ReturnType: %v", v.ReturnType)
		i++
	}
	if v.Exceptions != nil {
		fields[i] = fmt.Sprintf("Exceptions: %v", v.Exceptions)
		i++
	}
	if v.OneWay != nil {
		fields[i] = fmt.Sprintf("OneWay: %v", *(v.OneWay))
		i++
	}
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}

	return fmt.Sprintf("Function{%v}", strings.Join(fields[:i], ", "))
}

func _List_Argument_Equals(lhs, rhs []*Argument) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this Function match the
// provided Function.
//
// This function performs a deep comparison.
func (v *Function) Equals(rhs *Function) bool {
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.ThriftName == rhs.ThriftName) {
		return false
	}
	if !_List_Argument_Equals(v.Arguments, rhs.Arguments) {
		return false
	}
	if !((v.ReturnType == nil && rhs.ReturnType == nil) || (v.ReturnType != nil && rhs.ReturnType != nil && v.ReturnType.Equals(rhs.ReturnType))) {
		return false
	}
	if !((v.Exceptions == nil && rhs.Exceptions == nil) || (v.Exceptions != nil && rhs.Exceptions != nil && _List_Argument_Equals(v.Exceptions, rhs.Exceptions))) {
		return false
	}
	if !_Bool_EqualsPtr(v.OneWay, rhs.OneWay) {
		return false
	}
	if !((v.Annotations == nil && rhs.Annotations == nil) || (v.Annotations != nil && rhs.Annotations != nil && _Map_String_String_Equals(v.Annotations, rhs.Annotations))) {
		return false
	}

	return true
}

// GetOneWay returns the value of OneWay if it is set or its
// zero value if it is unset.
func (v *Function) GetOneWay() (o bool) {
	if v.OneWay != nil {
		return *v.OneWay
	}

	return
}

// GenerateServiceRequest is a request to generate code for zero or more
// Thrift services.
type GenerateServiceRequest struct {
	// IDs of services for which code should be generated.
	//
	// Note that the services map contains information about both, the
	// services being generated and their transitive dependencies. Code should
	// only be generated for service IDs listed here.
	RootServices []ServiceID `json:"rootServices,required"`
	// Map of service ID to service.
	//
	// Any service IDs present in this request will have a corresponding
	// service definition in this map, including services for which code does
	// not need to be generated.
	Services map[ServiceID]*Service `json:"services,required"`
	// Map of module ID to module.
	//
	// Any module IDs present in the request will have a corresponding module
	// definition in this map.
	Modules map[ModuleID]*Module `json:"modules,required"`
}

type _List_ServiceID_ValueList []ServiceID

func (v _List_ServiceID_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ServiceID_ValueList) Size() int {
	return len(v)
}

func (_List_ServiceID_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_ServiceID_ValueList) Close() {}

type _Map_ServiceID_Service_MapItemList map[ServiceID]*Service

func (m _Map_ServiceID_Service_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ServiceID_Service_MapItemList) Size() int {
	return len(m)
}

func (_Map_ServiceID_Service_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_ServiceID_Service_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ServiceID_Service_MapItemList) Close() {}

type _Map_ModuleID_Module_MapItemList map[ModuleID]*Module

func (m _Map_ModuleID_Module_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_ModuleID_Module_MapItemList) Size() int {
	return len(m)
}

func (_Map_ModuleID_Module_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_ModuleID_Module_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_ModuleID_Module_MapItemList) Close() {}

// ToWire translates a GenerateServiceRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GenerateServiceRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.RootServices == nil {
		return w, errors.New("field RootServices of GenerateServiceRequest is required")
	}
	w, err = wire.NewValueList(_List_ServiceID_ValueList(v.RootServices)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Services == nil {
		return w, errors.New("field Services of GenerateServiceRequest is required")
	}
	w, err = wire.NewValueMap(_Map_ServiceID_Service_MapItemList(v.Services)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Modules == nil {
		return w, errors.New("field Modules of GenerateServiceRequest is required")
	}
	w, err = wire.NewValueMap(_Map_ModuleID_Module_MapItemList(v.Modules)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ServiceID_Read(w wire.Value) (ServiceID, error) {
	var x ServiceID
	err := x.FromWire(w)
	return x, err
}

func _List_ServiceID_Read(l wire.ValueList) ([]ServiceID, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]ServiceID, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ServiceID_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Service_Read(w wire.Value) (*Service, error) {
	var v Service
	err := v.FromWire(w)
	return &v, err
}

func _Map_ServiceID_Service_Read(m wire.MapItemList) (map[ServiceID]*Service, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[ServiceID]*Service, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ServiceID_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Service_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _ModuleID_Read(w wire.Value) (ModuleID, error) {
	var x ModuleID
	err := x.FromWire(w)
	return x, err
}

func _Module_Read(w wire.Value) (*Module, error) {
	var v Module
	err := v.FromWire(w)
	return &v, err
}

func _Map_ModuleID_Module_Read(m wire.MapItemList) (map[ModuleID]*Module, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[ModuleID]*Module, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _ModuleID_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Module_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a GenerateServiceRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GenerateServiceRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GenerateServiceRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GenerateServiceRequest) FromWire(w wire.Value) error {
	var err error

	rootServicesIsSet := false
	servicesIsSet := false
	modulesIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.RootServices, err = _List_ServiceID_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				rootServicesIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.Services, err = _Map_ServiceID_Service_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				servicesIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.Modules, err = _Map_ModuleID_Module_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				modulesIsSet = true
			}
		}
	}

	if !rootServicesIsSet {
		return errors.New("field RootServices of GenerateServiceRequest is required")
	}

	if !servicesIsSet {
		return errors.New("field Services of GenerateServiceRequest is required")
	}

	if !modulesIsSet {
		return errors.New("field Modules of GenerateServiceRequest is required")
	}

	return nil
}

// String returns a readable string representation of a GenerateServiceRequest
// struct.
func (v *GenerateServiceRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("RootServices: %v", v.RootServices)
	i++
	fields[i] = fmt.Sprintf("Services: %v", v.Services)
	i++
	fields[i] = fmt.Sprintf("Modules: %v", v.Modules)
	i++

	return fmt.Sprintf("GenerateServiceRequest{%v}", strings.Join(fields[:i], ", "))
}

func _List_ServiceID_Equals(lhs, rhs []ServiceID) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

func _Map_ServiceID_Service_Equals(lhs, rhs map[ServiceID]*Service) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func _Map_ModuleID_Module_Equals(lhs, rhs map[ModuleID]*Module) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this GenerateServiceRequest match the
// provided GenerateServiceRequest.
//
// This function performs a deep comparison.
func (v *GenerateServiceRequest) Equals(rhs *GenerateServiceRequest) bool {
	if !_List_ServiceID_Equals(v.RootServices, rhs.RootServices) {
		return false
	}
	if !_Map_ServiceID_Service_Equals(v.Services, rhs.Services) {
		return false
	}
	if !_Map_ModuleID_Module_Equals(v.Modules, rhs.Modules) {
		return false
	}

	return true
}

// GenerateServiceResponse is response to a GenerateServiceRequest.
type GenerateServiceResponse struct {
	// Map of file path to file contents.
	//
	// All paths MUST be relative to the output directory into which ThriftRW
	// is generating code. Plugins SHOULD NOT make any assumptions about the
	// absolute location of the directory.
	//
	// The paths MUST NOT contain the string ".." or the request will fail.
	Files map[string][]byte `json:"files,omitempty"`
}

type _Map_String_Binary_MapItemList map[string][]byte

func (m _Map_String_Binary_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueBinary(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Binary_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Binary_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) Close() {}

// ToWire translates a GenerateServiceResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GenerateServiceResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Files != nil {
		w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.Files)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_Binary_Read(m wire.MapItemList) (map[string][]byte, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string][]byte, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetBinary(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a GenerateServiceResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GenerateServiceResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GenerateServiceResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GenerateServiceResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Files, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GenerateServiceResponse
// struct.
func (v *GenerateServiceResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Files != nil {
		fields[i] = fmt.Sprintf("Files: %v", v.Files)
		i++
	}

	return fmt.Sprintf("GenerateServiceResponse{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_Binary_Equals(lhs, rhs map[string][]byte) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !bytes.Equal(lv, rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this GenerateServiceResponse match the
// provided GenerateServiceResponse.
//
// This function performs a deep comparison.
func (v *GenerateServiceResponse) Equals(rhs *GenerateServiceResponse) bool {
	if !((v.Files == nil && rhs.Files == nil) || (v.Files != nil && rhs.Files != nil && _Map_String_Binary_Equals(v.Files, rhs.Files))) {
		return false
	}

	return true
}

// HandshakeRequest is the initial request sent to the plugin as part of
// establishing communication and feature negotiation.
type HandshakeRequest struct {
}

// ToWire translates a HandshakeRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HandshakeRequest) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a HandshakeRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HandshakeRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HandshakeRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HandshakeRequest) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a HandshakeRequest
// struct.
func (v *HandshakeRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("HandshakeRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this HandshakeRequest match the
// provided HandshakeRequest.
//
// This function performs a deep comparison.
func (v *HandshakeRequest) Equals(rhs *HandshakeRequest) bool {

	return true
}

// HandshakeResponse is the response from the plugin for a HandshakeRequest.
type HandshakeResponse struct {
	// Name of the plugin. This MUST match the name of the plugin specified
	// over the command line or the program will fail.
	Name string `json:"name,required"`
	// Version of the plugin API.
	//
	// This MUST be set to API_VERSION by the plugin.
	APIVersion int32 `json:"apiVersion,required"`
	// List of features the plugin provides.
	Features []Feature `json:"features,required"`
	// Version of ThriftRW with which the plugin was built.
	//
	// This MUST be set to go.uber.org/thriftrw/version.Version by the plugin
	// explicitly.
	LibraryVersion *string `json:"libraryVersion,omitempty"`
}

type _List_Feature_ValueList []Feature

func (v _List_Feature_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Feature_ValueList) Size() int {
	return len(v)
}

func (_List_Feature_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_Feature_ValueList) Close() {}

// ToWire translates a HandshakeResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HandshakeResponse) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI32(v.APIVersion), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Features == nil {
		return w, errors.New("field Features of HandshakeResponse is required")
	}
	w, err = wire.NewValueList(_List_Feature_ValueList(v.Features)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.LibraryVersion != nil {
		w, err = wire.NewValueString(*(v.LibraryVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Feature_Read(w wire.Value) (Feature, error) {
	var v Feature
	err := v.FromWire(w)
	return v, err
}

func _List_Feature_Read(l wire.ValueList) ([]Feature, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]Feature, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Feature_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a HandshakeResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HandshakeResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HandshakeResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HandshakeResponse) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false
	apiVersionIsSet := false
	featuresIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				v.APIVersion, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				apiVersionIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Features, err = _List_Feature_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				featuresIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.LibraryVersion = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of HandshakeResponse is required")
	}

	if !apiVersionIsSet {
		return errors.New("field APIVersion of HandshakeResponse is required")
	}

	if !featuresIsSet {
		return errors.New("field Features of HandshakeResponse is required")
	}

	return nil
}

// String returns a readable string representation of a HandshakeResponse
// struct.
func (v *HandshakeResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("APIVersion: %v", v.APIVersion)
	i++
	fields[i] = fmt.Sprintf("Features: %v", v.Features)
	i++
	if v.LibraryVersion != nil {
		fields[i] = fmt.Sprintf("LibraryVersion: %v", *(v.LibraryVersion))
		i++
	}

	return fmt.Sprintf("HandshakeResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_Feature_Equals(lhs, rhs []Feature) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this HandshakeResponse match the
// provided HandshakeResponse.
//
// This function performs a deep comparison.
func (v *HandshakeResponse) Equals(rhs *HandshakeResponse) bool {
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.APIVersion == rhs.APIVersion) {
		return false
	}
	if !_List_Feature_Equals(v.Features, rhs.Features) {
		return false
	}
	if !_String_EqualsPtr(v.LibraryVersion, rhs.LibraryVersion) {
		return false
	}

	return true
}

// GetLibraryVersion returns the value of LibraryVersion if it is set or its
// zero value if it is unset.
func (v *HandshakeResponse) GetLibraryVersion() (o string) {
	if v.LibraryVersion != nil {
		return *v.LibraryVersion
	}

	return
}

// Module is a module generated from a single Thrift file. Each module
// corresponds to exactly one Thrift file and contains all the types and
// constants defined in that Thrift file.
type Module struct {
	// Import path for the package defining the types for this module.
	ImportPath string `json:"importPath,required"`
	// Path to the directory containing the code for this module.
	//
	// The path is relative to the output directory into which ThriftRW is
	// generating code. Plugins SHOULD NOT make any assumptions about the
	// absolute location of the directory.
	Directory string `json:"directory,required"`
}

// ToWire translates a Module struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Module) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.ImportPath), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.Directory), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Module struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Module struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Module
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Module) FromWire(w wire.Value) error {
	var err error

	importPathIsSet := false
	directoryIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.ImportPath, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				importPathIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Directory, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				directoryIsSet = true
			}
		}
	}

	if !importPathIsSet {
		return errors.New("field ImportPath of Module is required")
	}

	if !directoryIsSet {
		return errors.New("field Directory of Module is required")
	}

	return nil
}

// String returns a readable string representation of a Module
// struct.
func (v *Module) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("ImportPath: %v", v.ImportPath)
	i++
	fields[i] = fmt.Sprintf("Directory: %v", v.Directory)
	i++

	return fmt.Sprintf("Module{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Module match the
// provided Module.
//
// This function performs a deep comparison.
func (v *Module) Equals(rhs *Module) bool {
	if !(v.ImportPath == rhs.ImportPath) {
		return false
	}
	if !(v.Directory == rhs.Directory) {
		return false
	}

	return true
}

// ModuleID is an arbitrary unique identifier to reference the different
// modules in this request.
type ModuleID int32

// ToWire translates ModuleID into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v ModuleID) ToWire() (wire.Value, error) {
	x := (int32)(v)
	return wire.NewValueI32(x), error(nil)
}

// String returns a readable string representation of ModuleID.
func (v ModuleID) String() string {
	x := (int32)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes ModuleID from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *ModuleID) FromWire(w wire.Value) error {
	x, err := w.GetI32(), error(nil)
	*v = (ModuleID)(x)
	return err
}

// Equals returns true if this ModuleID is equal to the provided
// ModuleID.
func (lhs ModuleID) Equals(rhs ModuleID) bool {
	return (lhs == rhs)
}

// Service is a service defined by the user in the Thrift file.
type Service struct {
	// Name of the Thrift service in Go code.
	Name string `json:"name,required"`
	// Name of the service as defined in the Thrift file.
	ThriftName string `json:"thriftName,required"`
	// ID of the parent service.
	ParentID *ServiceID `json:"parentID,omitempty"`
	// List of functions defined for this service.
	Functions []*Function `json:"functions,required"`
	// ID of the module where this service was declared.
	ModuleID ModuleID `json:"moduleID,required"`
	// Annotations defined on this service.
	//
	// Given,
	//
	//   service KeyValue {
	//   } (private = "true")
	//
	// The annotations will be,
	//
	//  {
	//    "private": "true",
	//  }
	Annotations map[string]string `json:"annotations,omitempty"`
}

type _List_Function_ValueList []*Function

func (v _List_Function_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Function_ValueList) Size() int {
	return len(v)
}

func (_List_Function_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Function_ValueList) Close() {}

// ToWire translates a Service struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Service) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 7, Value: w}
	i++

	w, err = wire.NewValueString(v.ThriftName), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.ParentID != nil {
		w, err = v.ParentID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Functions == nil {
		return w, errors.New("field Functions of Service is required")
	}
	w, err = wire.NewValueList(_List_Function_ValueList(v.Functions)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++

	w, err = v.ModuleID.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Function_Read(w wire.Value) (*Function, error) {
	var v Function
	err := v.FromWire(w)
	return &v, err
}

func _List_Function_Read(l wire.ValueList) ([]*Function, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Function, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Function_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Service struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Service struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Service
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Service) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false
	thriftNameIsSet := false

	functionsIsSet := false
	moduleIDIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 7:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.ThriftName, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				thriftNameIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x ServiceID
				x, err = _ServiceID_Read(field.Value)
				v.ParentID = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.Functions, err = _List_Function_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				functionsIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TI32 {
				v.ModuleID, err = _ModuleID_Read(field.Value)
				if err != nil {
					return err
				}
				moduleIDIsSet = true
			}
		case 8:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of Service is required")
	}

	if !thriftNameIsSet {
		return errors.New("field ThriftName of Service is required")
	}

	if !functionsIsSet {
		return errors.New("field Functions of Service is required")
	}

	if !moduleIDIsSet {
		return errors.New("field ModuleID of Service is required")
	}

	return nil
}

// String returns a readable string representation of a Service
// struct.
func (v *Service) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("ThriftName: %v", v.ThriftName)
	i++
	if v.ParentID != nil {
		fields[i] = fmt.Sprintf("ParentID: %v", *(v.ParentID))
		i++
	}
	fields[i] = fmt.Sprintf("Functions: %v", v.Functions)
	i++
	fields[i] = fmt.Sprintf("ModuleID: %v", v.ModuleID)
	i++
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}

	return fmt.Sprintf("Service{%v}", strings.Join(fields[:i], ", "))
}

func _ServiceID_EqualsPtr(lhs, rhs *ServiceID) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _List_Function_Equals(lhs, rhs []*Function) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Service match the
// provided Service.
//
// This function performs a deep comparison.
func (v *Service) Equals(rhs *Service) bool {
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.ThriftName == rhs.ThriftName) {
		return false
	}
	if !_ServiceID_EqualsPtr(v.ParentID, rhs.ParentID) {
		return false
	}
	if !_List_Function_Equals(v.Functions, rhs.Functions) {
		return false
	}
	if !(v.ModuleID == rhs.ModuleID) {
		return false
	}
	if !((v.Annotations == nil && rhs.Annotations == nil) || (v.Annotations != nil && rhs.Annotations != nil && _Map_String_String_Equals(v.Annotations, rhs.Annotations))) {
		return false
	}

	return true
}

// GetParentID returns the value of ParentID if it is set or its
// zero value if it is unset.
func (v *Service) GetParentID() (o ServiceID) {
	if v.ParentID != nil {
		return *v.ParentID
	}

	return
}

// ServiceID is an arbitrary unique identifier to reference the different
// services in this request.
type ServiceID int32

// ToWire translates ServiceID into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v ServiceID) ToWire() (wire.Value, error) {
	x := (int32)(v)
	return wire.NewValueI32(x), error(nil)
}

// String returns a readable string representation of ServiceID.
func (v ServiceID) String() string {
	x := (int32)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes ServiceID from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *ServiceID) FromWire(w wire.Value) error {
	x, err := w.GetI32(), error(nil)
	*v = (ServiceID)(x)
	return err
}

// Equals returns true if this ServiceID is equal to the provided
// ServiceID.
func (lhs ServiceID) Equals(rhs ServiceID) bool {
	return (lhs == rhs)
}

// SimpleType is a standalone native Go type.
type SimpleType int32

const (
	SimpleTypeBool        SimpleType = 1
	SimpleTypeByte        SimpleType = 2
	SimpleTypeInt8        SimpleType = 3
	SimpleTypeInt16       SimpleType = 4
	SimpleTypeInt32       SimpleType = 5
	SimpleTypeInt64       SimpleType = 6
	SimpleTypeFloat64     SimpleType = 7
	SimpleTypeString      SimpleType = 8
	SimpleTypeStructEmpty SimpleType = 9
)

// SimpleType_Values returns all recognized values of SimpleType.
func SimpleType_Values() []SimpleType {
	return []SimpleType{
		SimpleTypeBool,
		SimpleTypeByte,
		SimpleTypeInt8,
		SimpleTypeInt16,
		SimpleTypeInt32,
		SimpleTypeInt64,
		SimpleTypeFloat64,
		SimpleTypeString,
		SimpleTypeStructEmpty,
	}
}

// UnmarshalText tries to decode SimpleType from a byte slice
// containing its name.
//
//   var v SimpleType
//   err := v.UnmarshalText([]byte("BOOL"))
func (v *SimpleType) UnmarshalText(value []byte) error {
	switch string(value) {
	case "BOOL":
		*v = SimpleTypeBool
		return nil
	case "BYTE":
		*v = SimpleTypeByte
		return nil
	case "INT8":
		*v = SimpleTypeInt8
		return nil
	case "INT16":
		*v = SimpleTypeInt16
		return nil
	case "INT32":
		*v = SimpleTypeInt32
		return nil
	case "INT64":
		*v = SimpleTypeInt64
		return nil
	case "FLOAT64":
		*v = SimpleTypeFloat64
		return nil
	case "STRING":
		*v = SimpleTypeString
		return nil
	case "STRUCT_EMPTY":
		*v = SimpleTypeStructEmpty
		return nil
	default:
		return fmt.Errorf("unknown enum value %q for %q", value, "SimpleType")
	}
}

// Ptr returns a pointer to this enum value.
func (v SimpleType) Ptr() *SimpleType {
	return &v
}

// ToWire translates SimpleType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v SimpleType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes SimpleType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return SimpleType(0), err
//   }
//
//   var v SimpleType
//   if err := v.FromWire(x); err != nil {
//     return SimpleType(0), err
//   }
//   return v, nil
func (v *SimpleType) FromWire(w wire.Value) error {
	*v = (SimpleType)(w.GetI32())
	return nil
}

// String returns a readable string representation of SimpleType.
func (v SimpleType) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "BOOL"
	case 2:
		return "BYTE"
	case 3:
		return "INT8"
	case 4:
		return "INT16"
	case 5:
		return "INT32"
	case 6:
		return "INT64"
	case 7:
		return "FLOAT64"
	case 8:
		return "STRING"
	case 9:
		return "STRUCT_EMPTY"
	}
	return fmt.Sprintf("SimpleType(%d)", w)
}

// Equals returns true if this SimpleType value matches the provided
// value.
func (v SimpleType) Equals(rhs SimpleType) bool {
	return v == rhs
}

// MarshalJSON serializes SimpleType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v SimpleType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"BOOL\""), nil
	case 2:
		return ([]byte)("\"BYTE\""), nil
	case 3:
		return ([]byte)("\"INT8\""), nil
	case 4:
		return ([]byte)("\"INT16\""), nil
	case 5:
		return ([]byte)("\"INT32\""), nil
	case 6:
		return ([]byte)("\"INT64\""), nil
	case 7:
		return ([]byte)("\"FLOAT64\""), nil
	case 8:
		return ([]byte)("\"STRING\""), nil
	case 9:
		return ([]byte)("\"STRUCT_EMPTY\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode SimpleType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *SimpleType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "SimpleType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "SimpleType")
		}
		*v = (SimpleType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "SimpleType")
	}
}

// Type is a reference to a Go type which may be native or user defined.
type Type struct {
	SimpleType *SimpleType `json:"simpleType,omitempty"`
	// Slice of a type
	//
	// []$sliceType
	SliceType *Type `json:"sliceType,omitempty"`
	// Slice of key-value pairs of a pair of types.
	//
	// []struct{Key $left, Value $right}
	KeyValueSliceType *TypePair `json:"keyValueSliceType,omitempty"`
	// Map of a pair of types.
	//
	// map[$left]$right
	MapType *TypePair `json:"mapType,omitempty"`
	// Reference to a user-defined type.
	ReferenceType *TypeReference `json:"referenceType,omitempty"`
	// Pointer to a type.
	PointerType *Type `json:"pointerType,omitempty"`
}

// ToWire translates a Type struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Type) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.SimpleType != nil {
		w, err = v.SimpleType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.SliceType != nil {
		w, err = v.SliceType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.KeyValueSliceType != nil {
		w, err = v.KeyValueSliceType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.MapType != nil {
		w, err = v.MapType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.ReferenceType != nil {
		w, err = v.ReferenceType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.PointerType != nil {
		w, err = v.PointerType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Type should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _SimpleType_Read(w wire.Value) (SimpleType, error) {
	var v SimpleType
	err := v.FromWire(w)
	return v, err
}

func _TypePair_Read(w wire.Value) (*TypePair, error) {
	var v TypePair
	err := v.FromWire(w)
	return &v, err
}

func _TypeReference_Read(w wire.Value) (*TypeReference, error) {
	var v TypeReference
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Type struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Type struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Type
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Type) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x SimpleType
				x, err = _SimpleType_Read(field.Value)
				v.SimpleType = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.SliceType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.KeyValueSliceType, err = _TypePair_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.MapType, err = _TypePair_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TStruct {
				v.ReferenceType, err = _TypeReference_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TStruct {
				v.PointerType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.SimpleType != nil {
		count++
	}
	if v.SliceType != nil {
		count++
	}
	if v.KeyValueSliceType != nil {
		count++
	}
	if v.MapType != nil {
		count++
	}
	if v.ReferenceType != nil {
		count++
	}
	if v.PointerType != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Type should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Type
// struct.
func (v *Type) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.SimpleType != nil {
		fields[i] = fmt.Sprintf("SimpleType: %v", *(v.SimpleType))
		i++
	}
	if v.SliceType != nil {
		fields[i] = fmt.Sprintf("SliceType: %v", v.SliceType)
		i++
	}
	if v.KeyValueSliceType != nil {
		fields[i] = fmt.Sprintf("KeyValueSliceType: %v", v.KeyValueSliceType)
		i++
	}
	if v.MapType != nil {
		fields[i] = fmt.Sprintf("MapType: %v", v.MapType)
		i++
	}
	if v.ReferenceType != nil {
		fields[i] = fmt.Sprintf("ReferenceType: %v", v.ReferenceType)
		i++
	}
	if v.PointerType != nil {
		fields[i] = fmt.Sprintf("PointerType: %v", v.PointerType)
		i++
	}

	return fmt.Sprintf("Type{%v}", strings.Join(fields[:i], ", "))
}

func _SimpleType_EqualsPtr(lhs, rhs *SimpleType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Type match the
// provided Type.
//
// This function performs a deep comparison.
func (v *Type) Equals(rhs *Type) bool {
	if !_SimpleType_EqualsPtr(v.SimpleType, rhs.SimpleType) {
		return false
	}
	if !((v.SliceType == nil && rhs.SliceType == nil) || (v.SliceType != nil && rhs.SliceType != nil && v.SliceType.Equals(rhs.SliceType))) {
		return false
	}
	if !((v.KeyValueSliceType == nil && rhs.KeyValueSliceType == nil) || (v.KeyValueSliceType != nil && rhs.KeyValueSliceType != nil && v.KeyValueSliceType.Equals(rhs.KeyValueSliceType))) {
		return false
	}
	if !((v.MapType == nil && rhs.MapType == nil) || (v.MapType != nil && rhs.MapType != nil && v.MapType.Equals(rhs.MapType))) {
		return false
	}
	if !((v.ReferenceType == nil && rhs.ReferenceType == nil) || (v.ReferenceType != nil && rhs.ReferenceType != nil && v.ReferenceType.Equals(rhs.ReferenceType))) {
		return false
	}
	if !((v.PointerType == nil && rhs.PointerType == nil) || (v.PointerType != nil && rhs.PointerType != nil && v.PointerType.Equals(rhs.PointerType))) {
		return false
	}

	return true
}

// GetSimpleType returns the value of SimpleType if it is set or its
// zero value if it is unset.
func (v *Type) GetSimpleType() (o SimpleType) {
	if v.SimpleType != nil {
		return *v.SimpleType
	}

	return
}

// TypePair is a pair of two types.
type TypePair struct {
	Left  *Type `json:"left,required"`
	Right *Type `json:"right,required"`
}

// ToWire translates a TypePair struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TypePair) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Left == nil {
		return w, errors.New("field Left of TypePair is required")
	}
	w, err = v.Left.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Right == nil {
		return w, errors.New("field Right of TypePair is required")
	}
	w, err = v.Right.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TypePair struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TypePair struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TypePair
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TypePair) FromWire(w wire.Value) error {
	var err error

	leftIsSet := false
	rightIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Left, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				leftIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Right, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				rightIsSet = true
			}
		}
	}

	if !leftIsSet {
		return errors.New("field Left of TypePair is required")
	}

	if !rightIsSet {
		return errors.New("field Right of TypePair is required")
	}

	return nil
}

// String returns a readable string representation of a TypePair
// struct.
func (v *TypePair) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Left: %v", v.Left)
	i++
	fields[i] = fmt.Sprintf("Right: %v", v.Right)
	i++

	return fmt.Sprintf("TypePair{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TypePair match the
// provided TypePair.
//
// This function performs a deep comparison.
func (v *TypePair) Equals(rhs *TypePair) bool {
	if !v.Left.Equals(rhs.Left) {
		return false
	}
	if !v.Right.Equals(rhs.Right) {
		return false
	}

	return true
}

// TypeReference is a reference to a user-defined type.
type TypeReference struct {
	Name string `json:"name,required"`
	// Import path for the package defining this type.
	ImportPath string `json:"importPath,required"`
	// Annotations defined on this type.
	//
	// Note that these are the Thrift annotations listed after the type
	// declaration in the Thrift file.
	//
	// Given,
	//
	//   struct User {
	//     1: required i32 id
	//     2: required string name
	//   } (key = "id", validate)
	//
	// The annotations will be,
	//
	//   {
	//     "key": "id",
	//     "validate": "",
	//   }
	Annotations map[string]string `json:"annotations,omitempty"`
}

// ToWire translates a TypeReference struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TypeReference) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.ImportPath), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Annotations != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Annotations)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TypeReference struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TypeReference struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TypeReference
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TypeReference) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false
	importPathIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.ImportPath, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				importPathIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TMap {
				v.Annotations, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of TypeReference is required")
	}

	if !importPathIsSet {
		return errors.New("field ImportPath of TypeReference is required")
	}

	return nil
}

// String returns a readable string representation of a TypeReference
// struct.
func (v *TypeReference) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("ImportPath: %v", v.ImportPath)
	i++
	if v.Annotations != nil {
		fields[i] = fmt.Sprintf("Annotations: %v", v.Annotations)
		i++
	}

	return fmt.Sprintf("TypeReference{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TypeReference match the
// provided TypeReference.
//
// This function performs a deep comparison.
func (v *TypeReference) Equals(rhs *TypeReference) bool {
	if !(v.Name == rhs.Name) {
		return false
	}
	if !(v.ImportPath == rhs.ImportPath) {
		return false
	}
	if !((v.Annotations == nil && rhs.Annotations == nil) || (v.Annotations != nil && rhs.Annotations != nil && _Map_String_String_Equals(v.Annotations, rhs.Annotations))) {
		return false
	}

	return true
}
